/*
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 50641
 Source Host           : localhost
 Source Database       : codergroup

 Target Server Type    : MySQL
 Target Server Version : 50641
 File Encoding         : utf-8

 Date: 06/01/2019 22:42:51 PM
*/

SET NAMES utf8;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
--  Table structure for `answer`
-- ----------------------------
DROP TABLE IF EXISTS `answer`;
CREATE TABLE `answer` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `cai_size` int(11) DEFAULT NULL,
  `comment_size` int(11) DEFAULT NULL,
  `content` longtext NOT NULL,
  `create_time` datetime DEFAULT NULL,
  `is_accepted` int(11) DEFAULT NULL,
  `pid` bigint(20) DEFAULT NULL,
  `status` varchar(255) DEFAULT NULL,
  `zan_size` int(11) DEFAULT NULL,
  `question_id` bigint(20) DEFAULT NULL,
  `reply_user_id` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=48 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `answer`
-- ----------------------------
BEGIN;
INSERT INTO `answer` VALUES ('1', '0', '0', '<p>测试<br></p>', '2018-06-15 17:09:54', '1', null, 'publish', '0', '1', '1', '1'), ('2', '0', '0', '<p><img alt=\"图片.png\" src=\"http://cdn.codergroup.cn/uploads/2018/8/4/debug96/1533353348759\" width=\"1328\" height=\"142\"><br></p>', '2018-08-04 11:29:30', '0', null, 'publish', '0', '2', '1', '22'), ('3', '0', '0', '<p>张彪是谁？？？？？</p>', '2018-10-10 13:05:05', '0', null, 'publish', '0', '3', '71', '71'), ('4', '0', '0', '<p>！！！<br><br></p>', '2018-10-10 13:05:05', '1', null, 'publish', '1', '3', '71', '72'), ('5', '1', '0', '<p>是啊</p>', '2018-10-12 14:06:42', '0', null, 'publish', '1', '3', '71', '75'), ('6', '0', '0', '<p>刘</p>', '2018-10-12 14:09:06', '1', null, 'publish', '0', '4', '75', '75'), ('7', '0', '0', '<p>还时代峰峻绝大部分将</p>', '2018-10-17 10:38:27', '1', null, 'publish', '0', '6', '71', '71'), ('8', '0', '3', '<p>正在进行测试</p>', '2018-10-27 20:21:18', '1', null, 'publish', '0', '9', '82', '82'), ('9', '0', '0', '感谢配合', '2018-10-27 20:21:31', '0', '8', 'publish', '0', '9', '82', '82'), ('10', '0', '0', '<p>是，没跑</p>', '2018-10-30 20:25:18', '0', null, 'publish', '0', '3', '71', '71'), ('11', '1', '2', '<p>呵呵</p>', '2018-11-01 11:47:43', '0', null, 'publish', '1', '8', '71', '71'), ('12', '0', '0', '<p>挂佛挡杀佛</p>', '2018-11-01 18:58:50', '0', null, 'publish', '1', '4', '75', '75'), ('13', '0', '0', '配置\n', '2018-11-01 19:04:26', '0', '8', 'publish', '0', '9', '82', '75'), ('14', '0', '0', '放大法师', '2018-11-05 17:16:48', '0', '11', 'publish', '0', '8', '71', '75'), ('15', '0', '0', '股份的水电费', '2018-11-05 17:17:04', '0', '11', 'publish', '0', '8', '71', '75'), ('16', '0', '0', '@哈哈哈哈 大概花费大概多少', '2018-11-05 20:35:47', '0', '8', 'publish', '0', '9', '82', '75'), ('17', '0', '0', '<p>发的所发生的</p>', '2018-11-05 21:00:16', '0', null, 'publish', '0', '9', '82', '75'), ('18', '0', '1', '<p>法法</p>', '2018-11-05 21:04:07', '1', null, 'publish', '0', '10', '75', '75'), ('19', '0', '0', '<p>vcFsdfdasf</p>', '2018-11-05 21:05:11', '0', null, 'publish', '0', '10', '75', '75'), ('20', '0', '0', '<p>fds</p>', '2018-11-06 14:34:02', '0', null, 'publish', '0', '10', '75', '75'), ('21', '0', '0', '个非官方大哥', '2018-11-06 14:34:08', '0', '18', 'publish', '0', '10', '75', '75'), ('22', '0', '0', '<p>上的撒打发</p>', '2018-11-07 18:25:00', '1', null, 'publish', '0', '5', '78', '78'), ('23', '0', '1', '<p>no,fyj is a bsbsbssbsbsbsbsbsbsbsbasfsfsf</p>', '2018-11-08 20:43:40', '0', null, 'publish', '0', '23', '77', '77'), ('24', '1', '1', '<p>经核实对方</p>', '2018-11-08 23:31:10', '0', null, 'publish', '1', '23', '77', '71'), ('25', '0', '0', 'sdfghjkl', '2018-11-09 20:08:49', '0', '24', 'publish', '0', '23', '71', '75'), ('26', '0', '0', '来', '2018-11-10 20:45:17', '0', '23', 'publish', '0', '23', '77', '71'), ('27', '0', '0', '<p>11</p>', '2018-11-14 13:16:51', '0', null, 'publish', '0', '19', '78', '1'), ('28', '1', '0', '<p>11</p>', '2018-11-18 21:31:20', '0', null, 'publish', '1', '24', '98', '101'), ('29', '1', '1', '<p>2</p>', '2018-11-18 21:31:47', '0', null, 'publish', '1', '24', '98', '101'), ('30', '0', '0', '121', '2018-11-18 21:32:00', '0', '29', 'publish', '0', '24', '101', '101'), ('31', '1', '0', '<p>21</p>', '2018-11-18 21:32:09', '0', null, 'publish', '0', '24', '98', '101'), ('32', '0', '5', '<p>dada</p>', '2018-11-24 20:18:23', '1', null, 'publish', '1', '25', '104', '104'), ('33', '0', '0', 'sadasd', '2018-11-24 20:18:35', '0', '32', 'publish', '0', '25', '104', '104'), ('34', '0', '0', '@sadasd', '2018-11-24 20:18:59', '0', '32', 'publish', '0', '25', '104', '104'), ('35', '0', '0', '<p>saff</p>', '2018-12-31 18:11:16', '0', null, 'publish', '0', '24', '98', '114'), ('36', '1', '0', '<p>???????????????????<img alt=\"background.png\" src=\"http://cdn.codergroup.cn/uploads/2019/1/8/Empirefree/1546924326000\" width=\"60\" height=\"25\"></p>', '2019-01-08 13:12:07', '1', null, 'publish', '1', '26', '115', '115'), ('37', '0', '2', '<p>1111</p>', '2019-03-01 17:54:20', '0', null, 'publish', '0', '22', '78', '111'), ('38', '0', '0', '<p>111</p>', '2019-03-04 17:35:03', '0', null, 'publish', '0', '26', '115', '111'), ('39', '0', '0', '555', '2019-03-21 11:20:11', '0', '37', 'publish', '0', '22', '111', '113'), ('40', '0', '0', '8888', '2019-03-21 11:20:26', '0', '37', 'publish', '0', '22', '111', '113'), ('41', '0', '3', '<p>阿萨斯阿萨</p>', '2019-04-02 09:29:44', '1', null, 'publish', '0', '28', '113', '113'), ('42', '0', '0', '99999', '2019-04-02 09:30:46', '0', '41', 'publish', '0', '28', '113', '113'), ('43', '0', '0', '888888888888', '2019-04-04 09:41:44', '0', '32', 'publish', '0', '25', '104', '113'), ('44', '0', '0', 'alert(xxxxx);', '2019-04-04 09:42:10', '0', '32', 'publish', '0', '25', '104', '113'), ('45', '0', '0', 'alert(\'xxxxxx\');', '2019-04-04 09:42:23', '0', '32', 'publish', '0', '25', '104', '113'), ('46', '0', '0', '3333', '2019-04-12 09:37:02', '0', '41', 'publish', '0', '28', '113', '113'), ('47', '0', '0', '555', '2019-04-12 09:37:08', '0', '41', 'publish', '0', '28', '113', '113');
COMMIT;

-- ----------------------------
--  Table structure for `answer_cai`
-- ----------------------------
DROP TABLE IF EXISTS `answer_cai`;
CREATE TABLE `answer_cai` (
  `answer_id` bigint(20) NOT NULL,
  `cai_id` bigint(20) NOT NULL,
  UNIQUE KEY `UK_r7pma6ib5mc7vmmav21bxhxsm` (`cai_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `answer_cai`
-- ----------------------------
BEGIN;
INSERT INTO `answer_cai` VALUES ('5', '16'), ('11', '28'), ('24', '37'), ('31', '40'), ('29', '41'), ('28', '42'), ('36', '51');
COMMIT;

-- ----------------------------
--  Table structure for `answer_zan`
-- ----------------------------
DROP TABLE IF EXISTS `answer_zan`;
CREATE TABLE `answer_zan` (
  `answer_id` bigint(20) NOT NULL,
  `zan_id` bigint(20) NOT NULL,
  UNIQUE KEY `UK_gi6jlruc76s5sotrdj5lama07` (`zan_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `answer_zan`
-- ----------------------------
BEGIN;
INSERT INTO `answer_zan` VALUES ('4', '47'), ('5', '51'), ('12', '72'), ('11', '78'), ('24', '96'), ('28', '105'), ('29', '106'), ('32', '110'), ('36', '121');
COMMIT;

-- ----------------------------
--  Table structure for `article`
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `bookmark_size` int(11) DEFAULT NULL,
  `comment_size` int(11) DEFAULT NULL,
  `content` longtext NOT NULL,
  `create_time` datetime DEFAULT NULL,
  `guid` varchar(100) DEFAULT NULL,
  `is_allow_comment` int(11) DEFAULT NULL,
  `is_sticky` int(11) DEFAULT NULL,
  `status` varchar(10) DEFAULT NULL,
  `summary` varchar(2000) NOT NULL,
  `tags` varchar(100) DEFAULT NULL,
  `title` varchar(200) NOT NULL,
  `update_time` datetime DEFAULT NULL,
  `view_size` int(11) DEFAULT NULL,
  `zan_size` int(11) DEFAULT NULL,
  `category_id` bigint(20) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=10518 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `article`
-- ----------------------------
BEGIN;
INSERT INTO `article` VALUES ('10000', '0', '0', '<p>　&nbsp; &nbsp;我如果爱你——<br></p><p>　　绝不像攀援的凌霄花，</p><p>　　借你的高枝炫耀自己：</p><p>　　我如果爱你——</p><p>　　绝不学痴情的鸟儿，</p><p>　　为绿荫重复单调的歌曲；</p><p>　　也不止像泉源，</p><p>　　常年送来清凉的慰籍；</p><p>　　也不止像险峰，增加你的高度，衬托你的威仪。</p><p>　　甚至日光。</p><p>　　甚至春雨。</p><p>　　不，这些都还不够！</p><p>　　我必须是你近旁的一株木棉，</p><p>　　做为树的形象和你站在一起。</p><p>　　根，紧握在地下，</p><p>　　叶，相触在云里。</p><p>　　每一阵风过，</p><p>　　我们都互相致意，</p><p>　　但没有人</p><p>　　听懂我们的言语。</p><p>　　你有你的铜枝铁干，</p><p>　　像刀，像剑，</p><p>　　也像戟，</p><p>　　我有我的红硕花朵，</p><p>　　像沉重的叹息，</p><p>　　又像英勇的火炬，</p><p>　　我们分担寒潮、风雷、霹雳；</p><p>　　我们共享雾霭流岚、虹霓，</p><p>　　仿佛永远分离，</p><p>　　却又终身相依，</p><p>　　这才是伟大的爱情，</p><p>　　坚贞就在这里：</p><p>　　不仅爱你伟岸的身躯，</p><p>　　也爱你坚持的位置，脚下的土地。</p>', '2018-06-14 03:13:33', '/articles/10000', '0', '0', 'publish', '　   我如果爱你——　　绝不像攀援的凌霄花，　　借你的高枝炫耀自己：　　我如果爱你——　　绝不学痴情的鸟儿，　　为绿荫重复单调的歌曲；　　也不止像泉源，　　常年送来清凉的慰籍；　　也不止像险峰，增加你的高度，衬托你的威仪。　　甚至日光。　　甚至春雨。　　不，这些都还不够！　　我必须是你近旁的一株木棉，　　做为树的形象和你站在一起。　　根，紧握在地下，　　叶，相触在云里。　　每一阵风过，　　我们都互相致意，　　但没有人　　听懂我们的言语。　　你有你的铜枝铁干，　　像刀，像剑，　　也像戟，　　我有我的红硕花朵，　　像沉重的叹息，　　又像英勇的火炬，　　我们分担寒潮、风雷、霹雳；　　我们共享雾霭流岚、虹霓，　　仿佛永远分离，　　却又终身相依，　　这才是伟大的爱情，　　坚贞就在这里：　　不仅爱你伟岸的身躯，　　也爱你坚持的位置，脚下的土地。', '现代诗,诗歌,舒婷', '舒婷《致橡树》', '2018-11-20 08:30:56', '30', '1', '10000', '1'), ('10001', '0', '1', '<p><b><span style=\"color: rgb(79, 79, 79);\">1、面向对象的特征有哪些方面？</span><span style=\"color: rgb(79, 79, 79);\">&nbsp;</span></b><br></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：面向对象的特征主要有以下几个方面：&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">-<b> 抽象</b>：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">-<b> 继承</b>：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">- <b>封装</b>：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">- <b>多态性</b>：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</span></p><p><br></p><p><b><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">2、访问修饰符public,private,protected,以及不写（默认）时的区别？</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></b></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：</span></p><table><colgroup><col width=\"19.928400954653938%\"><col width=\"19.928400954653938%\"><col width=\"20.047732696897373%\"><col width=\"20.167064439140812%\"><col width=\"20.286396181384248%\"></colgroup><thead><tr><th>修饰符</th><th>当前类</th><th>同&nbsp;包</th><th>子&nbsp;类</th><th>其他包</th></tr></thead><tbody><tr><td style=\"text-align: left;\">public</td><td style=\"text-align: left;\">√</td><td style=\"text-align: left;\">√</td><td style=\"text-align: left;\">√</td><td style=\"text-align: left;\">√</td></tr><tr><td style=\"text-align: left;\">protected</td><td style=\"text-align: left;\">√</td><td style=\"text-align: left;\">√</td><td style=\"text-align: left;\">√</td><td style=\"text-align: left;\">×</td></tr><tr><td style=\"text-align: left;\">default</td><td style=\"text-align: left;\">√</td><td style=\"text-align: left;\">√</td><td style=\"text-align: left;\">×</td><td style=\"text-align: left;\">×</td></tr><tr><td style=\"text-align: left;\">private</td><td style=\"text-align: left;\">√</td><td style=\"text-align: left;\">×</td><td style=\"text-align: left;\">×</td><td style=\"text-align: left;\">×</td></tr></tbody></table><p style=\"text-align: justify;\">类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。</p><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>3、String 是最基本的数据类型吗？&nbsp;</b><br>答：不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。</p><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>4、float f=3.4;是否正确？&nbsp;</b><br>答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，<span style=\"color: rgb(227, 55, 55);\">因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F</span>;。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？&nbsp;</b><br>答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型，<span style=\"color: rgb(226, 139, 65);\">因此s1+1运算结果也是int 型</span>，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，<span style=\"color: rgb(226, 139, 65);\">因为s1+= 1;相当于s1 = (short)(s1 + 1);</span>其中有隐含的强制类型转换。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>6、Java有没有goto？&nbsp;</b><br>答：goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）</p><p><b><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">7、int和Integer有什么区别？</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></b></p><p><font color=\"#4f4f4f\"><b>参考这里：</b></font><span></span><a href=\"https://liuyanzhao.com/5318.html\" target=\"_blank\">Integer与int的种种比较你知道多少？</a><span></span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">Java 为每个原始类型提供了包装类型：&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">- 原始类型: boolean，char，byte，short，int，long，float，double&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">- 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</span></p><pre><code class=\"lang-java\">class AutoUnboxingTest {\n\n    public static void main(String[] args) {\n        Integer a = new Integer(3);\n        Integer b = 3;                  // 将3自动装箱成Integer类型\n        int c = 3;\n        System.out.println(a == b);     // false 两个引用没有引用同一对象\n        System.out.println(a == c);     // true a自动拆箱成int类型再和c比较\n    }\n}<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：</span><br></p><pre><code class=\"lang-java\">public class Test03 {\n\n    public static void main(String[] args) {\n        Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;\n\n        System.out.println(f1 == f2);\n        System.out.println(f3 == f4);\n    }\n}<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。</span><br></p><pre><code class=\"lang-java\"> public static Integer valueOf(int i) {\n        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">IntegerCache是Integer的内部类，其代码如下所示：</span><br></p><pre><code class=\"lang-java\">/**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * sun.misc.VM class.\n     */\n\n    private static class IntegerCache {\n        static final int low = -128;\n        static final int high;\n        static final Integer cache[];\n\n        static {\n            // high value may be configured by property\n            int h = 127;\n            String integerCacheHighPropValue =\n                sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue != null) {\n                try {\n                    int i = parseInt(integerCacheHighPropValue);\n                    i = Math.max(i, 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high = h;\n\n            cache = new Integer[(high - low) + 1];\n            int j = low;\n            for(int k = 0; k &lt; cache.length; k++)\n                cache[k] = new Integer(j++);\n\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high &gt;= 127;\n        }\n\n        private IntegerCache() {}\n    }<br></code></pre><p><span style=\"font-size: 16px; color: rgb(227, 55, 55);\">简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">。</span></p><p>提醒：越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。</p><p><span style=\"font-size: 16px;\"><span style=\"font-size: 14px;\"><br></span></span></p><p><span style=\"font-size: 16px;\"><span style=\"font-size: 14px;\"><br></span></span></p><p><span style=\"font-size: 16px;\"><span style=\"font-size: 14px;\">补充一下：</span></span></p><pre><code class=\"lang-java\">/*&nbsp;\n&nbsp;*&nbsp;@author&nbsp;LiuYanzhao\n&nbsp;*\n&nbsp;*/\npublic&nbsp;class&nbsp;Test&nbsp;{\n\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;128;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i2&nbsp;=&nbsp;128;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i3&nbsp;=&nbsp;new&nbsp;Integer(128);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Integer会自动拆箱为int，所以为true\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i&nbsp;==&nbsp;i2);//true\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i&nbsp;==&nbsp;i3);//true\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//java在编译的时候,被翻译成-&gt;&nbsp;Integer&nbsp;i5&nbsp;=&nbsp;Integer.valueOf(127);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i5&nbsp;=&nbsp;127;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i6&nbsp;=&nbsp;127;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i5&nbsp;==&nbsp;i6);//true\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i7&nbsp;=&nbsp;128;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i8&nbsp;=&nbsp;128;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i7&nbsp;==&nbsp;i8);//false\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i9&nbsp;=&nbsp;new&nbsp;Integer(127);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i10&nbsp;=&nbsp;127;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i9&nbsp;==&nbsp;i10);&nbsp;//false\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i11&nbsp;=&nbsp;new&nbsp;Integer(128);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i12&nbsp;=&nbsp;new&nbsp;Integer(123);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i11&nbsp;==&nbsp;i12);&nbsp;&nbsp;//false\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n}<br></code></pre><p></p><p><code></code></p><p>① 无论如何，<span style=\"color: rgb(255, 0, 0);\"><strong>Integer与new Integer不会相等</strong></span>。不会经历拆箱过程，i3的引用指向堆，而i4指向专门存放他的内存（常量池），他们的内存地址不一样，所以为false</p><p>②&nbsp;<strong><span style=\"color: rgb(255, 0, 0);\">两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false</span></strong></p><p>java在编译Integer i2 = 128的时候,被翻译成-&gt; Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存</p><p>③&nbsp;<strong><span style=\"color: rgb(255, 0, 0);\">两</span><span style=\"color: rgb(255, 0, 0);\">个都是new出来的,都为false</span></strong></p><p>④&nbsp;<strong><span style=\"color: rgb(255, 0, 0);\">int和Integer(无论new否)比，都为true</span></strong>，因为会把Integer自动拆箱为int再去比</p><p><br></p><p style=\"text-align: justify;\"><b>8、&amp;和&amp;&amp;的区别？&nbsp;</b><br>答：&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(\"\")，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p><blockquote><p style=\"text-align: justify;\">补充：如果你熟悉JavaScript，那你可能更能感受到短路运算的强大，想成为JavaScript的高手就先从玩转短路运算开始吧。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>9、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。</b>&nbsp;<br>答：通常我们定义<span style=\"color: rgb(227, 55, 55);\">一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间</span>；而通过<span style=\"color: rgb(32, 147, 97);\">new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域</span>，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，<span style=\"color: rgb(200, 167, 50);\">方法区用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、\"hello\"和常量都是放在常量池中，常量池是方法区的一部分</span>，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。</p><pre><code class=\"lang-java\">String str = new String(\"hello\");<br></code></pre><p><span style=\"font-size: 16px; color: rgb(227, 55, 55);\"><b>上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而\"hello\"这个字面量是放在方法区的。</b></span><br></p><p><span style=\"font-size: 16px; color: rgb(227, 55, 55);\"><b><br></b></span></p><p style=\"text-align: justify;\"><b>10、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？&nbsp;</b><br>答：Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。</p><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>11、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？&nbsp;</b><br>答：<span style=\"color: rgb(227, 55, 55);\">在Java 5以前，switch(expr)中，expr只能是byte、short、char、int</span>。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，<span style=\"color: rgb(226, 139, 65);\">expr还可以是字符串（String）</span>，<span style=\"color: rgb(32, 147, 97);\">但是长整型（long）在目前所有的版本中都是不可以的</span>。</p><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>12、用最有效率的方法计算2乘以8？&nbsp;</b><br>答： 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。</p><blockquote><p><span style=\"font-size: 16px; color: rgb(227, 55, 55);\"><b><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">补充：</span><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于(num &lt;&lt; 5) - num，左移5位相当于乘以2的5次方再减去自身就相当于乘以31，现在的VM都能自动完成这个优化。</span><br></b></span></p></blockquote><pre><code class=\"lang-java\">public class PhoneNumber {\n    private int areaCode;\n    private String prefix;\n    private String lineNumber;\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + areaCode;\n        result = prime * result\n                + ((lineNumber == null) ? 0 : lineNumber.hashCode());\n        result = prime * result + ((prefix == null) ? 0 : prefix.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        PhoneNumber other = (PhoneNumber) obj;\n        if (areaCode != other.areaCode)\n            return false;\n        if (lineNumber == null) {\n            if (other.lineNumber != null)\n                return false;\n        } else if (!lineNumber.equals(other.lineNumber))\n            return false;\n        if (prefix == null) {\n            if (other.prefix != null)\n                return false;\n        } else if (!prefix.equals(other.prefix))\n            return false;\n        return true;\n    }\n\n}<br></code></pre><p><br></p><p style=\"text-align: justify;\"><b>13、数组有没有length()方法？String有没有length()方法？&nbsp;</b><br>答：数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>14、在Java中，如何跳出当前的多重嵌套循环？</b>&nbsp;<br>答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>15、构造器（constructor）是否可被重写（override）？&nbsp;</b><br>答：构造器不能被继承，因此不能被重写，但可以被重载。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>16、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？&nbsp;</b><br>答：不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：</p><p style=\"text-align: justify;\"><span style=\"color: rgb(227, 55, 55);\">(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(227, 55, 55);\">(2)如果两个对象的hashCode相同，它们并不一定相同。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(227, 55, 55);\">解释一下(2)的原因</span></p><p style=\"text-align: justify;\"><i style=\"color: rgb(227, 55, 55);\"><span style=\"font-size: 14px;\">1、因为object类的hashcode默认返回是int，值超过int的范围了就有可能2个hashcode返回相同的值了</span><br></i></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px; color: rgb(227, 55, 55);\"><i style=\"\">2、hashCode() 方法还可以被重写</i></span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(227, 55, 55);\"><span style=\"color: rgb(17, 17, 17); font-size: 14px;\"><i><br></i></span></span></p><p style=\"text-align: justify;\">当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</p><blockquote><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">补充：</span><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍，如果你还没看过，那就赶紧去</span><a href=\"http://z.cn/\" target=\"_blank\">亚马逊</a><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">买一本吧）中是这样介绍equals方法的：首先equals方法必须满足</span><span style=\"font-size: 14px; color: rgb(227, 55, 55);\">自反性</span><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">（x.equals(x)必须返回true）、</span><span style=\"font-size: 14px; color: rgb(227, 55, 55);\">对称性</span><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">（x.equals(y)返回true时，y.equals(x)也必须返回true）、</span><span style=\"font-size: 14px; color: rgb(227, 55, 55);\">传递性</span><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和</span><span style=\"font-size: 14px; color: rgb(227, 55, 55);\">一致性</span><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：</span></p><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">1. 使用==操作符检查\"参数是否为这个对象的引用\"；</span></p><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">2. 使用instanceof操作符检查\"参数是否为正确的类型\"；</span></p><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；</span></p><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；</span></p><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">5. 重写equals时总是要重写hashCode；</span></p><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。</span><br></p></blockquote><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\"><br></span></p><p><b><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">17、是否可以继承String类？</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></b></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：String 类是final类，不可以被继承。</span></p><blockquote><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\"><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">补充：</span><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。</span><br></span></p></blockquote><p><br></p><p><b><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></b></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。在C#中可以编写如下所示的代码，但是在Java中却做不到。</span></p><pre><code class=\"lang-c++\">using System;\n\nnamespace CS01 {\n\n    class Program {\n        public static void swap(ref int x, ref int y) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n\n        public static void Main (string[] args) {\n            int a = 5, b = 10;\n            swap (ref a, ref b);\n            // a = 10, b = 5;\n            Console.WriteLine (\"a = {0}, b = {1}\", a, b);\n        }\n    }\n}<br></code></pre><p><br></p><blockquote><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">说明：</span><span style=\"font-size: 14px; color: rgb(227, 55, 55);\">Java中没有传引用实在是非常的不方便</span><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。</span><br></p></blockquote><p><br></p><p style=\"text-align: justify;\"><b>19、String和StringBuilder、StringBuffer的区别？</b>&nbsp;<br>答：Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。</p><blockquote><p style=\"text-align: justify;\">面试题1&nbsp;- 什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？</p><p style=\"text-align: justify;\">面试题2&nbsp;- 请说出下面程序的输出。</p></blockquote><pre><code class=\"lang-java\">class StringEqualTest {\n\n    public static void main(String[] args) {\n        String s1 = \"Programming\";\n        String s2 = new String(\"Programming\");\n        String s3 = \"Program\";\n        String s4 = \"ming\";\n        String s5 = \"Program\" + \"ming\";\n        String s6 = s3 + s4;\n        System.out.println(s1 == s2);//false\n        System.out.println(s1 == s5);//true\n        System.out.println(s1 == s6);//false\n        System.out.println(s1 == s6.intern());//true\n        System.out.println(s2 == s2.intern());//false\n    }\n}<br></code></pre><blockquote><p style=\"text-align: justify;\"><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">补充：解答上面的面试题需要清楚两点：</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">1.</span><span style=\"font-size: 14px; color: rgb(227, 55, 55);\"> String对象的intern方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">2. </span><span style=\"font-size: 14px; color: rgb(227, 55, 55);\">字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象</span><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">，这一点可以用javap -c StringEqualTest.class命令获得class文件对应的JVM字节码指令就可以看出来。</span><br></p></blockquote><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"><br></span></p><p style=\"text-align: justify;\"><b>20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？&nbsp;</b><br>答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p style=\"text-align: justify;\">重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；</p><p style=\"text-align: justify;\">重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p><blockquote><p style=\"text-align: justify;\">面试题：华为的面试题中曾经问过这样一个问题 - \"为什么不能根据返回类型来区分重载\"，快说出你的答案吧！</p><p style=\"text-align: justify;\">答案：<a href=\"http://codergroup.cn/articles/10002\" target=\"_blank\">点此</a></p></blockquote><p style=\"text-align: justify;\">这里补充一下：</p><p style=\"text-align: justify;\"><b>重写：同名同参，两同两小一大（父子类继承关系）</b></p><p style=\"text-align: justify;\">1、两同：方法名相同，参数列表相同</p><p style=\"text-align: justify;\">2、两小：子类返回值类型(如 Dog) &lt;= 父类返回值类型(如 Animal)，子类方法声明抛出的异常(如 IOException ) &lt;= 父类方法声明抛出的异常(如 <span style=\"font-size: 16px;\">IOException 或&nbsp;</span>Exception )</p><p style=\"text-align: justify;\">3、一大：子类方法返回权限(如 public ) &gt; 父类方法访问权限(如 private,<span style=\"font-size: 16px;\">default,</span>protect)</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>重载：同名不同参，返回值无关</b></p><p style=\"text-align: justify;\">1、方法名必须相同，参数列表不同</p><p style=\"text-align: justify;\">2、可以有不同的返回类型</p><p style=\"text-align: justify;\">3、可以有不同的访问权限</p><p style=\"text-align: justify;\">4、可以抛不同的参数</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>21、描述一下JVM加载class文件的原理机制？</b>&nbsp;<br>答：JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。&nbsp;<br>由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。&nbsp;<br>类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p><blockquote><ul><li>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</li><li>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</li><li>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li></ul></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>22、char 型变量中能不能存贮一个中文汉字，为什么？&nbsp;</b><br>答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。</p><blockquote><p style=\"text-align: justify;\">补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>23、抽象类（abstract class）和接口（interface）有什么异同？&nbsp;</b><br>答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。</p><p style=\"text-align: justify;\">补充：这里给一个表格</p><table><colgroup><col width=\"33.29355608591885%\"><col width=\"33.29355608591885%\"><col width=\"33.53221957040573%\"></colgroup><thead><tr><th><strong>参数</strong></th><th><strong>抽象类</strong></th><th><strong>接口</strong></th></tr></thead><tbody><tr><td style=\"text-align: center;\">默认的方法实现</td><td style=\"text-align: center;\">它可以有默认的方法实现</td><td style=\"text-align: center;\">接口完全是抽象的。它根本不存在方法的实现</td></tr><tr><td style=\"text-align: center;\">实现</td><td style=\"text-align: center;\">子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td><td style=\"text-align: center;\">子类使用关键字<strong>implements</strong>来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td style=\"text-align: center;\">构造器</td><td style=\"text-align: center;\">抽象类可以有构造器</td><td style=\"text-align: center;\">接口不能有构造器</td></tr><tr><td style=\"text-align: center;\">与正常Java类的区别</td><td style=\"text-align: center;\">除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td><td style=\"text-align: center;\">接口是完全不同的类型</td></tr><tr><td style=\"text-align: center;\">访问修饰符</td><td style=\"text-align: center;\">抽象方法可以有<strong>public</strong>、<strong>protected</strong>和<strong>default</strong>这些修饰符</td><td style=\"text-align: center;\">接口方法默认修饰符是<strong>public</strong>。你不可以使用其它修饰符。</td></tr><tr><td style=\"text-align: center;\">main方法</td><td style=\"text-align: center;\">抽象方法可以有main方法并且我们可以运行它</td><td style=\"text-align: center;\">接口没有main方法，因此我们不能运行它。</td></tr><tr><td style=\"text-align: center;\">多继承</td><td style=\"text-align: center;\">抽象方法可以继承一个类和实现多个接口</td><td style=\"text-align: center;\">接口只可以继承一个或多个其它接口</td></tr><tr><td style=\"text-align: center;\">速度</td><td style=\"text-align: center;\">它比接口速度要快</td><td style=\"text-align: center;\">接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td></tr><tr><td style=\"text-align: center;\">添加新方法</td><td style=\"text-align: center;\">如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td><td style=\"text-align: center;\">如果你往接口中添加方法，那么你必须改变实现该接口的类。</td></tr></tbody></table><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>24、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</b>&nbsp;<br>答：Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。</p><pre><code class=\"lang-java\">    new Outer().new Inner();<br></code></pre><p style=\"text-align: justify;\"><br></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\"><b>25、Java 中会存在内存泄漏吗，请简单描述。</b></span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。</span></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>26、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？&nbsp;</b><br>答：都不能。<span style=\"color: rgb(227, 55, 55);\">抽象方法需要子类重写</span>，<span style=\"color: rgb(227, 55, 55);\">而静态的方法是无法被重写的</span>，因此二者是矛盾的。<span style=\"color: rgb(227, 55, 55);\">本地方法是由本地代码（如C代码）实现的方法</span>，而抽象方法是没有实现的，也是矛盾的。<span style=\"color: rgb(227, 55, 55);\">synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的</span>。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>27、阐述静态变量和实例变量的区别。&nbsp;</b><br>答：静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象<span style=\"color: rgb(227, 55, 55);\">，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝</span>；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p><blockquote><p style=\"text-align: justify;\">补充：在Java开发中，上下文类和工具类中通常会有大量的静态成员。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？&nbsp;</b><br>答：<span style=\"color: rgb(227, 55, 55);\">不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(227, 55, 55);\"><br></span></p><p style=\"text-align: justify;\"><b>29、如何实现对象克隆？&nbsp;</b><br>答：有两种方式：&nbsp;<br>  1). 实现Cloneable接口并重写Object类中的clone()方法；&nbsp;<br>  2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。</p><pre><code class=\"lang-java\">import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class MyUtil {\n\n    private MyUtil() {\n        throw new AssertionError();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T extends Serializable&gt; T clone(T obj) throws Exception {\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bout);\n        oos.writeObject(obj);\n\n        ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());\n        ObjectInputStream ois = new ObjectInputStream(bin);\n        return (T) ois.readObject();\n\n        // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义\n        // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放\n    }\n}<br></code></pre><p style=\"text-align: justify;\"><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">下面是测试代码：</span><br></p><pre><code class=\"lang-java\">import java.io.Serializable;\n\n/**\n * 人类\n * @author 骆昊\n *\n */\nclass Person implements Serializable {\n    private static final long serialVersionUID = -9102017020286042305L;\n\n    private String name;    // 姓名\n    private int age;        // 年龄\n    private Car car;        // 座驾\n\n    public Person(String name, int age, Car car) {\n        this.name = name;\n        this.age = age;\n        this.car = car;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public Car getCar() {\n        return car;\n    }\n\n    public void setCar(Car car) {\n        this.car = car;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person [name=\" + name + \", age=\" + age + \", car=\" + car + \"]\";\n    }\n\n}<br></code></pre><p><br></p><pre><code class=\"lang-java\">/**\n * 小汽车类\n * @author 骆昊\n *\n */\nclass Car implements Serializable {\n    private static final long serialVersionUID = -5713945027627603702L;\n\n    private String brand;       // 品牌\n    private int maxSpeed;       // 最高时速\n\n    public Car(String brand, int maxSpeed) {\n        this.brand = brand;\n        this.maxSpeed = maxSpeed;\n    }\n\n    public String getBrand() {\n        return brand;\n    }\n\n    public void setBrand(String brand) {\n        this.brand = brand;\n    }\n\n    public int getMaxSpeed() {\n        return maxSpeed;\n    }\n\n    public void setMaxSpeed(int maxSpeed) {\n        this.maxSpeed = maxSpeed;\n    }\n\n    @Override\n    public String toString() {\n        return \"Car [brand=\" + brand + \", maxSpeed=\" + maxSpeed + \"]\";\n    }\n\n}<br></code></pre><p><br></p><pre><code class=\"lang-java\">class CloneTest {\n\n    public static void main(String[] args) {\n        try {\n            Person p1 = new Person(\"Hao LUO\", 33, new Car(\"Benz\", 300));\n            Person p2 = MyUtil.clone(p1);   // 深度克隆\n            p2.getCar().setBrand(\"BYD\");\n            // 修改克隆的Person对象p2关联的汽车对象的品牌属性\n            // 原来的Person对象p1关联的汽车不会受到任何影响\n            // 因为在克隆Person对象时其关联的汽车对象也被克隆了\n            System.out.println(p1);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre><blockquote><p style=\"text-align: justify;\">注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。</p></blockquote><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>30、GC是什么？为什么要有GC？&nbsp;</b><br>答：<span style=\"color: rgb(227, 55, 55);\">GC是垃圾收集</span>的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。&nbsp;<br><span style=\"color: rgb(227, 55, 55);\">垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存</span>。<span style=\"color: rgb(32, 147, 97);\">垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。</span>在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。</p><blockquote><p style=\"text-align: justify;\">补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：&nbsp;<br>- 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。&nbsp;<br>- 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。&nbsp;<br>- 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。</p></blockquote><p style=\"text-align: justify;\">与垃圾回收相关的JVM参数：</p><blockquote><ul><li>-Xms / -Xmx — 堆的初始大小 / 堆的最大大小</li><li>-Xmn — 堆中年轻代的大小</li><li>-XX:-DisableExplicitGC — 让System.gc()不产生任何作用</li><li>-XX:+PrintGCDetails — 打印GC的细节</li><li>-XX:+PrintGCDateStamps — 打印GC操作的时间戳</li><li>-XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小</li><li>-XX:NewRatio — 可以设置老生代和新生代的比例</li><li>-XX:PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布</li><li>-XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值</li><li>-XX:TargetSurvivorRatio：设置幸存区的目标使用率</li></ul></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>31、String s = new String(\"xyz\");创建了几个字符串对象？&nbsp;</b><br>答：两个对象，一个是静态区的\"xyz\"，一个是用new创建在堆上的对象（s是存在栈上）。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？</b>&nbsp;<br>答：接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>33、一个\".java\"源文件中是否可以包含多个类（不是内部类）？有什么限制？</b>&nbsp;<br>答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？&nbsp;</b><br>答：可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？&nbsp;</b><br>答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>36、Java 中的final关键字有哪些用法？&nbsp;</b><br>答：</p><p style=\"text-align: justify;\">(1)修饰类：表示该类不能被继承；</p><p style=\"text-align: justify;\">(2)修饰方法：表示方法不能被重写；</p><p style=\"text-align: justify;\">(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span style=\"color: rgb(79, 79, 79); font-size: 16px;\"><b>37、指出下面程序的运行结果。</b></span><br></p><pre><code class=\"lang-java\">class A {\n\n    static {\n        System.out.print(\"1\");\n    }\n\n    public A() {\n        System.out.print(\"2\");\n    }\n}\n\nclass B extends A{\n\n    static {\n        System.out.print(\"a\");\n    }\n\n    public B() {\n        System.out.print(\"b\");\n    }\n}\n\npublic class Hello {\n\n    public static void main(String[] args) {\n        A ab = new B();\n        ab = new B();\n    }\n\n}<br></code></pre><p style=\"text-align: justify;\">答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：<span style=\"color: rgb(227, 55, 55);\">先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。</span></p><blockquote><p style=\"text-align: justify;\">提示：如果不能给出此题的正确答案，说明之前第21题Java类加载机制还没有完全理解，赶紧再看看吧。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>38、数据类型之间的转换：&nbsp;</b><br>- 如何将字符串转换为基本数据类型？&nbsp;<br>- 如何将基本数据类型转换为字符串？&nbsp;<br>答：&nbsp;<br>- 调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；&nbsp;<br>- 一种方法是将基本数据类型与空字符串（\"\"）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符串</p><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>39、如何实现字符串的反转及替换？&nbsp;</b><br>答：方法很多，可以自己写实现也可以使用String或StringBuffer/StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：</p><pre><code class=\"lang-java\">   public static String reverse(String originStr) {\n        if(originStr == null || originStr.length() &lt;= 1) \n            return originStr;\n        return reverse(originStr.substring(1)) + originStr.charAt(0);\n    }<br></code></pre><p><br></p><p><b><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">40、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></b></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：代码如下所示：</span></p><pre><code class=\"lang-java\">String s1 = \"你好\";\nString s2 = new String(s1.getBytes(\"GB2312\"), \"ISO-8859-1\");<br></code></pre><p><br></p><p><b><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">41、日期和时间：</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></b></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">- 如何取得年月日、小时分钟秒？</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">- 如何取得从1970年1月1日0时0分0秒到现在的毫秒数？</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">- 如何取得某月的最后一天？</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">- 如何格式化日期？</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">问题1：创建java.util.Calendar 实例，调用其get()方法传入不同的参数即可获得参数所对应的值。Java 8中可以使用java.time.LocalDateTimel来获取，代码如下所示。</span></p><pre><code class=\"lang-java\">public class DateTimeTest {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        System.out.println(cal.get(Calendar.YEAR));\n        System.out.println(cal.get(Calendar.MONTH));    // 0 - 11\n        System.out.println(cal.get(Calendar.DATE));\n        System.out.println(cal.get(Calendar.HOUR_OF_DAY));\n        System.out.println(cal.get(Calendar.MINUTE));\n        System.out.println(cal.get(Calendar.SECOND));\n\n        // Java 8\n        LocalDateTime dt = LocalDateTime.now();\n        System.out.println(dt.getYear());\n        System.out.println(dt.getMonthValue());     // 1 - 12\n        System.out.println(dt.getDayOfMonth());\n        System.out.println(dt.getHour());\n        System.out.println(dt.getMinute());\n        System.out.println(dt.getSecond());\n    }\n}<br></code></pre><p><br></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">问题2：以下方法均可获得该毫秒数。</span><br></p><pre><code class=\"lang-java\">Calendar.getInstance().getTimeInMillis();\nSystem.currentTimeMillis();\nClock.systemDefaultZone().millis(); // Java 8<br></code></pre><p><br></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">问题3：<span style=\"font-size: 16px; color: rgb(79, 79, 79);\">如何取得某月的最后一天？</span><span style=\"font-size: 16px; color: rgb(79, 79, 79);\">&nbsp;</span>代码如下所示。</span><br></p><pre><code class=\"lang-java\">Calendar time = Calendar.getInstance();\ntime.getActualMaximum(Calendar.DAY_OF_MONTH);<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\"><br></span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\"><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">问题4：利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。Java 8中可以用java.time.format.DateTimeFormatter来格式化时间日期，代码如下所示。</span><br></span></p><pre><code class=\"lang-java\">import java.text.SimpleDateFormat;\nimport java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Date;\n\nclass DateFormatTest {\n\n    public static void main(String[] args) {\n        SimpleDateFormat oldFormatter = new SimpleDateFormat(\"yyyy/MM/dd\");\n        Date date1 = new Date();\n        System.out.println(oldFormatter.format(date1));\n\n        // Java 8\n        DateTimeFormatter newFormatter = DateTimeFormatter.ofPattern(\"yyyy/MM/dd\");\n        LocalDate date2 = LocalDate.now();\n        System.out.println(date2.format(newFormatter));\n    }\n}<br></code></pre><p><br></p><blockquote><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">补充：Java的时间日期API一直以来都是被诟病的东西，为了解决这一问题，Java 8中引入了新的时间日期API，其中包括LocalDate、LocalTime、LocalDateTime、Clock、Instant等类，这些的类的设计都使用了不变模式，因此是线程安全的设计。如果不理解这些内容，可以参考我的另一篇文章</span><a href=\"http://blog.csdn.net/jackfrued/article/details/44499227\" target=\"_blank\">《关于Java并发编程的总结和思考》</a><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">。</span><br></p></blockquote><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\"><br></span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">42、打印昨天的当前时刻。</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：</span></p><pre><code class=\"lang-java\">import java.util.Calendar;\n\nclass YesterdayCurrent {\n    public static void main(String[] args){\n        Calendar cal = Calendar.getInstance();\n        cal.add(Calendar.DATE, -1);\n        System.out.println(cal.getTime());\n    }\n}<br></code></pre><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\"><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">在Java 8中，可以用下面的代码实现相同的功能。</span><br></span></p><pre><code class=\"lang-java\">import java.time.LocalDateTime;\n\nclass YesterdayCurrent {\n\n    public static void main(String[] args) {\n        LocalDateTime today = LocalDateTime.now();\n        LocalDateTime yesterday = today.minusDays(1);\n\n        System.out.println(yesterday);\n    }\n}<br></code></pre><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\"><span style=\"color: rgb(79, 79, 79); font-size: 16px;\"><br></span></span></p><p style=\"text-align: justify;\"><b>43、比较一下Java和JavaSciprt。</b>&nbsp;<br>答：JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。&nbsp;<br>下面对两种语言间的异同作如下比较：&nbsp;<br>-<span style=\"color: rgb(227, 55, 55);\"> 基于对象和面向对象</span>：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。&nbsp;<br>- <span style=\"color: rgb(227, 55, 55);\">解释和编译</span>：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）&nbsp;<br>-<span style=\"color: rgb(227, 55, 55);\"> 强类型变量和类型弱变量</span>：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。&nbsp;<br>- 代码格式不一样。</p><blockquote><p style=\"text-align: justify;\">补充：上面列出的四点是网上流传的所谓的标准答案。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民，因此JavaScript支持函数式编程，可以使用Lambda函数和闭包（closure），当然Java 8也开始支持函数式编程，提供了对Lambda表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>44、什么时候用断言（assert）？</b>&nbsp;<br>答：断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError。断言的使用如下面的代码所示：</p><pre><code class=\"lang-java\">assert(a &gt; 0); // throws an AssertionError if a &lt;= 0<br></code></pre><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\"><span style=\"color: rgb(79, 79, 79); font-size: 16px;\"><br></span></span></p><p style=\"text-align: justify;\">断言可以有两种形式：&nbsp;<br>assert Expression1;&nbsp;<br>assert Expression1 : Expression2 ;&nbsp;<br>Expression1 应该总是产生一个布尔值。&nbsp;<br>Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。</p><p style=\"text-align: justify;\">要在运行时启用断言，可以在启动JVM时使用-enableassertions或者-ea标记。要在运行时选择禁用断言，可以在启动JVM时使用-da或者-disableassertions标记。要在系统类中启用或禁用断言，可使用-esa或-dsa标记。还可以在包的基础上启用或者禁用断言。</p><blockquote><p style=\"text-align: justify;\">注意：断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>45、Error和Exception有什么区别？&nbsp;</b><br>答：Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。</p><blockquote><p style=\"text-align: justify;\">面试题：2005年摩托罗拉的面试中曾经问过这么一个问题“If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java程序在运行时也可能会遭遇StackOverflowError，这是一个无法恢复的错误，只能重新修改代码了，这个面试题的答案是c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示：</p></blockquote><pre><code class=\"lang-java\">class StackOverflowErrorTest {\n\n    public static void main(String[] args) {\n        main(null);\n    }\n}<br></code></pre><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\"><span style=\"color: rgb(79, 79, 79); font-size: 16px;\"><br></span></span></p><blockquote><p style=\"text-align: justify;\">提示：用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再继续递归）。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\">46、try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?&nbsp;<br></p><p style=\"text-align: justify;\"><span style=\"color: rgb(227, 55, 55);\">答：会执行，在方法返回调用者前执行</span>。</p><blockquote><p style=\"text-align: justify;\">注意：在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值。显然，在finally中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>47、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</b>&nbsp;<br>答：Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally为确保一段代码不管发生什么异常状况都要被执行；try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>48、运行时异常与受检异常有何异同？&nbsp;</b><br>答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则：&nbsp;<br>- 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）&nbsp;<br>- 对可以恢复的情况使用受检异常，对编程错误使用运行时异常&nbsp;<br>- 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）&nbsp;<br>- 优先使用标准的异常&nbsp;<br>- 每个方法抛出的异常都要有文档&nbsp;<br>- 保持异常的原子性&nbsp;<br>- 不要在catch中忽略掉捕获到的异常</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>49、列出一些你常见的运行时异常？&nbsp;</b><br>答：&nbsp;<br>- ArithmeticException（算术异常）&nbsp;<br>- ClassCastException （类转换异常）&nbsp;<br>- IllegalArgumentException （非法参数异常）&nbsp;<br>- IndexOutOfBoundsException （下标越界异常）&nbsp;<br>- NullPointerException （空指针异常）&nbsp;<br>- SecurityException （安全异常）</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>50、阐述final、finally、finalize的区别。&nbsp;</b><br>答：&nbsp;<br>- final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。&nbsp;<br>- finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。&nbsp;<br>- finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>51、类ExampleA继承Exception，类ExampleB继承ExampleA。&nbsp;</b><br>有如下代码片断：</p><pre><code class=\"lang-java\">try {\n    throw new ExampleB(\"b\")\n} catch（ExampleA e）{\n    System.out.println(\"ExampleA\");\n} catch（Exception e）{\n    System.out.println(\"Exception\");\n}<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">请问执行此段代码的输出是什么？</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常）</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\"><br></span></p><blockquote><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\"><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">面试题</span><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">&nbsp;- 说出下面代码的运行结果。（此题的出处是《Java编程思想》一书）</span><br></span></p></blockquote><pre><code class=\"lang-java\">class Annoyance extends Exception {}\nclass Sneeze extends Annoyance {}\n\nclass Human {\n\n    public static void main(String[] args) \n        throws Exception {\n        try {\n            try {\n                throw new Sneeze();\n            } \n            catch ( Annoyance a ) {\n                System.out.println(\"Caught Annoyance\");\n                throw a;\n            }\n        } \n        catch ( Sneeze s ) {\n            System.out.println(\"Caught Sneeze\");\n            return ;\n        }\n        finally {\n            System.out.println(\"Hello World!\");\n        }\n    }\n}<br></code></pre><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\"><span style=\"color: rgb(79, 79, 79); font-size: 16px;\"><br></span></span></p><p style=\"text-align: justify;\"><b>52、List、Set、Map是否继承自Collection接口？&nbsp;</b><br>答：List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>53、阐述ArrayList、Vector、LinkedList的存储性能和特性。</b>&nbsp;<br>答：ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</p><blockquote><p style=\"text-align: justify;\">补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是Has-A关系而不是Is-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是Has-A关系（关联）或Use-A关系（依赖）。同理，Stack类继承Vector也是不正确的。Sun公司的工程师们也会犯这种低级错误，让人唏嘘不已。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>54、Collection和Collections的区别？&nbsp;</b><br>答：Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>55、List、Map、Set三个接口存取元素时，各有什么特点？&nbsp;</b><br>答：List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>56、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？&nbsp;</b><br>答：TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。&nbsp;<br>例子1：<br></p><pre><code class=\"lang-java\">public class Student implements Comparable&lt;Student&gt; {\n    private String name;        // 姓名\n    private int age;            // 年龄\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student [name=\" + name + \", age=\" + age + \"]\";\n    }\n\n    @Override\n    public int compareTo(Student o) {\n        return this.age - o.age; // 比较年龄(年龄的升序)\n    }\n\n}<br></code></pre><pre><code class=\"lang-java\">import java.util.Set;\nimport java.util.TreeSet;\n\nclass Test01 {\n\n    public static void main(String[] args) {\n        Set&lt;Student&gt; set = new TreeSet&lt;&gt;();     // Java 7的钻石语法(构造器后面的尖括号中不需要写类型)\n        set.add(new Student(\"Hao LUO\", 33));\n        set.add(new Student(\"XJ WANG\", 32));\n        set.add(new Student(\"Bruce LEE\", 60));\n        set.add(new Student(\"Bob YANG\", 22));\n\n        for(Student stu : set) {\n            System.out.println(stu);\n        }\n//      输出结果: \n//      Student [name=Bob YANG, age=22]\n//      Student [name=XJ WANG, age=32]\n//      Student [name=Hao LUO, age=33]\n//      Student [name=Bruce LEE, age=60]\n    }\n}<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">例子2：</span><br></p><pre><code class=\"lang-java\">public class Student {\n    private String name;    // 姓名\n    private int age;        // 年龄\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    /**\n     * 获取学生姓名\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 获取学生年龄\n     */\n    public int getAge() {\n        return age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student [name=\" + name + \", age=\" + age + \"]\";\n    }\n\n}<br></code></pre><pre><code class=\"lang-java\">import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\nclass Test02 {\n\n    public static void main(String[] args) {\n        List&lt;Student&gt; list = new ArrayList&lt;&gt;();     // Java 7的钻石语法(构造器后面的尖括号中不需要写类型)\n        list.add(new Student(\"Hao LUO\", 33));\n        list.add(new Student(\"XJ WANG\", 32));\n        list.add(new Student(\"Bruce LEE\", 60));\n        list.add(new Student(\"Bob YANG\", 22));\n\n        // 通过sort方法的第二个参数传入一个Comparator接口对象\n        // 相当于是传入一个比较对象大小的算法到sort方法中\n        // 由于Java中没有函数指针、仿函数、委托这样的概念\n        // 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调\n        Collections.sort(list, new Comparator&lt;Student&gt; () {\n\n            @Override\n            public int compare(Student o1, Student o2) {\n                return o1.getName().compareTo(o2.getName());    // 比较学生姓名\n            }\n        });\n\n        for(Student stu : list) {\n            System.out.println(stu);\n        }\n//      输出结果: \n//      Student [name=Bob YANG, age=22]\n//      Student [name=Bruce LEE, age=60]\n//      Student [name=Hao LUO, age=33]\n//      Student [name=XJ WANG, age=32]\n    }\n}<br></code></pre><p><br></p><p style=\"text-align: justify;\"><b>57、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?&nbsp;</b><br>答：<span style=\"color: rgb(227, 55, 55);\">sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程</span>，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）<span style=\"color: rgb(32, 147, 97);\">。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool）</span>，如果线程重新获得对象的锁就可以进入就绪状态。</p><blockquote><p style=\"text-align: justify;\">补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。时下很时髦的<a href=\"https://nodejs.org/\" target=\"_blank\">Node.js</a>就采用了单线程异步I/O的工作模式。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>58、线程的sleep()方法和yield()方法有什么区别？&nbsp;</b><br>答：&nbsp;<br>① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；<span style=\"color: rgb(227, 55, 55);\">yield()方法只会给相同优先级或更高优先级的线程以运行的机会</span>；&nbsp;<br>② 线程执行sleep()方法后转入阻塞（blocked）状态，<span style=\"color: rgb(227, 55, 55);\">而执行yield()方法后转入就绪（ready）状态</span>；&nbsp;<br>③ <span style=\"color: rgb(227, 55, 55);\">sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；</span>&nbsp;<br>④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</p><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>59、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？&nbsp;</b><br>答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>60、请说出与线程同步以及线程调度相关的方法。&nbsp;</b><br>答：&nbsp;<br>- wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；&nbsp;<br>- sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；&nbsp;<br>- notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；&nbsp;<br>- notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p><blockquote><p style=\"text-align: justify;\">提示：关于Java多线程和并发编程的问题，建议大家看我的另一篇文章<a href=\"http://blog.csdn.net/jackfrued/article/details/44499227\" target=\"_blank\">《关于Java并发编程的总结和思考》</a>。</p><p style=\"text-align: justify;\">补充：Java 5通过Lock接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；此外，Java 5还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>61、编写多线程程序有几种实现方式？</b>&nbsp;<br>答：Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。</p><blockquote><p style=\"text-align: justify;\">补充：Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示：</p></blockquote><pre><code class=\"lang-java\">import java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\n\nclass MyTask implements Callable&lt;Integer&gt; {\n    private int upperBounds;\n\n    public MyTask(int upperBounds) {\n        this.upperBounds = upperBounds;\n    }\n\n    @Override\n    public Integer call() throws Exception {\n        int sum = 0; \n        for(int i = 1; i &lt;= upperBounds; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n\n}\n\nclass Test {\n\n    public static void main(String[] args) throws Exception {\n        List&lt;Future&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        for(int i = 0; i &lt; 10; i++) {\n            list.add(service.submit(new MyTask((int) (Math.random() * 100))));\n        }\n\n        int sum = 0;\n        for(Future&lt;Integer&gt; future : list) {\n            // while(!future.isDone()) ;\n            sum += future.get();\n        }\n\n        System.out.println(sum);\n    }\n}<br></code></pre><p><br></p><p style=\"text-align: justify;\"><b>62、synchronized关键字的用法？&nbsp;</b><br>答：synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。在第60题的例子中已经展示了synchronized关键字的用法。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>63、举例说明同步和异步。&nbsp;</b><br>答：如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。<span style=\"color: rgb(227, 55, 55);\">当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率</span>。事实上，<span style=\"color: rgb(32, 147, 97);\">所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作</span>。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>64、启动一个线程是调用run()还是start()方法？</b>&nbsp;<br>答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>65、什么是线程池（thread pool）？&nbsp;</b><br>答：在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。&nbsp;<br>Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：&nbsp;<br>- newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。&nbsp;<br>- newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。&nbsp;<br>- newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。&nbsp;<br>- newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。&nbsp;<br>- newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</p><p style=\"text-align: justify;\">第60题的例子中演示了通过Executors工具类创建线程池并使用线程池执行线程的代码。如果希望在服务器上使用线程池，强烈建议使用newFixedThreadPool方法来创建线程池，这样能获得更好的性能。</p><p><br></p><p style=\"text-align: justify;\"><b>66、线程的基本状态以及状态之间的关系？&nbsp;</b><br>答：&nbsp;<br><img src=\"https://img-blog.csdn.net/20150408002007838\" alt=\"这里写图片描述\"></p><blockquote><p style=\"text-align: justify;\">说明：其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>67、简述synchronized 和java.util.concurrent.locks.Lock的异同？&nbsp;</b><br>答：Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：Lock 能完成synchronized所实现的所有功能；主要不同点：<span style=\"color: rgb(227, 55, 55);\">Lock有比synchronized更精确的线程语义和更好的性能</span>，<span style=\"color: rgb(32, 147, 97);\">而且不强制性的要求一定要获得锁。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放</span>（这是释放外部资源的最好的地方）。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>68、Java中如何实现序列化，有什么意义？&nbsp;</b><br>答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。<span style=\"color: rgb(227, 55, 55);\">序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。&nbsp;</span><br>要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。<span style=\"color: rgb(227, 55, 55);\">序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆</span>（可以参考第29题）。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>69、Java中有几种类型的流？&nbsp;</b><br>答：<span style=\"color: rgb(227, 55, 55);\">字节流和字符流</span>。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于Java的I/O需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。</p><blockquote><p style=\"text-align: justify;\">面试题&nbsp;- 编程实现文件拷贝。（这个题目在笔试的时候经常出现，下面的代码给出了两种实现方案）</p></blockquote><pre><code class=\"lang-java\">import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic final class MyUtil {\n\n    private MyUtil() {\n        throw new AssertionError();\n    }\n\n    public static void fileCopy(String source, String target) throws IOException {\n        try (InputStream in = new FileInputStream(source)) {\n            try (OutputStream out = new FileOutputStream(target)) {\n                byte[] buffer = new byte[4096];\n                int bytesToRead;\n                while((bytesToRead = in.read(buffer)) != -1) {\n                    out.write(buffer, 0, bytesToRead);\n                }\n            }\n        }\n    }\n\n    public static void fileCopyNIO(String source, String target) throws IOException {\n        try (FileInputStream in = new FileInputStream(source)) {\n            try (FileOutputStream out = new FileOutputStream(target)) {\n                FileChannel inChannel = in.getChannel();\n                FileChannel outChannel = out.getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(4096);\n                while(inChannel.read(buffer) != -1) {\n                    buffer.flip();\n                    outChannel.write(buffer);\n                    buffer.clear();\n                }\n            }\n        }\n    }\n}<br></code></pre><p><br></p><p><b><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></b></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：代码如下：</span></p><pre><code class=\"lang-java\">import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic final class MyUtil {\n\n    // 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象(绝对好习惯)\n    private MyUtil() {\n        throw new AssertionError();\n    }\n\n    /**\n     * 统计给定文件中给定字符串的出现次数\n     * \n     * @param filename  文件名\n     * @param word 字符串\n     * @return 字符串在文件中出现的次数\n     */\n    public static int countWordInFile(String filename, String word) {\n        int counter = 0;\n        try (FileReader fr = new FileReader(filename)) {\n            try (BufferedReader br = new BufferedReader(fr)) {\n                String line = null;\n                while ((line = br.readLine()) != null) {\n                    int index = -1;\n                    while (line.length() &gt;= word.length() &amp;&amp; (index = line.indexOf(word)) &gt;= 0) {\n                        counter++;\n                        line = line.substring(index + word.length());\n                    }\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return counter;\n    }\n\n}<br></code></pre><p><br></p><p><b><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">71、如何用Java代码列出一个目录下所有的文件？</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></b></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">如果只要求列出当前文件夹下的文件，代码如下所示：</span></p><pre><code class=\"lang-java\">import java.io.File;\n\nclass Test12 {\n\n    public static void main(String[] args) {\n        File f = new File(\"/Users/Hao/Downloads\");\n        for(File temp : f.listFiles()) {\n            if(temp.isFile()) {\n                System.out.println(temp.getName());\n            }\n        }\n    }\n}<br></code></pre><p><br></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">如果需要对文件夹继续展开，代码如下所示：</span><br></p><pre><code class=\"lang-java\">import java.io.File;\n\nclass Test12 {\n\n    public static void main(String[] args) {\n        showDirectory(new File(\"/Users/Hao/Downloads\"));\n    }\n\n    public static void showDirectory(File f) {\n        _walkDirectory(f, 0);\n    }\n\n    private static void _walkDirectory(File f, int level) {\n        if(f.isDirectory()) {\n            for(File temp : f.listFiles()) {\n                _walkDirectory(temp, level + 1);\n            }\n        }\n        else {\n            for(int i = 0; i &lt; level - 1; i++) {\n                System.out.print(\"\\t\");\n            }\n            System.out.println(f.getName());\n        }\n    }\n}<br></code></pre><p><br></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">在Java 7中可以使用NIO.2的API来做同样的事情，代码如下所示：</span><br></p><pre><code class=\"lang-java\">class ShowFileTest {\n\n    public static void main(String[] args) throws IOException {\n        Path initPath = Paths.get(\"/Users/Hao/Downloads\");\n        Files.walkFileTree(initPath, new SimpleFileVisitor&lt;Path&gt;() {\n\n            @Override\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n                    throws IOException {\n                System.out.println(file.getFileName().toString());\n                return FileVisitResult.CONTINUE;\n            }\n\n        });\n    }\n}<br></code></pre><p><br></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\"><b>72、用Java的套接字编程实现一个多线程的回显（echo）服务器。</b></span><br></p><pre><code class=\"lang-java\">import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EchoServer {\n\n    private static final int ECHO_SERVER_PORT = 6789;\n\n    public static void main(String[] args) {        \n        try(ServerSocket server = new ServerSocket(ECHO_SERVER_PORT)) {\n            System.out.println(\"服务器已经启动...\");\n            while(true) {\n                Socket client = server.accept();\n                new Thread(new ClientHandler(client)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class ClientHandler implements Runnable {\n        private Socket client;\n\n        public ClientHandler(Socket client) {\n            this.client = client;\n        }\n\n        @Override\n        public void run() {\n            try(BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));\n                    PrintWriter pw = new PrintWriter(client.getOutputStream())) {\n                String msg = br.readLine();\n                System.out.println(\"收到\" + client.getInetAddress() + \"发送的: \" + msg);\n                pw.println(msg);\n                pw.flush();\n            } catch(Exception ex) {\n                ex.printStackTrace();\n            } finally {\n                try {\n                    client.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n}<br></code></pre><blockquote><p style=\"text-align: justify;\">注意：上面的代码使用了Java 7的TWR语法，由于很多外部资源类都间接的实现了AutoCloseable接口（单方法回调接口），因此可以利用TWR语法在try结束的时候通过回调的方式自动调用外部资源类的close()方法，避免书写冗长的finally代码块。此外，上面的代码用一个静态内部类实现线程的功能，使用多线程可以避免一个用户I/O操作所产生的中断影响其他用户对服务器的访问，简单的说就是一个用户的输入操作不会造成其他用户的阻塞。当然，上面的代码使用线程池可以获得更好的性能，因为频繁的创建和销毁线程所造成的开销也是不可忽视的。</p></blockquote><p style=\"text-align: justify;\">下面是一段回显客户端测试代码：</p><pre><code class=\"lang-java\">import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class EchoClient {\n\n    public static void main(String[] args) throws Exception {\n        Socket client = new Socket(\"localhost\", 6789);\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"请输入内容: \");\n        String msg = sc.nextLine();\n        sc.close();\n        PrintWriter pw = new PrintWriter(client.getOutputStream());\n        pw.println(msg);\n        pw.flush();\n        BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));\n        System.out.println(br.readLine());\n        client.close();\n    }\n}<br></code></pre><p>如果希望用NIO的多路复用套接字实现服务器，代码如下所示。NIO的操作虽然带来了更好的性能，但是有些操作是比较底层的，对于初学者来说还是有些难于理解。<br></p><pre><code class=\"lang-java\">import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\n\npublic class EchoServerNIO {\n\n    private static final int ECHO_SERVER_PORT = 6789;\n    private static final int ECHO_SERVER_TIMEOUT = 5000;\n    private static final int BUFFER_SIZE = 1024;\n\n    private static ServerSocketChannel serverChannel = null;\n    private static Selector selector = null;    // 多路复用选择器\n    private static ByteBuffer buffer = null;    // 缓冲区\n\n    public static void main(String[] args) {\n        init();\n        listen();\n    }\n\n    private static void init() {\n        try {\n            serverChannel = ServerSocketChannel.open();\n            buffer = ByteBuffer.allocate(BUFFER_SIZE);\n            serverChannel.socket().bind(new InetSocketAddress(ECHO_SERVER_PORT));\n            serverChannel.configureBlocking(false);\n            selector = Selector.open();\n            serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static void listen() {\n        while (true) {\n            try {\n                if (selector.select(ECHO_SERVER_TIMEOUT) != 0) {\n                    Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();\n                    while (it.hasNext()) {\n                        SelectionKey key = it.next();\n                        it.remove();\n                        handleKey(key);\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static void handleKey(SelectionKey key) throws IOException {\n        SocketChannel channel = null;\n\n        try {\n            if (key.isAcceptable()) {\n                ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n                channel = serverChannel.accept();\n                channel.configureBlocking(false);\n                channel.register(selector, SelectionKey.OP_READ);\n            } else if (key.isReadable()) {\n                channel = (SocketChannel) key.channel();\n                buffer.clear();\n                if (channel.read(buffer) &gt; 0) {\n                    buffer.flip();\n                    CharBuffer charBuffer = CharsetHelper.decode(buffer);\n                    String msg = charBuffer.toString();\n                    System.out.println(\"收到\" + channel.getRemoteAddress() + \"的消息：\" + msg);\n                    channel.write(CharsetHelper.encode(CharBuffer.wrap(msg)));\n                } else {\n                    channel.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            if (channel != null) {\n                channel.close();\n            }\n        }\n    }\n\n}<br></code></pre><pre><code class=\"lang-java\">import java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\n\npublic final class CharsetHelper {\n    private static final String UTF_8 = \"UTF-8\";\n    private static CharsetEncoder encoder = Charset.forName(UTF_8).newEncoder();\n    private static CharsetDecoder decoder = Charset.forName(UTF_8).newDecoder();\n\n    private CharsetHelper() {\n    }\n\n    public static ByteBuffer encode(CharBuffer in) throws CharacterCodingException{\n        return encoder.encode(in);\n    }\n\n    public static CharBuffer decode(ByteBuffer in) throws CharacterCodingException{\n        return decoder.decode(in);\n    }\n}<br></code></pre><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>73、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？&nbsp;</b><br>答：XML文档定义分为DTD和Schema两种形式，二者都是对XML语法的约束，其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析，而且可以为XML承载的数据定义类型，约束能力较之DTD更强大。对XML的解析主要有DOM（文档对象模型，<u>D</u>ocument&nbsp;<u>O</u>bject&nbsp;<u>M</u>odel）、SAX（<u>S</u>imple&nbsp;<u>A</u>PI for&nbsp;<u>X</u>ML）和StAX（Java 6中引入的新的解析XML的方式，<u>St</u>reaming&nbsp;<u>A</u>PI for&nbsp;<u>X</u>ML），其中DOM处理大型文件时其性能下降的非常厉害，这个问题是由DOM树结构占用的内存较多造成的，而且DOM解析方式必须在解析文件之前把整个文档装入内存，适合对XML的随机访问（典型的用空间换取时间的策略）；SAX是事件驱动型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理XML文件，适合对XML的顺序访问；顾名思义，StAX把重点放在流上，实际上StAX与其他解析方式的本质区别就在于应用程序能够把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖（SAX就是这样做的），但不同之处在于StAX允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>74、你在项目中哪些地方用到了XML？&nbsp;</b><br>答：XML的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从XML文件中还原相关信息进行处理，XML曾经是异构系统间交换数据的事实标准，但此项功能几乎已经被JSON（<u>J</u>ava<u>S</u>cript&nbsp;<u>O</u>bject&nbsp;<u>N</u>otation）取而代之。当然，目前很多软件仍然使用XML来存储配置信息，我们在很多项目中通常也会将作为配置信息的硬代码写在XML文件中，Java的很多框架也是这么做的，而且这些框架都选择了<a href=\"http://www.dom4j.org/\" target=\"_blank\">dom4j</a>作为处理XML的工具，因为Sun公司的官方API实在不怎么好用。</p><blockquote><p style=\"text-align: justify;\">补充：现在有很多时髦的软件（如Sublime）已经开始将配置文件书写成JSON格式，我们已经强烈的感受到XML的另一项功能也将逐渐被业界抛弃。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>75、阐述JDBC操作数据库的步骤。&nbsp;</b><br>答：下面的代码以连接本机的Oracle数据库为例，演示JDBC操作数据库的步骤。</p><ul><li>加载驱动。</li></ul><pre><code class=\"lang-java\">Class.forName(\"com.mysql.jdbc.Driver\");<br></code></pre><ul><li>创建连接。</li></ul><pre><code class=\"lang-java\">Connection con = DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/spring?useUnicode=true&amp;characterEncoding=utf8\", \"root\", \"123456\");<br></code></pre><ul><li>创建语句。</li></ul><pre><code class=\"lang-java\">PreparedStatement ps = con.prepareStatement(\"select * from emp where sal between ? and ?\");\nps.setInt(1, 1000);\nps.setInt(2, 3000);<br></code></pre><ul><li>执行语句。</li></ul><pre><code class=\"lang-java\">ResultSet rs = ps.executeQuery();<br></code></pre><ul><li>处理结果。</li></ul><pre><code>while(rs.next()) {\n    System.out.println(rs.getInt(\"empno\") + \" - \" + rs.getString(\"ename\"));\n}<br></code></pre><ul><li>关闭资源。</li></ul><pre><code class=\"lang-java\">  finally {\n        if(con != null) {\n            try {\n                con.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }<br></code></pre><blockquote><p style=\"text-align: justify;\">提示：关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭ResultSet、再关闭Statement、在关闭Connection。上面的代码只关闭了Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在JDBC 4.0中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>76、Statement和PreparedStatement有什么区别？哪个性能更好？&nbsp;</b><br>答：与Statement相比，①PreparedStatement接口代表预编译的语句，它主要的优势在于可以<span style=\"color: rgb(227, 55, 55);\">减少SQL的编译错误并增加SQL的安全性</span>（减少SQL注射攻击的可能性）；②PreparedStatement中的SQL语句是可以带参数的，<span style=\"color: rgb(227, 55, 55);\">避免了用字符串连接拼接SQL语句</span>的麻烦和不安全；③<span style=\"color: rgb(227, 55, 55);\">当批量处理SQL或频繁执行相同的查询</span>时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。</p><blockquote><p style=\"text-align: justify;\">补充：为了提供对存储过程的调用，JDBC API中还提供了CallableStatement接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的SQL语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>77、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？</b>&nbsp;<br>答：要提升读取数据的性能，可以指定<span style=\"color: rgb(227, 55, 55);\">通过结果集（ResultSet）对象的setFetchSize()方法指定每次抓取的记录数</span>（典型的空间换时间策略）；<span style=\"color: rgb(227, 55, 55);\">要提升更新数据的性能可以使用PreparedStatement语句构建批处理</span>，将若干SQL语句置于一个批处理中执行。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>78、在进行数据库编程时，连接池有什么作用？&nbsp;</b><br>答：由于<span style=\"color: rgb(32, 147, 97);\">创建连接和释放连接都有很大的开销</span>（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），<span style=\"color: rgb(227, 55, 55);\">为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销</span>，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有：<a href=\"http://sourceforge.net/projects/c3p0/\" target=\"_blank\">C3P0</a>、<a href=\"http://proxool.sourceforge.net/\" target=\"_blank\">Proxool</a>、<a href=\"http://commons.apache.org/proper/commons-dbcp/\" target=\"_blank\">DBCP</a>、<a href=\"https://github.com/wwadge/bonecp\" target=\"_blank\">BoneCP</a>、<a href=\"https://github.com/alibaba/druid\" target=\"_blank\">Druid</a>等。</p><blockquote><p style=\"text-align: justify;\">补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>79、什么是DAO模式？</b>&nbsp;<br>答：DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>80、事务的ACID是指什么？</b>&nbsp;<br>答：&nbsp;<br>- 原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败；&nbsp;<br>- 一致性(Consistent)：事务结束后系统状态是一致的；&nbsp;<br>- 隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态；&nbsp;<br>- 持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。</p><blockquote><p style=\"text-align: justify;\">补充：关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，<span style=\"color: rgb(227, 55, 55);\">只有存在并发数据访问时才需要事务</span>。当多个事务访问同一数据时，可能会存在5类问题，包括3类数据读取问题（<span style=\"color: rgb(226, 139, 65);\">脏读、不可重复读和幻读</span>）和2类数据更新问题（<span style=\"color: rgb(226, 139, 65);\">第1类丢失更新和第2类丢失更新</span>）。</p></blockquote><p style=\"text-align: justify;\">脏读（Dirty Read）：A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，<span style=\"color: rgb(227, 55, 55);\">那么A读取到的数据就是脏数据</span>。</p><table><colgroup><col width=\"33.29355608591885%\"><col width=\"33.29355608591885%\"><col width=\"33.53221957040573%\"></colgroup><thead><tr><th>时间</th><th>转账事务A</th><th>取款事务B</th></tr></thead><tbody><tr><td style=\"text-align: left;\">T1</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">开始事务</td></tr><tr><td style=\"text-align: left;\">T2</td><td style=\"text-align: left;\">开始事务</td><td style=\"text-align: left;\">&nbsp;</td></tr><tr><td style=\"text-align: left;\">T3</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">查询账户余额为1000元</td></tr><tr><td style=\"text-align: left;\">T4</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">取出500元余额修改为500元</td></tr><tr><td style=\"text-align: left;\">T5</td><td style=\"text-align: left;\">查询账户余额为500元（脏读）</td><td style=\"text-align: left;\">&nbsp;</td></tr><tr><td style=\"text-align: left;\">T6</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">撤销事务余额恢复为1000元</td></tr><tr><td style=\"text-align: left;\">T7</td><td style=\"text-align: left;\">汇入100元把余额修改为600元</td><td style=\"text-align: left;\">&nbsp;</td></tr><tr><td style=\"text-align: left;\">T8</td><td style=\"text-align: left;\">提交事务</td><td style=\"text-align: left;\">&nbsp;</td></tr></tbody></table><hr><p style=\"text-align: justify;\">不可重复读（Unrepeatable Read）：事务A重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务B修改过了。</p><table><colgroup><col width=\"33.29355608591885%\"><col width=\"33.29355608591885%\"><col width=\"33.53221957040573%\"></colgroup><thead><tr><th>时间</th><th>转账事务A</th><th>取款事务B</th></tr></thead><tbody><tr><td style=\"text-align: left;\">T1</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">开始事务</td></tr><tr><td style=\"text-align: left;\">T2</td><td style=\"text-align: left;\">开始事务</td><td style=\"text-align: left;\">&nbsp;</td></tr><tr><td style=\"text-align: left;\">T3</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">查询账户余额为1000元</td></tr><tr><td style=\"text-align: left;\">T4</td><td style=\"text-align: left;\">查询账户余额为1000元</td><td style=\"text-align: left;\">&nbsp;</td></tr><tr><td style=\"text-align: left;\">T5</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">取出100元修改余额为900元</td></tr><tr><td style=\"text-align: left;\">T6</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">提交事务</td></tr><tr><td style=\"text-align: left;\">T7</td><td style=\"text-align: left;\">查询账户余额为900元（不可重复读）</td><td style=\"text-align: left;\">&nbsp;</td></tr></tbody></table><hr><p style=\"text-align: justify;\">幻读（Phantom Read）：事务A重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务B提交的行。</p><table><colgroup><col width=\"33.29355608591885%\"><col width=\"33.29355608591885%\"><col width=\"33.53221957040573%\"></colgroup><thead><tr><th>时间</th><th>统计金额事务A</th><th>转账事务B</th></tr></thead><tbody><tr><td style=\"text-align: left;\">T1</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">开始事务</td></tr><tr><td style=\"text-align: left;\">T2</td><td style=\"text-align: left;\">开始事务</td><td style=\"text-align: left;\">&nbsp;</td></tr><tr><td style=\"text-align: left;\">T3</td><td style=\"text-align: left;\">统计总存款为10000元</td><td style=\"text-align: left;\">&nbsp;</td></tr><tr><td style=\"text-align: left;\">T4</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">新增一个存款账户存入100元</td></tr><tr><td style=\"text-align: left;\">T5</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">提交事务</td></tr><tr><td style=\"text-align: left;\">T6</td><td style=\"text-align: left;\">再次统计总存款为10100元（幻读）</td><td style=\"text-align: left;\">&nbsp;</td></tr></tbody></table><hr><p style=\"text-align: justify;\">第1类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。</p><table><colgroup><col width=\"33.29355608591885%\"><col width=\"33.29355608591885%\"><col width=\"33.53221957040573%\"></colgroup><thead><tr><th>时间</th><th>取款事务A</th><th>转账事务B</th></tr></thead><tbody><tr><td style=\"text-align: left;\">T1</td><td style=\"text-align: left;\">开始事务</td><td style=\"text-align: left;\">&nbsp;</td></tr><tr><td style=\"text-align: left;\">T2</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">开始事务</td></tr><tr><td style=\"text-align: left;\">T3</td><td style=\"text-align: left;\">查询账户余额为1000元</td><td style=\"text-align: left;\">&nbsp;</td></tr><tr><td style=\"text-align: left;\">T4</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">查询账户余额为1000元</td></tr><tr><td style=\"text-align: left;\">T5</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">汇入100元修改余额为1100元</td></tr><tr><td style=\"text-align: left;\">T6</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">提交事务</td></tr><tr><td style=\"text-align: left;\">T7</td><td style=\"text-align: left;\">取出100元将余额修改为900元</td><td style=\"text-align: left;\">&nbsp;</td></tr><tr><td style=\"text-align: left;\">T8</td><td style=\"text-align: left;\">撤销事务</td><td style=\"text-align: left;\">&nbsp;</td></tr><tr><td style=\"text-align: left;\">T9</td><td style=\"text-align: left;\">余额恢复为1000元（丢失更新）</td><td style=\"text-align: left;\">&nbsp;</td></tr></tbody></table><hr><p style=\"text-align: justify;\">第2类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。</p><table><colgroup><col width=\"33.29355608591885%\"><col width=\"33.29355608591885%\"><col width=\"33.53221957040573%\"></colgroup><thead><tr><th>时间</th><th>转账事务A</th><th>取款事务B</th></tr></thead><tbody><tr><td style=\"text-align: left;\">T1</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">开始事务</td></tr><tr><td style=\"text-align: left;\">T2</td><td style=\"text-align: left;\">开始事务</td><td style=\"text-align: left;\">&nbsp;</td></tr><tr><td style=\"text-align: left;\">T3</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">查询账户余额为1000元</td></tr><tr><td style=\"text-align: left;\">T4</td><td style=\"text-align: left;\">查询账户余额为1000元</td><td style=\"text-align: left;\">&nbsp;</td></tr><tr><td style=\"text-align: left;\">T5</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">取出100元将余额修改为900元</td></tr><tr><td style=\"text-align: left;\">T6</td><td style=\"text-align: left;\">&nbsp;</td><td style=\"text-align: left;\">提交事务</td></tr><tr><td style=\"text-align: left;\">T7</td><td style=\"text-align: left;\">汇入100元将余额修改为1100元</td><td style=\"text-align: left;\">&nbsp;</td></tr><tr><td style=\"text-align: left;\">T8</td><td style=\"text-align: left;\">提交事务</td><td style=\"text-align: left;\">&nbsp;</td></tr><tr><td style=\"text-align: left;\">T9</td><td style=\"text-align: left;\">查询账户余额为1100元（丢失更新）</td><td style=\"text-align: left;\">&nbsp;</td></tr></tbody></table><hr><p style=\"text-align: justify;\">数据并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能就是致命的，数据库通常会通过锁机制来解决数据并发访问问题，<span style=\"color: rgb(227, 55, 55);\">按锁定对象不同可以分为表级锁和行级锁</span>；按<span style=\"color: rgb(227, 55, 55);\">并发事务锁定关系可以分为共享锁和独占锁</span>，具体的内容大家可以自行查阅资料进行了解。&nbsp;<br>直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定会话的事务隔离级别，数据库就会通过分析SQL语句然后为事务访问的资源加上合适的锁，此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对用户来说都是透明的（就是说你不用理解，事实上我确实也不知道）。ANSI/ISO SQL 92标准定义了4个等级的事务隔离级别，如下表所示：</p><table><colgroup><col width=\"16.58711217183771%\"><col width=\"16.58711217183771%\"><col width=\"16.706443914081145%\"><col width=\"16.706443914081145%\"><col width=\"16.82577565632458%\"><col width=\"17.064439140811455%\"></colgroup><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>第一类丢失更新</th><th>第二类丢失更新</th></tr></thead><tbody><tr><td style=\"text-align: left;\">READ UNCOMMITED</td><td style=\"text-align: left;\">允许</td><td style=\"text-align: left;\">允许</td><td style=\"text-align: left;\">允许</td><td style=\"text-align: left;\">不允许</td><td style=\"text-align: left;\">允许</td></tr><tr><td style=\"text-align: left;\">READ COMMITTED</td><td style=\"text-align: left;\">不允许</td><td style=\"text-align: left;\">允许</td><td style=\"text-align: left;\">允许</td><td style=\"text-align: left;\">不允许</td><td style=\"text-align: left;\">允许</td></tr><tr><td style=\"text-align: left;\">REPEATABLE READ</td><td style=\"text-align: left;\">不允许</td><td style=\"text-align: left;\">不允许</td><td style=\"text-align: left;\">允许</td><td style=\"text-align: left;\">不允许</td><td style=\"text-align: left;\">不允许</td></tr><tr><td style=\"text-align: left;\">SERIALIZABLE</td><td style=\"text-align: left;\">不允许</td><td style=\"text-align: left;\">不允许</td><td style=\"text-align: left;\">不允许</td><td style=\"text-align: left;\">不允许</td><td style=\"text-align: left;\">不允许</td></tr></tbody></table><p style=\"text-align: justify;\">需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>81、JDBC中如何进行事务处理？</b>&nbsp;<br>答：Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC 3.0中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。&nbsp;<br><img src=\"https://img-blog.csdn.net/20150408174308284\" alt=\"这里写图片描述\"></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>82、JDBC能否处理Blob和Clob？&nbsp;</b><br>答： Blob是指二进制大对象（Binary Large Object），而Clob是指大字符对象（Character Large Objec），因此其中Blob是为存储大的二进制数据而设计的，而Clob是为存储大的文本数据而设计的。JDBC的PreparedStatement和ResultSet都提供了相应的方法来支持Blob和Clob操作。下面的代码展示了如何使用JDBC操作LOB：&nbsp;<br>下面以MySQL数据库为例，创建一个张有三个字段的用户表，包括编号（id）、姓名（name）和照片（photo），建表语句如下：</p><pre><code class=\"lang-sql\">create table tb_user\n(\nid int primary key auto_increment,\nname varchar(20) unique not null,\nphoto longblob\n);<br></code></pre><p style=\"text-align: justify;\"><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">下面的Java代码向数据库中插入一条记录：</span><br></p><pre><code class=\"lang-java\">import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\nclass JdbcLobTest {\n\n    public static void main(String[] args) {\n        Connection con = null;\n        try {\n            // 1. 加载驱动（Java6以上版本可以省略）\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            // 2. 建立连接\n            con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\", \"root\", \"123456\");\n            // 3. 创建语句对象\n            PreparedStatement ps = con.prepareStatement(\"insert into tb_user values (default, ?, ?)\");\n            ps.setString(1, \"骆昊\");              // 将SQL语句中第一个占位符换成字符串\n            try (InputStream in = new FileInputStream(\"test.jpg\")) {    // Java 7的TWR\n                ps.setBinaryStream(2, in);      // 将SQL语句中第二个占位符换成二进制流\n                // 4. 发出SQL语句获得受影响行数\n                System.out.println(ps.executeUpdate() == 1 ? \"插入成功\" : \"插入失败\");\n            } catch(IOException e) {\n                System.out.println(\"读取照片失败!\");\n            }\n        } catch (ClassNotFoundException | SQLException e) {     // Java 7的多异常捕获\n            e.printStackTrace();\n        } finally { // 释放外部资源的代码都应当放在finally中保证其能够得到执行\n            try {\n                if(con != null &amp;&amp; !con.isClosed()) {\n                    con.close();    // 5. 释放数据库连接 \n                    con = null;     // 指示垃圾回收器可以回收该对象\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}<br></code></pre><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>83、简述正则表达式及其用途。&nbsp;</b><br>答：在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p><blockquote><p style=\"text-align: justify;\">说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，<span style=\"color: rgb(227, 55, 55);\">正则表达式就是在进行字符串匹配和处理的时候最为强大的工具</span>，绝大多数语言都提供了对正则表达式的支持。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>84、Java中是如何支持正则表达式操作的？&nbsp;</b><br>答：Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，请参考下面面试题的代码。</p><blockquote><p style=\"text-align: justify;\">面试题：&nbsp;- 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？</p></blockquote><pre><code class=\"lang-java\">import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass RegExpTest {\n\n    public static void main(String[] args) {\n        String str = \"北京市(朝阳区)(西城区)(海淀区)\";\n        Pattern p = Pattern.compile(\".*?(?=\\\\()\");\n        Matcher m = p.matcher(str);\n        if(m.find()) {\n            System.out.println(m.group());\n        }\n    }\n}<br></code></pre><blockquote><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">说明：</span><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">上面的正则表达式中使用了懒惰匹配和前瞻，如果不清楚这些内容，推荐读一下网上很有名的</span><a href=\"http://www.jb51.net/tools/zhengze.html\" target=\"_blank\">《正则表达式30分钟入门教程》</a><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">。</span><br></p></blockquote><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\"><br></span></p><p style=\"text-align: justify;\"><b>85、获得一个类的类对象有哪些方式？&nbsp;</b><br>答：&nbsp;<br>- 方法1：类型.class，例如：String.class&nbsp;<br>- 方法2：对象.getClass()，例如：\"hello\".getClass()&nbsp;<br>- 方法3：Class.forName()，例如：Class.forName(\"java.lang.String\")</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>86、如何通过反射创建对象？&nbsp;</b><br>答：&nbsp;<br>- 方法1：<span style=\"color: rgb(227, 55, 55);\">通过类对象调用newInstance()方法</span>，例如：String.class.newInstance()&nbsp;<br>- 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(\"Hello\");</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>87、如何通过反射获取和设置对象私有字段的值？&nbsp;</b><br>答：可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如ReflectionUtil.get(dog, \"owner.car.engine.id\");可以获得dog对象的主人的汽车的引擎的ID号。</p><pre><code class=\"lang-java\">import java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 反射工具类\n * @author 骆昊\n *\n */\npublic class ReflectionUtil {\n\n    private ReflectionUtil() {\n        throw new AssertionError();\n    }\n\n    /**\n     * 通过反射取对象指定字段(属性)的值\n     * @param target 目标对象\n     * @param fieldName 字段的名字\n     * @throws 如果取不到对象指定字段的值则抛出异常\n     * @return 字段的值\n     */\n    public static Object getValue(Object target, String fieldName) {\n        Class&lt;?&gt; clazz = target.getClass();\n        String[] fs = fieldName.split(\"\\\\.\");\n\n        try {\n            for(int i = 0; i &lt; fs.length - 1; i++) {\n                Field f = clazz.getDeclaredField(fs[i]);\n                f.setAccessible(true);\n                target = f.get(target);\n                clazz = target.getClass();\n            }\n\n            Field f = clazz.getDeclaredField(fs[fs.length - 1]);\n            f.setAccessible(true);\n            return f.get(target);\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * 通过反射给对象的指定字段赋值\n     * @param target 目标对象\n     * @param fieldName 字段的名称\n     * @param value 值\n     */\n    public static void setValue(Object target, String fieldName, Object value) {\n        Class&lt;?&gt; clazz = target.getClass();\n        String[] fs = fieldName.split(\"\\\\.\");\n        try {\n            for(int i = 0; i &lt; fs.length - 1; i++) {\n                Field f = clazz.getDeclaredField(fs[i]);\n                f.setAccessible(true);\n                Object val = f.get(target);\n                if(val == null) {\n                    Constructor&lt;?&gt; c = f.getType().getDeclaredConstructor();\n                    c.setAccessible(true);\n                    val = c.newInstance();\n                    f.set(target, val);\n                }\n                target = val;\n                clazz = target.getClass();\n            }\n\n            Field f = clazz.getDeclaredField(fs[fs.length - 1]);\n            f.setAccessible(true);\n            f.set(target, value);\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}<br></code></pre><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\"><br></span></p><p><b><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">88、如何通过反射调用对象的方法？</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></b></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：请看下面的代码：</span></p><pre><code class=\"lang-java\">import java.lang.reflect.Method;\n\nclass MethodInvokeTest {\n\n    public static void main(String[] args) throws Exception {\n        String str = \"hello\";\n        Method m = str.getClass().getMethod(\"toUpperCase\");\n        System.out.println(m.invoke(str));  // HELLO\n    }\n}<br></code></pre><p><br></p><p style=\"text-align: justify;\"><b>89、简述一下面向对象的\"六原则一法则\"。</b>&nbsp;<br>答：&nbsp;<br><span style=\"color: rgb(227, 55, 55);\">- 单一职责原则</span>：一个类只做它该做的事情。（单一职责原则想表达的就是\"高内聚\"，写代码最终极的原则只有六个字\"高内聚、低耦合\"，就如同葵花宝典或辟邪剑谱的中心思想就八个字\"欲练此功必先自宫\"，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫\"因为专注，所以专业\"，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）&nbsp;<br><span style=\"color: rgb(227, 55, 55);\">- 开闭原则</span>：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）&nbsp;<br><span style=\"color: rgb(227, 55, 55);\">- 依赖倒转原则</span>：<span style=\"color: rgb(32, 147, 97);\">面向接口编程</span>。（该原则说得直白和具体一些就是<span style=\"color: rgb(32, 147, 97);\">声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型</span>，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）&nbsp;<br><span style=\"color: rgb(227, 55, 55);\">- 里氏替换原则</span>：<span style=\"color: rgb(32, 147, 97);\">任何时候都可以用子类型替换掉父类型</span>。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。<span style=\"color: rgb(32, 147, 97);\">里氏替换原则可以检查继承关系是否合理</span>，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）&nbsp;<br><span style=\"color: rgb(227, 55, 55);\">- 接口隔离原则</span>：<span style=\"color: rgb(32, 147, 97);\">接口要小而专，绝不能大而全</span>。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）&nbsp;<br>- <span style=\"color: rgb(227, 55, 55);\">合成聚合复用原则</span>：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表<span style=\"color: rgb(32, 147, 97);\">继承、关联和依赖</span>。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，<span style=\"color: rgb(200, 167, 50);\">即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。</span>记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）&nbsp;<br>- <span style=\"color: rgb(227, 55, 55);\">迪米特法则</span>：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（<span style=\"color: rgb(32, 147, 97);\">迪米特法则简单的说就是如何做到\"低耦合\"</span>，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）</p><p style=\"text-align: justify;\"><img src=\"https://img-blog.csdn.net/20150408153246930\" alt=\"这里写图片描述\">&nbsp;<br><img src=\"https://img-blog.csdn.net/20150408153213362\" alt=\"这里写图片描述\"></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>90、简述一下你了解的设计模式。</b>&nbsp;<br>答：所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。&nbsp;<br>在GoF的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共23种设计模式，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。&nbsp;<br>面试被问到关于设计模式的知识时，可以拣最常用的作答，例如：&nbsp;<br>- 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。&nbsp;<br>- 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。&nbsp;<br>- 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。&nbsp;<br>- 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。&nbsp;<br>除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections工具类和I/O系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。</p><p><br></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\"><b>91、用Java写一个单例类。</b></span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：&nbsp;</span></p><ul><li><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">饿汉式单例</span></li></ul><pre><code class=\"lang-java\">public class Singleton {\n    private Singleton(){}\n    private static Singleton instance = new Singleton();\n    public static Singleton getInstance(){\n        return instance;\n    }\n}<br></code></pre><ul><li>懒汉式单例</li></ul><pre><code class=\"lang-java\">public class Singleton {\n    private static Singleton instance = null;\n    private Singleton() {}\n    public static synchronized Singleton getInstance(){\n        if (instance == null) instance ＝ new Singleton();\n        return instance;\n    }\n}<br></code></pre><blockquote><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">注意：</span><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">实现一个单例有两点注意事项，①将构造器私有，不允许外界通过构造器创建对象；②通过公开的静态方法向外界返回类的唯一实例。这里有一个问题可以思考：Spring的IoC容器可以为普通的类创建单例，它是怎么做到的呢？</span><br></p></blockquote><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\"><br></span></p><p style=\"text-align: justify;\"><b>92、什么是UML？&nbsp;</b><br>答：UML是统一建模语言（Unified Modeling Language）的缩写，它发表于1997年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>93、UML中有哪些常用的图？&nbsp;</b><br>答：UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。&nbsp;<br>用例图：&nbsp;<br><img src=\"https://img-blog.csdn.net/20150408151744237\" alt=\"这里写图片描述\">&nbsp;<br>类图：&nbsp;<br><img src=\"https://img-blog.csdn.net/20150408151843748\" alt=\"这里写图片描述\">&nbsp;<br>时序图：&nbsp;<br><img src=\"https://img-blog.csdn.net/20150408153230144\" alt=\"这里写图片描述\"></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><br></p><p><b><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">94、用Java写一个冒泡排序。</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></b></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：冒泡排序几乎是个程序员都写得出来，但是面试的时候如何写一个逼格高的冒泡排序却不是每个人都能做到，下面提供一个参考代码：</span></p><pre><code class=\"lang-java\">import java.util.Comparator;\n\n/**\n * 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换)\n * @author骆昊\n *\n */\npublic interface Sorter {\n\n   /**\n    * 排序\n    * @param list 待排序的数组\n    */\n   public &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] list);\n\n   /**\n    * 排序\n    * @param list 待排序的数组\n    * @param comp 比较两个对象的比较器\n    */\n   public &lt;T&gt; void sort(T[] list, Comparator&lt;T&gt; comp);\n}<br></code></pre><pre><code class=\"lang-java\">import java.util.Comparator;\n\n/**\n * 冒泡排序\n * \n * @author骆昊\n *\n */\npublic class BubbleSorter implements Sorter {\n\n    @Override\n    public &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] list) {\n        boolean swapped = true;\n        for (int i = 1, len = list.length; i &lt; len &amp;&amp; swapped; ++i) {\n            swapped = false;\n            for (int j = 0; j &lt; len - i; ++j) {\n                if (list[j].compareTo(list[j + 1]) &gt; 0) {\n                    T temp = list[j];\n                    list[j] = list[j + 1];\n                    list[j + 1] = temp;\n                    swapped = true;\n                }\n            }\n        }\n    }\n\n    @Override\n    public &lt;T&gt; void sort(T[] list, Comparator&lt;T&gt; comp) {\n        boolean swapped = true;\n        for (int i = 1, len = list.length; i &lt; len &amp;&amp; swapped; ++i) {\n            swapped = false;\n            for (int j = 0; j &lt; len - i; ++j) {\n                if (comp.compare(list[j], list[j + 1]) &gt; 0) {\n                    T temp = list[j];\n                    list[j] = list[j + 1];\n                    list[j + 1] = temp;\n                    swapped = true;\n                }\n            }\n        }\n    }\n}<br></code></pre><p><br></p><p><b><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">95、用Java写一个折半查找。</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></b></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：折半查找，也称二分查找、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组已经为空，则表示找不到指定的元素。这种搜索算法每一次比较都使搜索范围缩小一半，其时间复杂度是O(logN)。</span></p><pre><code class=\"lang-java\">import java.util.Comparator;\n\npublic class MyUtil {\n\n   public static &lt;T extends Comparable&lt;T&gt;&gt; int binarySearch(T[] x, T key) {\n      return binarySearch(x, 0, x.length- 1, key);\n   }\n\n   // 使用循环实现的二分查找\n   public static &lt;T&gt; int binarySearch(T[] x, T key, Comparator&lt;T&gt; comp) {\n      int low = 0;\n      int high = x.length - 1;\n      while (low &lt;= high) {\n          int mid = (low + high) &gt;&gt;&gt; 1;\n          int cmp = comp.compare(x[mid], key);\n          if (cmp &lt; 0) {\n            low= mid + 1;\n          }\n          else if (cmp &gt; 0) {\n            high= mid - 1;\n          }\n          else {\n            return mid;\n          }\n      }\n      return -1;\n   }\n\n   // 使用递归实现的二分查找\n   private static&lt;T extends Comparable&lt;T&gt;&gt; int binarySearch(T[] x, int low, int high, T key) {\n      if(low &lt;= high) {\n        int mid = low + ((high -low) &gt;&gt; 1);\n        if(key.compareTo(x[mid])== 0) {\n           return mid;\n        }\n        else if(key.compareTo(x[mid])&lt; 0) {\n           return binarySearch(x,low, mid - 1, key);\n        }\n        else {\n           return binarySearch(x,mid + 1, high, key);\n        }\n      }\n      return -1;\n   }\n}<br></code></pre><blockquote><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">说明：</span><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">上面的代码中给出了折半查找的两个版本，一个用递归实现，一个用循环实现。需要注意的是计算中间位置时不应该使用(high+ low) / 2的方式，因为加法运算可能导致整数越界，这里应该使用以下三种方式之一：low + (high - low) / 2或low + (high – low) &gt;&gt; 1或(low + high) &gt;&gt;&gt; 1（&gt;&gt;&gt;是逻辑右移，是不带符号位的右移）</span><br></p></blockquote><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\"><br></span></p><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">原文地址：<a href=\"https://blog.csdn.net/jackfrued/article/details/44921941\" target=\"_blank\">https://blog.csdn.net/jackfrued/article/details/44921941</a></span></p>', '2018-06-14 09:35:27', '/articles/10001', '0', '0', 'publish', '1、面向对象的特征有哪些方面？ <span style=\"color', 'Java,面试', 'Java面试题全集（上）—— Java基础篇', '2019-03-18 00:39:22', '64', '1', '10001', '1');
INSERT INTO `article` VALUES ('10002', '0', '7', '<p><span style=\"font-size: 14px;\">我们先简单讲一下重载和重写的区别</span></p><p style=\"text-align: justify;\"><b>重写：同名同参，两同两小一大（父子类继承关系）</b></p><p style=\"text-align: justify;\">1、两同：方法名相同，参数列表相同</p><p style=\"text-align: justify;\">2、两小：子类返回值类型(如 Dog) &lt;= 父类返回值类型(如 Animal)，子类方法声明抛出的异常(如 IOException ) &lt;= 父类方法声明抛出的异常(如&nbsp;IOException 或&nbsp;Exception )</p><p style=\"text-align: justify;\">3、一大：子类方法返回权限(如 public ) &gt; 父类方法访问权限(如 private,default,protect)</p><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>重载：同名不同参，返回值无关</b></p><p style=\"text-align: justify;\">1、方法名必须相同，参数列表不同</p><p style=\"text-align: justify;\">2、可以有不同的返回类型</p><p style=\"text-align: justify;\">3、可以有不同的访问权限</p><p style=\"text-align: justify;\">4、可以抛不同的参数</p><p><span style=\"font-size: 14px;\"><br></span></p><p><span style=\"font-size: medium;\">知道什么是重写和重载后，我们来看这个问题 <span style=\"color: rgb(227, 55, 55);\">“为什么不能根据返回类型来区分重载”</span>。</span></p><blockquote><p>原因：因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。<br></p></blockquote><p><br></p><p><span style=\"font-size: 17.5px;\">例如</span><br></p><pre><code class=\"lang-java\">float max(int a, int b);\nint max(int a, int b);<br></code></pre><p style=\"text-align: justify;\">当调用max(1, 2);时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的。</p><p style=\"text-align: justify;\">再比如对下面这两个方法来说，虽然它们有同样的名字和自变量，但其实是很容易区分的：&nbsp;</p><pre><code class=\"lang-java\">void f() {} \nint f() {} <br></code></pre><p style=\"text-align: justify;\">若编译器可根据上下文（语境）明确判断出含义，比如在 int x=f()中，那么这样做完全没有问题。</p><p style=\"text-align: justify;\"><span style=\"color: rgb(227, 55, 55);\">然而，&nbsp;我们也可能调用一个方法，同时忽略返回值；我们通常把这称为“为它的副作用去调用一个方法”，因为我&nbsp;<br>们关心的不是返回值，而是方法调用的其他效果</span>。</p><p style=\"text-align: justify;\">所以假如我们象下面这样调用方法：&nbsp;f();&nbsp;</p><p style=\"text-align: justify;\">Java 怎样判断f()的具体调用方式呢？而且别人如何识别并理解代码呢？由于存在这一类的问题，所以不能根据返回值类型来区分过载的方法。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><i><b>函数的返回值只是作为函数运行之后的一个“状态”，</b></i></p><p style=\"text-align: justify;\"><i><b>他是保持方法的调用者与被调用者进行通信的关键。</b></i></p><p style=\"text-align: justify;\"><i><b>并不能作为某个方法的“标识”</b></i></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b><br></b></p>', '2018-06-14 20:35:58', '/articles/10002', '0', '0', 'publish', '我们先简单讲一下重载和重写的区别重写：同名同参，两同两小一大（父子类继承关系）<p style=\"text-align: j', 'Java,面试', '为什么不能根据返回类型区分重载？', '2019-03-30 00:57:04', '51', '1', '10001', '1'), ('10003', '2', '5', '<p>白头吟</p>', '2018-06-15 16:04:21', '/articles/10003', '0', '0', 'publish', '白头吟', '', '愿得一心人，白首不相离', '2019-03-30 00:57:30', '65', '2', '10002', '8'), ('10004', '0', '1', '<h2>Class类概念</h2><p style=\"text-align: justify;\">Class也是一个Java类，保存的是与之对应Java类的meta信息（元信息），用来描述这个类的结构，比如描述一个类有哪些成员，有哪些方法等。一般在反射中使用。<br></p><p style=\"text-align: justify;\">详细解释：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例（Class对象）。也就是说，在Java中，每个java类都有一个相应的Class对象，用于表示这个java类的类型信息。</p><h2>类加载概念</h2><p style=\"text-align: justify;\">当使用一个类的时候（比如new一个类的实例），会检查此类是否被加载到内存，如果没有，则会执行加载操作。</p><p style=\"text-align: justify;\">读取类对应的class文件数据，解析此数据，构造一个此类对应的Class类的实例。此时JVM就可以使用该类了，比如实例化此类，或者调用此类的静态方法。</p><p style=\"text-align: justify;\">Java也提供了手动加载类的接口，class.forName()方法就是其中之一。</p><p style=\"text-align: justify;\">（说来说去，其实就是生成这个类的Class）</p><h2><span style=\"font-size: 18px;\">类加载器的概念</span></h2><p><span style=\"font-size: medium;\">顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。<br>基本上所有的类加载器都是 java.lang.ClassLoader类的一个实例。</span></p><h2>类初始化概念</h2><p style=\"text-align: justify;\">类被加载之后，jvm已经获得了一个描述类结构的Class实例。但是还需要进行类初始化操作之后才能正常使用此类，类初始化操作就是执行一遍<span style=\"color: rgb(51, 51, 255);\">类的静态语句</span>，包括静态变量的声明还有静态代码块。</p><h2>Class.forName()方法</h2><p style=\"text-align: justify;\">此方法含义是：加载参数指定的类，并且初始化它。</p><h2>在jdbc连接数据库中的应用</h2><p style=\"text-align: justify;\">到这里，不用解释，读者也会明白，在使用jdbc方式连接数据库时，为什么要执行Class.forName(\'驱动类名\')方法了：将驱动类的class文件装载到内存中，并且形成一个描述此驱动类结构的Class类实例，并且初始化此驱动类，这样jvm就可以使用它了，这就是Class.forName()方法的含义。</p><p style=\"text-align: justify;\">有数据库开发经验朋友会发现，为什么在我们加载数据库驱动包的时候有的却没有调用newInstance( )方法呢？即有的jdbc连接数据库的写法里是Class.forName(xxx.xx.xx);而有一 些：Class.forName(xxx.xx.xx).newInstance()，为什么会有这两种写法呢？&nbsp;<br>刚才提到，Class.forName(\"\");的作用是要求JVM查找并加载指定的类，如果在类中有静态初始化器的话，JVM必然会执行该类的静态代码段。<span style=\"color: rgb(227, 55, 55);\">而在JDBC规范中明确要求这个Driver类必须向DriverManager注册自己</span>，即任何一个JDBC Driver的 Driver类的代码都必须类似如下：&nbsp;</p><pre><code>public class MyJDBCDriver implements Driver { &nbsp; &nbsp;\n&nbsp; &nbsp; static&nbsp;{&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp;DriverManager.registerDriver(new MyJDBCDriver()); &nbsp;\n&nbsp; &nbsp; }&nbsp;\n}&nbsp;<br></code></pre><p></p><p style=\"text-align: justify;\"><br><span style=\"color: rgb(32, 147, 97);\">既然在静态初始化器的中已经进行了注册，所以我们在使用JDBC时只需要Class.forName(XXX.XXX);就可以了</span>。</p>', '2018-06-17 09:30:52', '/articles/10004', '0', '0', 'publish', 'Class类概念Class也是一个Java类，保存的是与之对应Java类的meta信息（元信息），用来描述这个类的结构，比如描述一个类有哪些成员，有哪些方法等。一般在反射中使用。<p style=\"te', 'Java,JavaWeb,JDBC', '理解Class.forName()', '2019-03-08 14:52:23', '8', '0', '10003', '1'), ('10005', '0', '0', '<p style=\"text-align: justify;\">共享锁【S锁】<br>又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</p><p style=\"text-align: justify;\">排他锁【X锁】<br>又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。<br></p>', '2018-06-17 10:49:37', '/articles/10005', '0', '0', 'publish', '共享锁【S锁】又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。<p', '锁,共享锁,排它锁,数据库', '共享锁（S锁）和排它锁（X锁）', '2019-03-29 09:15:24', '17', '0', '10004', '1'), ('10006', '0', '0', '<p style=\"margin-left: auto;\">&nbsp; &nbsp; &nbsp; &nbsp;锁就是防止其他事务访问指定资源的手段。锁是实现并发控制的主要方法，是多个用户能够同时操纵同一个数据库中的数据而不发生数据不一致现象的重要保障。 一般来说，锁可以防止脏读、不可重复读和幻读。</p><h1><span style=\"color: rgb(227, 55, 55);\">1、<b>脏读</b>(Dirty Read)</span></h1><p><span style=\"font-size: 18px; color: rgb(32, 147, 97);\">针对未提交数据</span><br></p><p style=\"margin-left: auto;\">详细解释：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p><p style=\"margin-left: auto;\">事务T1：更新一条数据<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --&gt;事务T2：读取事务T1更新的记录<br>&nbsp;事务T1：调用commit进行提交<br>&nbsp;此时事务T2读取到的数据是保存在数据库内存中的数据，称为脏数据，这个过程称为脏读。</p><p style=\"margin-left: auto;\">脏读发生在一个事务A读取了被另一个事务B修改，但是还未提交的数据。假如B回退，则事务A读取的是无效的数据。这跟不可重复读类似，但是第二个事务不需要执行提交。</p><p style=\"margin-left: auto;\">解决脏读问题：<span style=\"color: rgb(227, 55, 55);\"><b>修改时加排他锁，直到事务提交后才释放，读取时加共享锁</b></span>，读取完释放事务1读取数据时加上共享锁后（这样在事务1读取数据的过程中，其他事务就不会修改该数据），不允许任何事务操作该数据，只能读取，之后1如果有更新操作，那么会转换为排他锁，其他事务更无权参与进来读写，这样就防止了脏读问题。但是当事务1读取数据过程中，有可能其他事务也读取了该数据，读取完毕后共享锁释放，此时事务1修改数据，修改完毕提交事务，其他事务再次读取数据时候发现数据不一致，就会出现不可重复读问题，所以这样不能够避免不可重复读问题。</p><table>    <colgroup>        <col width=\"33.29355608591885%\">        <col width=\"33.29355608591885%\">        <col width=\"33.53221957040573%\">    </colgroup>    <thead>        <tr>            <th>时间</th>            <th>转账事务A</th>            <th>取款事务B</th>        </tr>    </thead>    <tbody>        <tr>            <td>T1</td>            <td>&nbsp;</td>            <td>开始事务</td>        </tr>        <tr>            <td>T2</td>            <td>开始事务</td>            <td>&nbsp;</td>        </tr>        <tr>            <td>T3</td>            <td>&nbsp;</td>            <td>查询账户余额为1000元</td>        </tr>        <tr>            <td>T4</td>            <td>&nbsp;</td>            <td>取出500元余额修改为500元</td>        </tr>        <tr>            <td>T5</td>            <td>查询账户余额为500元（脏读）</td>            <td>&nbsp;</td>        </tr>        <tr>            <td>T6</td>            <td>&nbsp;</td>            <td>撤销事务余额恢复为1000元</td>        </tr>        <tr>            <td>T7</td>            <td>汇入100元把余额修改为600元</td>            <td>&nbsp;</td>        </tr>        <tr>            <td>T8</td>            <td>提交事务</td>            <td>&nbsp;</td>        </tr>    </tbody></table><h1><span style=\"color: rgb(227, 55, 55);\"><br></span></h1><h1><span style=\"color: rgb(227, 55, 55);\">2、<b>幻读</b>（Phantom）</span></h1><p><span style=\"color: rgb(32, 147, 97); font-size: 18px;\">针对其他提交前后，读取数据</span><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b style=\"\">条数</b></span><span style=\"color: rgb(32, 147, 97); font-size: 18px;\">的对比</span><br></p><p style=\"margin-left: auto;\">详细解释：幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p><p style=\"margin-left: auto;\">事务T1：查询表中所有记录<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --&gt;事务T2：插入一条记录<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --&gt;事务T2：调用commit进行提交<br>事务T1：再次查询表中所有记录<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<br>此时事务T1两次查询到的记录是不一样的，称为幻读。</p><p style=\"margin-left: auto;\"><span style=\"color: rgb(255, 0, 0);\">注意：幻读重点在新增或删除。</span></p><p style=\"margin-left: auto;\">幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。</p><p style=\"margin-left: auto;\"><span style=\"color: rgb(255, 0, 0);\">发生的情况：没有范围锁。</span></p><p style=\"margin-left: auto;\">如何避免：实行序列化隔离模式，在任何一个低级别的隔离中都可能会发生。</p><p style=\"margin-left: auto;\">解决幻读问题：采用的是范围锁RangeS&nbsp;RangeS_S模式，锁定检索范围为只读，这样就避免了幻读问题。</p><p style=\"margin-left: auto;\"><br></p><h1><span style=\"color: rgb(227, 55, 55);\">3、<b>不可重复读</b>（Nonrepeatable Read）</span></h1><p><span style=\"font-size: 18px; color: rgb(32, 147, 97);\">针对其他提交前后，读取数据本身的对比</span><br></p><p style=\"margin-left: auto;\">事务T1：查询一条记录<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--&gt;事务T2：更新事务T1查询的记录<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--&gt;事务T2：调用commit进行提交<br>事务T1：再次查询上次的记录<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<br>此时事务T1对同一数据查询了两次，可得到的内容不同，称为不可重复读。</p><p style=\"margin-left: auto;\"><span style=\"color: rgb(255, 0, 0);\">注意：不可重复读重点在修改。</span></p><p style=\"margin-left: auto;\">在基于锁的并行控制方法中，如果在执行select时不添加读锁，就会发生不可重复读问题。</p><p style=\"margin-left: auto;\">在多版本并行控制机制中，当一个遇到提交冲突的事务需要回退但却被释放时，会发生不可重复读问题。</p><p style=\"margin-left: auto;\">有两个策略可以防止这个问题的发生：</p><p style=\"margin-left: auto;\">（1） 推迟事务2的执行，直至事务1提交或者回退。这种策略在使用锁时应用。</p><p style=\"margin-left: auto;\">（2） 而在多版本并行控制中，事务2可以被先提交，而事务1继续执行在旧版本的数据上。当事务1终于尝试提交时，数据库会检验它的结果是否和事务1、事务2顺序执行时一样。如果是，则事务1提交成功；如果不是，事务1会被回退。</p><p style=\"margin-left: auto;\">解决不可重复读问题：读取数据时加共享锁，写数据时加排他锁，都是事务提交才释放锁。读取时候不允许其他事物修改该数据，不管数据在事务过程中读取多少次，数据都是一致的，避免了不可重复读问题。<br><br></p><h1><span style=\"color: rgb(227, 55, 55);\">4、<strong style=\"\">丢失更新</strong>（Lost Update）&nbsp;</span><br><br>事务T1读取了数据，并执行了一些操作，然后更新数据。事务T2也做相同的事，则T1和T2更新数据时可能会覆盖对方的更新，从而引起错误。</h1><p style=\"margin-left: auto;\">5.处理以上隔离级别的问题，采用如下方法：</p><p style=\"margin-left: auto;\">&nbsp; 事务隔离五种级别：<br>&nbsp; &nbsp; &nbsp; &nbsp; （1）TRANSACTION_NONE&nbsp; 不使用事务。<br>&nbsp; &nbsp; &nbsp; &nbsp; （2）TRANSACTION_READ_UNCOMMITTED&nbsp; 允许脏读。<br>&nbsp; &nbsp; &nbsp; &nbsp; （3）TRANSACTION_READ_COMMITTED&nbsp; 防止脏读，最常用的隔离级别,并且是大多数数据库的默认隔离级别。<br>&nbsp;    &nbsp; &nbsp; &nbsp; （4）TRANSACTION_REPEATABLE_READ&nbsp; 可以防止脏读和不可重复读。<br>&nbsp; &nbsp; &nbsp; &nbsp; （5）TRANSACTION_SERIALIZABLE&nbsp; 可以防止脏读，不可重复读取和幻读，（事务串行化）会降低数据库的效率。</p><p style=\"margin-left: auto;\">&nbsp; 以上的五个事务隔离级别都是在Connection接口中定义的静态常量，使用setTransactionIsolation(int level) 方法可以设置事务隔离级别。</p><p style=\"margin-left: auto;\">&nbsp;&nbsp;如:con.setTransactionIsolation(Connection.REPEATABLE_READ)。</p><p style=\"margin-left: auto;\">&nbsp; 注意：事务的隔离级别受数据库的限制，不同的数据库支持的的隔离级别不一定相同。</p><p><br></p><p><br></p><h1><span style=\"font-size: 18px;\"><span style=\"color: rgb(226, 139, 65);\">不可重复读和幻读区别</span></span></h1><p><span style=\"font-size: 18px;\">对于不可重复读和幻读，可以借用下面的例子理解：</span></p><p><br></p><h2>不可重复读</h2><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"><span style=\"color: rgb(51, 51, 51);\">不可重复读的重点是</span><span style=\"color: rgb(255, 0, 0);\">修改</span><span style=\"color: rgb(51, 51, 51);\">:</span></span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-size: 14px;\">同样的条件,&nbsp;你读取过的数据,&nbsp;再次读取出来发现值不一样了</span></span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-size: 14px;\">例子：</span></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">在事务1中，Mary 读取了自己的工资为1000,操作并没有完成&nbsp;</span></p><pre><code class=\"lang-sql\">con1&nbsp;=&nbsp;getConnection();&nbsp;&nbsp;\nselect&nbsp;salary&nbsp;from&nbsp;employee&nbsp;empId&nbsp;=\"Mary\";&nbsp;<br></code></pre><p><span style=\"color: rgb(85, 85, 85); font-size: 14px;\">在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务.&nbsp;</span><br></p><pre><code class=\"lang-sql\">con2&nbsp;=&nbsp;getConnection();&nbsp;&nbsp;\nupdate&nbsp;employee&nbsp;set&nbsp;salary&nbsp;=&nbsp;2000;&nbsp;&nbsp;\ncon2.commit();&nbsp;&nbsp;<br></code></pre><p><span style=\"color: rgb(85, 85, 85); font-size: 14px;\"><span style=\"color: rgb(85, 85, 85); font-size: 14px;\">在事务1中，Mary 再次读取自己的工资时，工资变为了2000&nbsp;</span><br></span></p><pre><code class=\"lang-sql\">//con1&nbsp;&nbsp;\nselect&nbsp;salary&nbsp;from&nbsp;employee&nbsp;empId&nbsp;=\"Mary\"; &nbsp;<br></code></pre><p><span style=\"font-size: 14px; color: rgb(85, 85, 85);\">在一个事务中前后两次读取的结果并不致，导致了不可重复读。</span></p><p><b style=\"color: rgb(0, 0, 0);\"><br></b></p><h2><span style=\"color: rgb(0, 0, 0);\">幻读</span></h2><p><span style=\"font-size: 14px;\">幻读的重点在于<span style=\"color: rgb(255, 0, 0);\">新增或者删除 (数据条数变化)</span><br></span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-size: 14px;\">同样的条件,&nbsp;第1次和第2次读出来的记录数不一样</span></span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-size: 14px;\">例子：</span></span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-size: 14px;\">目前工资为1000的员工有10人。&nbsp;<br>事务1,读取所有工资为1000的员工。&nbsp;</span></span></p><pre><code class=\"lang-sql\">con1&nbsp;=&nbsp;getConnection();&nbsp;&nbsp;\nSelect&nbsp;*&nbsp;from&nbsp;employee&nbsp;where&nbsp;salary&nbsp;=1000;&nbsp;&nbsp;<br></code></pre><p><span style=\"color: rgb(85, 85, 85); font-size: 14px;\">共读取10条记录&nbsp;</span></p><p><span style=\"color: rgb(85, 85, 85); font-size: 14px;\">这时另一个事务向employee表插入了一条员工记录，工资也为1000&nbsp;</span><br></p><pre><code class=\"lang-sql\">con2&nbsp;=&nbsp;getConnection();&nbsp;&nbsp;\nInsert&nbsp;into&nbsp;employee(empId,salary)&nbsp;values(\"Lili\",1000);&nbsp;&nbsp;\ncon2.commit();&nbsp;&nbsp;<br></code></pre><p><span style=\"color: rgb(85, 85, 85); font-size: 14px;\">事务1再次读取所有工资为1000的员工&nbsp;</span><br></p><pre><code class=\"lang-sql\">//con1&nbsp;&nbsp;\nselect&nbsp;*&nbsp;from&nbsp;employee&nbsp;where&nbsp;salary&nbsp;=1000;<br></code></pre><p><span style=\"color: rgb(85, 85, 85); font-size: 14px;\">共读取到了11条记录，这就</span><span style=\"color: rgb(85, 85, 85); font-size: 14px;\">像</span><span style=\"color: rgb(85, 85, 85); font-size: 14px;\">产生了幻读。&nbsp;</span><br></p>', '2018-06-17 12:09:01', '/articles/10006', '0', '0', 'publish', '       锁就是防止其他事务访问指定资源的手段。锁是实现并发控制的主要方法，是多个用户能够同时操纵同一个数据库中的数据而不发生数据不一致现象的重要保障。 一般来说，锁可以防止脏读、不可重复读和幻读', '脏读,幻读,不可重复读,丢失更新', '脏读、幻读、不可重复读和丢失更新', '2018-10-11 10:35:02', '10', '0', '10004', '1'), ('10008', '0', '0', '<p style=\"text-align: justify;\">这部分主要是与Java Web和Web Service相关的面试题。</p><p style=\"text-align: justify;\"><b>96、阐述Servlet和CGI的区别?&nbsp;</b><br>答：Servlet与CGI的区别在于Servlet处于服务器进程中，它通过多线程方式运行其service()方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet。</p><blockquote><p style=\"text-align: justify;\">补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>97、Servlet接口中有哪些方法？&nbsp;</b><br>答：Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关：&nbsp;<br>- void init(ServletConfig config) throws ServletException&nbsp;<br>- void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException&nbsp;<br>- void destory()&nbsp;<br>- java.lang.String getServletInfo()&nbsp;<br>- ServletConfig getServletConfig()</p><p style=\"text-align: justify;\">Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。</p><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>98、转发（forward）和重定向（redirect）的区别？&nbsp;</b><br>答：forward是容器中控制权的转向，是服务器请求资源，服务器直接访问目标地址的URL，把那个URL 的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。redirect就是服务器端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，因此从浏览器的地址栏中可以看到跳转后的链接地址，很明显redirect无法访问到服务器保护起来资源，但是可以从一个网站redirect到其他网站。forward更加高效，所以在满足需要时尽量使用forward（通过调用RequestDispatcher对象的forward()方法，该对象可以通过ServletRequest对象的getRequestDispatcher()方法获得），并且这样也有助于隐藏实际的链接；在有些情况下，比如需要访问一个其它服务器上的资源，则必须使用重定向（通过HttpServletResponse对象调用其sendRedirect()方法实现）。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>99、JSP有哪些内置对象？作用分别是什么？&nbsp;</b><br>答：JSP有9个内置对象：&nbsp;<br>- request：封装客户端的请求，其中包含来自GET或POST请求的参数；&nbsp;<br>- response：封装服务器对客户端的响应；&nbsp;<br>- pageContext：通过该对象可以获取其他对象；&nbsp;<br>- session：封装用户会话的对象；&nbsp;<br>- application：封装服务器运行环境的对象；&nbsp;<br>- out：输出服务器响应的输出流对象；&nbsp;<br>- config：Web应用的配置对象；&nbsp;<br>- page：JSP页面本身（相当于Java程序中的this）；&nbsp;<br>- exception：封装页面抛出异常的对象。</p><blockquote><p style=\"text-align: justify;\">补充：如果用Servlet来生成网页中的动态内容无疑是非常繁琐的工作，另一方面，所有的文本和HTML标签都是硬编码，即使做出微小的修改，都需要进行重新编译。JSP解决了Servlet的这些问题，它是Servlet很好的补充，可以专门用作为用户呈现视图（View），而Servlet作为控制器（Controller）专门负责处理用户请求并转发或重定向到某个页面。基于Java的Web开发很多都同时使用了Servlet和JSP。JSP页面其实是一个Servlet，能够运行Servlet的服务器（Servlet容器）通常也是JSP容器，可以提供JSP页面的运行环境，Tomcat就是一个Servlet/JSP容器。第一次请求一个JSP页面时，Servlet/JSP容器首先将JSP页面转换成一个JSP页面的实现类，这是一个实现了JspPage接口或其子接口HttpJspPage的Java类。JspPage接口是Servlet的子接口，因此每个JSP页面都是一个Servlet。转换成功后，容器会编译Servlet类，之后容器加载和实例化Java字节码，并执行它通常对Servlet所做的生命周期操作。对同一个JSP页面的后续请求，容器会查看这个JSP页面是否被修改过，如果修改过就会重新转换并重新编译并执行。如果没有则执行内存中已经存在的Servlet实例。我们可以看一段JSP代码对应的Java程序就知道一切了，而且9个内置对象的神秘面纱也会被揭开。</p></blockquote><p style=\"text-align: justify;\">JSP页面：</p><pre><code class=\"lang-java\">&lt;%@ page pageEncoding=\"UTF-8\"%&gt;\n&lt;%\nString path = request.getContextPath();\nString basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";\n%&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;base href=\"&lt;%=basePath%&gt;\"&gt;\n    &lt;title&gt;首页&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        * { font-family: \"Arial\"; }\n    &lt;/style&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;h1&gt;Hello, World!&lt;/h1&gt;\n    &lt;hr/&gt;\n    &lt;h2&gt;Current time is: &lt;%= new java.util.Date().toString() %&gt;&lt;/h2&gt;\n  &lt;/body&gt;\n&lt;/html&gt;<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">对应的Java代码：</span><br></p><pre><code class=\"lang-java\">/*\n * Generated by the Jasper component of Apache Tomcat\n * Version: Apache Tomcat/7.0.52\n * Generated at: 2014-10-13 13:28:38 UTC\n * Note: The last modified time of this file was set to\n *       the last modified time of the source file after\n *       generation to assist with modification tracking.\n */\npackage org.apache.jsp;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport javax.servlet.jsp.*;\n\npublic final class index_jsp extends org.apache.jasper.runtime.HttpJspBase\n        implements org.apache.jasper.runtime.JspSourceDependent {\n\n    private static final javax.servlet.jsp.JspFactory _jspxFactory = javax.servlet.jsp.JspFactory\n            .getDefaultFactory();\n\n    private static java.util.Map&lt;java.lang.String, java.lang.Long&gt; _jspx_dependants;\n\n    private javax.el.ExpressionFactory _el_expressionfactory;\n    private org.apache.tomcat.InstanceManager _jsp_instancemanager;\n\n    public java.util.Map&lt;java.lang.String, java.lang.Long&gt; getDependants() {\n        return _jspx_dependants;\n    }\n\n    public void _jspInit() {\n        _el_expressionfactory = _jspxFactory.getJspApplicationContext(\n                getServletConfig().getServletContext()).getExpressionFactory();\n        _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory\n                .getInstanceManager(getServletConfig());\n    }\n\n    public void _jspDestroy() {\n    }\n\n    public void _jspService(\n            final javax.servlet.http.HttpServletRequest request,\n            final javax.servlet.http.HttpServletResponse response)\n            throws java.io.IOException, javax.servlet.ServletException {\n        // 内置对象就是在这里定义的\n        final javax.servlet.jsp.PageContext pageContext;\n        javax.servlet.http.HttpSession session = null;\n        final javax.servlet.ServletContext application;\n        final javax.servlet.ServletConfig config;\n        javax.servlet.jsp.JspWriter out = null;\n        final java.lang.Object page = this;\n        javax.servlet.jsp.JspWriter _jspx_out = null;\n        javax.servlet.jsp.PageContext _jspx_page_context = null;\n\n        try {\n            response.setContentType(\"text/html;charset=UTF-8\");\n            pageContext = _jspxFactory.getPageContext(this, request, response,\n                    null, true, 8192, true);\n            _jspx_page_context = pageContext;\n            application = pageContext.getServletContext();\n            config = pageContext.getServletConfig();\n            session = pageContext.getSession();\n            out = pageContext.getOut();\n            _jspx_out = out;\n\n            out.write(\'\\r\');\n            out.write(\'\\n\');\n\n            String path = request.getContextPath();\n            String basePath = request.getScheme() + \"://\"\n                    + request.getServerName() + \":\" + request.getServerPort()\n                    + path + \"/\";\n// 以下代码通过输出流将HTML标签输出到浏览器中\n            out.write(\"\\r\\n\");\n            out.write(\"\\r\\n\");\n            out.write(\"&lt;!DOCTYPE html&gt;\\r\\n\");\n            out.write(\"&lt;html&gt;\\r\\n\");\n            out.write(\"  &lt;head&gt;\\r\\n\");\n            out.write(\"    &lt;base href=\\\"\");\n            out.print(basePath);\n            out.write(\"\\\"&gt;\\r\\n\");\n            out.write(\"    &lt;title&gt;首页&lt;/title&gt;\\r\\n\");\n            out.write(\"    &lt;style type=\\\"text/css\\\"&gt;\\r\\n\");\n            out.write(\"    \\t* { font-family: \\\"Arial\\\"; }\\r\\n\");\n            out.write(\"    &lt;/style&gt;\\r\\n\");\n            out.write(\"  &lt;/head&gt;\\r\\n\");\n            out.write(\"  \\r\\n\");\n            out.write(\"  &lt;body&gt;\\r\\n\");\n            out.write(\"    &lt;h1&gt;Hello, World!&lt;/h1&gt;\\r\\n\");\n            out.write(\"    &lt;hr/&gt;\\r\\n\");\n            out.write(\"    &lt;h2&gt;Current time is: \");\n            out.print(new java.util.Date().toString());\n            out.write(\"&lt;/h2&gt;\\r\\n\");\n            out.write(\"  &lt;/body&gt;\\r\\n\");\n            out.write(\"&lt;/html&gt;\\r\\n\");\n        } catch (java.lang.Throwable t) {\n            if (!(t instanceof javax.servlet.jsp.SkipPageException)) {\n                out = _jspx_out;\n                if (out != null &amp;&amp; out.getBufferSize() != 0)\n                    try {\n                        out.clearBuffer();\n                    } catch (java.io.IOException e) {\n                    }\n                if (_jspx_page_context != null)\n                    _jspx_page_context.handlePageException(t);\n                else\n                    throw new ServletException(t);\n            }\n        } finally {\n            _jspxFactory.releasePageContext(_jspx_page_context);\n        }\n    }\n}<br></code></pre><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>100、get和post请求的区别？&nbsp;</b><br>答：&nbsp;<br>①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；&nbsp;<br>②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用\"?\"连接，而各个变量之间使用\"&amp;\"连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；&nbsp;<br>③get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据，上传文件通常要使用post方式；&nbsp;<br>④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；&nbsp;<br>⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是\"%20\"。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>101、常用的Web服务器有哪些？&nbsp;</b><br>答：Unix和Linux平台下使用最广泛的免费HTTP服务器是Apache服务器，而Windows平台的服务器通常使用IIS作为Web服务器。选择Web服务器应考虑的因素有：性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等。下面是对常见服务器的简介：&nbsp;<br>- IIS：Microsoft的Web服务器产品，全称是Internet Information Services。IIS是允许在公共Intranet或Internet上发布信息的Web服务器。IIS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在IIS的平台上。IIS提供了一个图形界面的管理工具，称为Internet服务管理器，可用于监视配置和控制Internet服务。IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。&nbsp;<br>- Kangle：Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务器软件。此外，Kangle也是一款专为做虚拟主机研发的Web服务器。实现虚拟主机独立进程、独立身份运行。用户之间安全隔离，一个用户出问题不影响其他用户。支持PHP、ASP、ASP.NET、Java、Ruby等多种动态开发语言。&nbsp;<br>- WebSphere：WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IBM电子商务计划的核心部分，它是基于Java的应用环境，用于建立、部署和管理Internet和Intranet Web应用程序，适应各种Web应用程序服务器的需要。&nbsp;<br>- WebLogic：WebLogic Server是一款多功能、基于标准的Web应用服务器，为企业构建企业应用提供了坚实的基础。针对各种应用开发、关键性任务的部署，各种系统和数据库的集成、跨Internet协作等Weblogic都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发等优势，很多公司的企业级应用都选择它来作为开发和部署的环境。WebLogic Server在使应用服务器成为企业应用架构的基础方面一直处于领先地位，为构建集成化的企业级应用提供了稳固的基础。&nbsp;<br>- Apache：目前Apache仍然是世界上用得最多的Web服务器，其市场占有率很长时间都保持在60%以上（目前的市场份额约40%左右）。世界上很多著名的网站都是Apache的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。&nbsp;<br>- Tomcat：Tomcat是一个开放源代码、运行Servlet和JSP的容器。Tomcat实现了Servlet和JSP规范。此外，Tomcat还实现了Apache-Jakarta规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的Web服务器都选择了Tomcat。&nbsp;<br>- Nginx：读作\"engine x\"，是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。 Nginx是由Igor Sysoev为俄罗斯访问量第二的<a href=\"http://www.rambler.ru/\" target=\"_blank\">Rambler</a>站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。在2014年下半年，Nginx的市场份额达到了14%。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>102、JSP和Servlet是什么关系？&nbsp;</b><br>答：其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</p><p style=\"text-align: justify;\">103、讲解JSP中的四种作用域。&nbsp;<br>答：JSP中的四种作用域包括page、request、session和application，具体来说：&nbsp;<br>- page代表与一个页面相关的对象和属性。&nbsp;<br>- request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。&nbsp;<br>- session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。&nbsp;<br>- application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</p><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>104、如何实现JSP或Servlet的单线程模式？&nbsp;</b><br>答：&nbsp;<br>对于JSP页面，可以通过page指令进行设置。</p><pre><code class=\"lang-java\">&lt;%@page isThreadSafe=”false”%&gt;</code></pre><p style=\"text-align: justify;\">对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。</p><blockquote><p style=\"text-align: justify;\">说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>105、实现会话跟踪的技术有哪些？&nbsp;</b><br>答：由于HTTP协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的ID，下一次用户在请求中包含此ID，服务器据此判断到底是哪一个用户。&nbsp;<br>①URL 重写：在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。&nbsp;<br>②设置表单隐藏域：将和会话跟踪相关的字段添加到隐式表单域中，这些信息不会在浏览器中显示但是提交表单时会提交给服务器。&nbsp;<br>这两种方式很难处理跨越多个页面的信息传递，因为如果每次都要修改URL或在页面中添加隐式表单域来存储用户会话相关信息，事情将变得非常麻烦。&nbsp;<br>③cookie：cookie有两种，一种是基于窗口的，浏览器窗口关闭后，cookie就没有了；另一种是将信息存储在一个临时文件中，并设置存在的时间。当用户通过浏览器和服务器建立一次会话后，会话ID就会随响应信息返回存储在基于窗口的cookie中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话ID又会提交给服务器让服务器识别用户身份。会话中可以为用户保存信息。会话对象是在服务器内存中的，而基于窗口的cookie是在客户端内存中的。如果浏览器禁用了cookie，那么就需要通过下面两种方式进行会话跟踪。当然，在使用cookie时要注意几点：首先不要在cookie中存放敏感信息；其次cookie存储的数据量有限（4k），不能将过多的内容存储cookie中；再者浏览器通常只允许一个站点最多存放20个cookie。当然，和用户会话相关的其他信息（除了会话ID）也可以存在cookie方便进行会话跟踪。&nbsp;<br>④HttpSession：在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</p><blockquote><p style=\"text-align: justify;\">**补充：**HTML5中可以使用Web Storage技术通过JavaScript来保存数据，例如可以使用localStorage和sessionStorage来保存用户会话的信息，也能够实现会话跟踪。</p></blockquote><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>106、过滤器有哪些作用和用法？&nbsp;</b><br>答： Java Web开发中的过滤器（filter）是从Servlet 2.3规范开始增加的功能，并在Servlet 2.4规范中得到增强。对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，在过滤器中你可以对响应的内容进行转换，然后再将响应发送到客户端。</p><p style=\"text-align: justify;\">常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。</p><p style=\"text-align: justify;\">和过滤器相关的接口主要有：Filter、FilterConfig和FilterChain。</p><p style=\"text-align: justify;\">编码过滤器的例子：</p><pre><code class=\"lang-java\">import java.io.IOException;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\nimport javax.servlet.annotation.WebInitParam;\n\n@WebFilter(urlPatterns = { \"*\" }, \n        initParams = {@WebInitParam(name=\"encoding\", value=\"utf-8\")})\npublic class CodingFilter implements Filter {\n    private String defaultEncoding = \"utf-8\";\n\n    @Override\n    public void destroy() {\n    }\n\n    @Override\n    public void doFilter(ServletRequest req, ServletResponse resp,\n            FilterChain chain) throws IOException, ServletException {\n        req.setCharacterEncoding(defaultEncoding);\n        resp.setCharacterEncoding(defaultEncoding);\n        chain.doFilter(req, resp);\n    }\n\n    @Override\n    public void init(FilterConfig config) throws ServletException {\n        String encoding = config.getInitParameter(\"encoding\");\n        if (encoding != null) {\n            defaultEncoding = encoding;\n        }\n    }\n}<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">下载计数过滤器的例子：</span><br></p><pre><code class=\"lang-java\">import java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\nimport javax.servlet.http.HttpServletRequest;\n\n@WebFilter(urlPatterns = {\"/*\"})\npublic class DownloadCounterFilter implements Filter {\n\n    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n    private Properties downloadLog;\n    private File logFile;\n\n    @Override\n    public void destroy() {\n        executorService.shutdown();\n    }\n\n    @Override\n    public void doFilter(ServletRequest req, ServletResponse resp,\n            FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest) req;\n        final String uri = request.getRequestURI();\n        executorService.execute(new Runnable() {\n\n            @Override\n            public void run() {\n                String value = downloadLog.getProperty(uri);\n                if(value == null) {\n                    downloadLog.setProperty(uri, \"1\");\n                }\n                else {\n                    int count = Integer.parseInt(value);\n                    downloadLog.setProperty(uri, String.valueOf(++count));\n                }\n                try {\n                    downloadLog.store(new FileWriter(logFile), \"\");\n                } \n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        chain.doFilter(req, resp);\n    }\n\n    @Override\n    public void init(FilterConfig config) throws ServletException {\n        String appPath = config.getServletContext().getRealPath(\"/\");\n        logFile = new File(appPath, \"downloadLog.txt\");\n        if(!logFile.exists()) {\n            try {\n                logFile.createNewFile();\n            } \n            catch(IOException e) {\n                e.printStackTrace();\n            }\n        }\n        downloadLog = new Properties();\n        try {\n            downloadLog.load(new FileReader(logFile));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n}<br></code></pre><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\"></span></p><blockquote><p style=\"text-align: justify;\">说明：这里使用了Servlet 3规范中的注解来部署过滤器，当然也可以在web.xml中使用&lt;filter&gt;和&lt;filter-mapping&gt;标签部署过滤器，如108题中所示。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>107、监听器有哪些作用和用法？&nbsp;</b><br>答：Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：&nbsp;<br>①ServletContextListener：对Servlet上下文的创建和销毁进行监听。&nbsp;<br>②ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。&nbsp;<br>③HttpSessionListener：对Session的创建和销毁进行监听。</p><blockquote><p style=\"text-align: justify;\">补充：session的销毁有两种情况：1). session超时（可以在web.xml中通过&lt;session-config&gt;/&lt;session-timeout&gt;标签配置超时时间）；2). 通过调用session对象的invalidate()方法使session失效。</p></blockquote><p style=\"text-align: justify;\">④HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。&nbsp;<br>⑤ServletRequestListener：对请求对象的初始化和销毁进行监听。&nbsp;<br>⑥ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。</p><p style=\"text-align: justify;\">下面是一个统计网站最多在线人数监听器的例子。</p><pre><code class=\"lang-java\">import javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\nimport javax.servlet.annotation.WebListener;\n\n/**\n 上下文监听器，在服务器启动时初始化onLineCount和maxOnLineCount两个变量\n 并将其置于服务器上下文（ServletContext）中，其初始值都是0\n*/\n@WebListener\npublic class InitListener implements ServletContextListener {\n\n    @Override\n    public void contextDestroyed(ServletContextEvent evt) {\n    }\n\n    @Override\n    public void contextInitialized(ServletContextEvent evt) {\n        evt.getServletContext().setAttribute(\"onLineCount\", 0);\n        evt.getServletContext().setAttribute(\"maxOnLineCount\", 0);\n    }\n\n}<br></code></pre><pre><code class=\"lang-java\">import java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.annotation.WebListener;\nimport javax.servlet.http.HttpSessionEvent;\nimport javax.servlet.http.HttpSessionListener;\n\n/**\n 会话监听器，在用户会话创建和销毁的时候根据情况\n 修改onLineCount和maxOnLineCount的值\n*/\n@WebListener\npublic class MaxCountListener implements HttpSessionListener {\n\n    @Override\n    public void sessionCreated(HttpSessionEvent event) {\n        ServletContext ctx = event.getSession().getServletContext();\n        int count = Integer.parseInt(ctx.getAttribute(\"onLineCount\").toString());\n        count++;\n        ctx.setAttribute(\"onLineCount\", count);\n        int maxOnLineCount = Integer.parseInt(ctx.getAttribute(\"maxOnLineCount\").toString());\n        if (count &gt; maxOnLineCount) {\n            ctx.setAttribute(\"maxOnLineCount\", count);\n            DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            ctx.setAttribute(\"date\", df.format(new Date()));\n        }\n    }\n\n    @Override\n    public void sessionDestroyed(HttpSessionEvent event) {\n        ServletContext app = event.getSession().getServletContext();\n        int count = Integer.parseInt(app.getAttribute(\"onLineCount\").toString());\n        count--;\n        app.setAttribute(\"onLineCount\", count);\n    }\n}<br></code></pre><blockquote><p style=\"text-align: justify;\">说明：这里使用了Servlet 3规范中的@WebListener注解配置监听器，当然你可以在web.xml文件中用&lt;listener&gt;标签配置监听器，如108题中所示。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>108、web.xml文件中可以配置哪些内容？&nbsp;</b><br>答：web.xml用于配置Web应用的相关信息，如：监听器（listener）、过滤器（filter）、 Servlet、相关参数、会话超时时间、安全验证方式、错误页面等，下面是一些开发中常见的配置：</p><p style=\"text-align: justify;\">①配置Spring上下文加载监听器加载Spring配置文件并创建IoC容器：</p><pre><code class=\"lang-java\"> &lt;context-param&gt;\n     &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;\n  &lt;/context-param&gt;\n\n  &lt;listener&gt;\n     &lt;listener-class&gt;\n       org.springframework.web.context.ContextLoaderListener\n     &lt;/listener-class&gt;\n  &lt;/listener&gt;<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">②配置Spring的OpenSessionInView过滤器来解决延迟加载和Hibernate会话关闭的矛盾：</span><br></p><pre><code class=\"lang-java\">&lt;filter&gt;\n      &lt;filter-name&gt;openSessionInView&lt;/filter-name&gt;\n      &lt;filter-class&gt;\n         org.springframework.orm.hibernate3.support.OpenSessionInViewFilter\n      &lt;/filter-class&gt;\n  &lt;/filter&gt;\n\n  &lt;filter-mapping&gt;\n      &lt;filter-name&gt;openSessionInView&lt;/filter-name&gt;\n      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n  &lt;/filter-mapping&gt;<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">③配置会话超时时间为10分钟：</span><br></p><pre><code class=\"lang-java\">  &lt;session-config&gt;\n      &lt;session-timeout&gt;10&lt;/session-timeout&gt;\n  &lt;/session-config&gt;<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">④配置404和Exception的错误页面：</span><br></p><pre><code class=\"lang-java\"> &lt;error-page&gt;\n      &lt;error-code&gt;404&lt;/error-code&gt;\n      &lt;location&gt;/error.jsp&lt;/location&gt;\n  &lt;/error-page&gt;\n\n  &lt;error-page&gt;\n      &lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt;\n      &lt;location&gt;/error.jsp&lt;/location&gt;\n  &lt;/error-page&gt;<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">⑤配置安全认证方式：</span><br></p><pre><code class=\"lang-java\">&lt;security-constraint&gt;\n      &lt;web-resource-collection&gt;\n          &lt;web-resource-name&gt;ProtectedArea&lt;/web-resource-name&gt;\n          &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;\n          &lt;http-method&gt;GET&lt;/http-method&gt;\n          &lt;http-method&gt;POST&lt;/http-method&gt;\n      &lt;/web-resource-collection&gt;\n      &lt;auth-constraint&gt;\n          &lt;role-name&gt;admin&lt;/role-name&gt;\n      &lt;/auth-constraint&gt;\n  &lt;/security-constraint&gt;\n\n  &lt;login-config&gt;\n      &lt;auth-method&gt;BASIC&lt;/auth-method&gt;\n  &lt;/login-config&gt;\n\n  &lt;security-role&gt;\n      &lt;role-name&gt;admin&lt;/role-name&gt;\n  &lt;/security-role&gt;<br></code></pre><blockquote><p style=\"text-align: justify;\">说明：对Servlet（小服务）、Listener（监听器）和Filter（过滤器）等Web组件的配置，Servlet 3规范提供了基于注解的配置方式，可以分别使用@WebServlet、@WebListener、@WebFilter注解进行配置。&nbsp;<br></p><hr><br>补充：如果Web提供了有价值的商业信息或者是敏感数据，那么站点的安全性就是必须考虑的问题。安全认证是实现安全性的重要手段，认证就是要解决“Are you who you say you are?”的问题。认证的方式非常多，简单说来可以分为三类：&nbsp;<br>A. What you know? — 口令&nbsp;<br>B. What you have? — 数字证书（U盾、密保卡）&nbsp;<br>C. Who you are? — 指纹识别、虹膜识别&nbsp;<br>在Tomcat中可以通过建立安全套接字层（Secure Socket Layer, SSL）以及通过基本验证或表单验证来实现对安全性的支持。</blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>109、你的项目中使用过哪些JSTL标签？&nbsp;</b><br>答：项目中主要使用了JSTL的核心标签库，包括&lt;c:if&gt;、&lt;c:choose&gt;、&lt;c: when&gt;、&lt;c: otherwise&gt;、&lt;c:forEach&gt;等，主要用于构造循环和分支结构以控制显示逻辑。</p><blockquote><p style=\"text-align: justify;\">说明：虽然JSTL标签库提供了core、sql、fmt、xml等标签库，但是实际开发中建议只使用核心标签库（core），而且最好只使用分支和循环标签并辅以表达式语言（EL），这样才能真正做到数据显示和业务逻辑的分离，这才是最佳实践。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>110、使用标签库有什么好处？如何自定义JSP标签？&nbsp;</b><br>答：使用标签库的好处包括以下几个方面：&nbsp;<br>- 分离JSP页面的内容和逻辑，简化了Web开发；&nbsp;<br>- 开发者可以创建自定义标签来封装业务逻辑和显示逻辑；&nbsp;<br>- 标签具有很好的可移植性、可维护性和可重用性；&nbsp;<br>- 避免了对Scriptlet（小脚本）的使用（很多公司的项目开发都不允许在JSP中书写小脚本）</p><p style=\"text-align: justify;\">自定义JSP标签包括以下几个步骤：&nbsp;<br>- 编写一个Java类实现实现Tag/BodyTag/IterationTag接口（开发中通常不直接实现这些接口而是继承TagSupport/BodyTagSupport/SimpleTagSupport类，这是对缺省适配模式的应用），重写doStartTag()、doEndTag()等方法，定义标签要完成的功能&nbsp;<br>- 编写扩展名为tld的标签描述文件对自定义标签进行部署，tld文件通常放在WEB-INF文件夹下或其子目录中&nbsp;<br>- 在JSP页面中使用taglib指令引用该标签库</p><p style=\"text-align: justify;\">下面是一个自定义标签库的例子。</p><p style=\"text-align: justify;\">步骤1 - 标签类源代码TimeTag.java：</p><pre><code class=\"lang-java\">package com.jackfrued.tags;\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.JspWriter;\nimport javax.servlet.jsp.tagext.TagSupport;\n\npublic class TimeTag extends TagSupport {\n    private static final long serialVersionUID = 1L;\n\n    private String format = \"yyyy-MM-dd hh:mm:ss\";\n    private String foreColor = \"black\";\n    private String backColor = \"white\";\n\n    public int doStartTag() throws JspException {\n         SimpleDateFormat sdf = new SimpleDateFormat(format);\n         JspWriter writer = pageContext.getOut();\n         StringBuilder sb = new StringBuilder();\n         sb.append(String.format(\"&lt;span style=\'color:%s;background-color:%s\'&gt;%s&lt;/span&gt;\",\n             foreColor, backColor, sdf.format(new Date())));\n         try {\n           writer.print(sb.toString());\n         } catch(IOException e) {\n           e.printStackTrace();\n         }\n         return SKIP_BODY;\n      }\n\n    public void setFormat(String format) {\n        this.format = format;\n    }\n\n    public void setForeColor(String foreColor) {\n        this.foreColor = foreColor;\n    }\n\n    public void setBackColor(String backColor) {\n        this.backColor = backColor;\n    }\n}<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">步骤2 - 编写标签库描述文件my.tld：</span><br></p><pre><code class=\"lang-java\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee \n    http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\"\n    version=\"2.0\"&gt;\n\n    &lt;description&gt;定义标签库&lt;/description&gt;\n    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;\n    &lt;short-name&gt;MyTag&lt;/short-name&gt;\n    &lt;tag&gt;\n        &lt;name&gt;time&lt;/name&gt;\n        &lt;tag-class&gt;com.jackfrued.tags.TimeTag&lt;/tag-class&gt;\n        &lt;body-content&gt;empty&lt;/body-content&gt;\n        &lt;attribute&gt;\n            &lt;name&gt;format&lt;/name&gt;\n            &lt;required&gt;false&lt;/required&gt;\n        &lt;/attribute&gt;\n        &lt;attribute&gt;\n            &lt;name&gt;foreColor&lt;/name&gt;\n        &lt;/attribute&gt;\n        &lt;attribute&gt;\n            &lt;name&gt;backColor&lt;/name&gt;\n        &lt;/attribute&gt;\n    &lt;/tag&gt;\n&lt;/taglib&gt;<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">步骤3 - 在JSP页面中使用自定义标签：</span><br></p><pre><code class=\"lang-java\">&lt;%@ page pageEncoding=\"UTF-8\"%&gt;\n&lt;%@ taglib prefix=\"my\" uri=\"/WEB-INF/tld/my.tld\" %&gt;\n&lt;%\nString path = request.getContextPath();\nString basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";\n%&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;base href=\"&lt;%=basePath%&gt;\"&gt;\n    &lt;title&gt;首页&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        * { font-family: \"Arial\"; font-size:72px; }\n    &lt;/style&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;my:time format=\"yyyy-MM-dd\" backColor=\"blue\" foreColor=\"yellow\"/&gt;\n  &lt;/body&gt;\n&lt;/html&gt;<br></code></pre><blockquote><p style=\"text-align: justify;\">提示：如果要将自定义的标签库发布成JAR文件，需要将标签库描述文件（tld文件）放在JAR文件的META-INF目录下，可以JDK中的jar工具完成JAR文件的生成，如果不清楚如何操作，可以请教<a href=\"http://www.baigoogledu.com/\" target=\"_blank\">谷老师和百老师</a>。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>111、说一下表达式语言（EL）的隐式对象及其作用。&nbsp;</b><br>答：EL的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）、paramValues、header（访问请求头）、headerValues、cookie（访问cookie）、applicationScope（访问application作用域）、sessionScope（访问session作用域）、requestScope（访问request作用域）、pageScope（访问page作用域）。</p><p style=\"text-align: justify;\">用法如下所示：</p><pre><code class=\"lang-java\">${pageContext.request.method}\n${pageContext[\"request\"][\"method\"]}\n${pageContext.request[\"method\"]}\n${pageContext[\"request\"].method}\n${initParam.defaultEncoding}\n${header[\"accept-language\"]}\n${headerValues[\"accept-language\"][0]}\n${cookie.jsessionid.value}\n${sessionScope.loginUser.username}<br></code></pre><blockquote><p style=\"text-align: justify;\">补充：表达式语言的.和[]运算作用是一致的，唯一的差别在于如果访问的属性名不符合Java标识符命名规则，例如上面的accept-language就不是一个有效的Java标识符，那么这时候就只能用[]运算符而不能使用.运算符获取它的值</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>112、表达式语言（EL）支持哪些运算符？&nbsp;</b><br>答：除了.和[]运算符，EL还提供了：&nbsp;<br>- 算术运算符：+、-、*、/或div、%或mod&nbsp;<br>- 关系运算符：==或eq、!=或ne、&gt;或gt、&gt;=或ge、&lt;或lt、&lt;=或le&nbsp;<br>- 逻辑运算符：&amp;&amp;或and、||或or、!或not&nbsp;<br>- 条件运算符：${statement? A : B}（跟Java的条件运算符类似）&nbsp;<br>- empty运算符：检查一个值是否为null或者空（数组长度为0或集合中没有元素也返回true）</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>113、Java Web开发的Model 1和Model 2分别指的是什么？&nbsp;</b><br>答：Model 1是以页面为中心的Java Web开发，使用JSP+JavaBean技术将页面显示逻辑和业务逻辑处理分开，JSP实现页面显示，JavaBean对象用来保存数据和实现业务逻辑。Model 2是基于MVC（模型-视图-控制器，Model-View-Controller）架构模式的开发模型，实现了模型和视图的彻底分离，利于团队开发和代码复用，如下图所示。</p><p style=\"text-align: justify;\"><img src=\"https://img-blog.csdn.net/20150409102658882\" alt=\"这里写图片描述\"></p><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>114、Servlet 3中的异步处理指的是什么？&nbsp;</b><br>答：在Servlet 3中引入了一项新的技术可以让Servlet异步处理请求。有人可能会质疑，既然都有多线程了，还需要异步处理请求吗？答案是肯定的，因为如果一个任务处理时间相当长，那么Servlet或Filter会一直占用着请求处理线程直到任务结束，随着并发用户的增加，容器将会遭遇线程超出的风险，这这种情况下很多的请求将会被堆积起来而后续的请求可能会遭遇拒绝服务，直到有资源可以处理请求为止。异步特性可以帮助应用节省容器中的线程，特别适合执行时间长而且用户需要得到结果的任务，如果用户不需要得到结果则直接将一个Runnable对象交给Executor并立即返回即可。（如果不清楚多线程和线程池的相关内容，请查看<a href=\"http://blog.csdn.net/jackfrued/article/details/44921941\" target=\"_blank\">《Java面试题全集（上）》</a>关于多线程和线程池的部分或阅读我的另一篇文章<a href=\"http://blog.csdn.net/jackfrued/article/details/44499227\" target=\"_blank\">《关于Java并发编程的总结和思考》</a>）</p><blockquote><p style=\"text-align: justify;\">补充：多线程在Java诞生初期无疑是一个亮点，而Servlet单实例多线程的工作方式也曾为其赢得美名，然而技术的发展往往会颠覆我们很多的认知，就如同当年爱因斯坦的相对论颠覆了牛顿的经典力学一般。事实上，异步处理绝不是Serlvet 3首创，如果你了解Node.js的话，对Servlet 3的这个重要改进就不以为奇了。</p></blockquote><p style=\"text-align: justify;\">下面是一个支持异步处理请求的Servlet的例子。</p><pre><code class=\"lang-java\">import java.io.IOException;\nimport javax.servlet.AsyncContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(urlPatterns = {\"/async\"}, asyncSupported = true)\npublic class AsyncServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void doGet(HttpServletRequest req, HttpServletResponse resp) \n            throws ServletException, IOException {\n        // 开启Tomcat异步Servlet支持\n        req.setAttribute(\"org.apache.catalina.ASYNC_SUPPORTED\", true);\n\n        final AsyncContext ctx = req.startAsync();  // 启动异步处理的上下文\n        // ctx.setTimeout(30000);\n        ctx.start(new Runnable() {\n\n            @Override\n            public void run() {\n                // 在此处添加异步处理的代码\n\n                ctx.complete();\n            }\n        });\n    }\n}<br></code></pre><p><br></p><p><b>115、如何在基于Java的Web项目中实现文件上传和下载？&nbsp;</b><br>答：在Sevlet 3 以前，Servlet API中没有支持上传功能的API，因此要实现上传功能需要引入第三方工具从POST请求中获得上传的附件或者通过自行处理输入流来获得上传的文件，我们推荐使用Apache的commons-fileupload。&nbsp;<br>从Servlet 3开始，文件上传变得无比简单，相信看看下面的例子一切都清楚了。<br></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">上传页面index.jsp：</span><br></p><pre><code class=\"lang-java\">&lt;%@ page pageEncoding=\"utf-8\"%&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;\n&lt;title&gt;Photo Upload&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Select your photo and upload&lt;/h1&gt;\n&lt;hr/&gt;\n&lt;div style=\"color:red;font-size:14px;\"&gt;${hint}&lt;/div&gt;\n&lt;form action=\"UploadServlet\" method=\"post\" enctype=\"multipart/form-data\"&gt;\n    Photo file: &lt;input type=\"file\" name=\"photo\" /&gt;\n    &lt;input type=\"submit\" value=\"Upload\" /&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">支持上传的Servlet：</span><br></p><pre><code class=\"lang-java\">package com.jackfrued.servlet;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.MultipartConfig;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Part;\n\n@WebServlet(\"/UploadServlet\")\n@MultipartConfig\npublic class UploadServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doPost(HttpServletRequest request,\n            HttpServletResponse response) throws ServletException, IOException {\n        // 可以用request.getPart()方法获得名为photo的上传附件\n        // 也可以用request.getParts()获得所有上传附件（多文件上传）\n        // 然后通过循环分别处理每一个上传的文件\n        Part part = request.getPart(\"photo\");\n        if (part != null &amp;&amp; part.getSubmittedFileName().length() &gt; 0) {\n            // 用ServletContext对象的getRealPath()方法获得上传文件夹的绝对路径\n            String savePath = request.getServletContext().getRealPath(\"/upload\");\n            // Servlet 3.1规范中可以用Part对象的getSubmittedFileName()方法获得上传的文件名\n            // 更好的做法是为上传的文件进行重命名（避免同名文件的相互覆盖）\n            part.write(savePath + \"/\" + part.getSubmittedFileName());\n            request.setAttribute(\"hint\", \"Upload Successfully!\");\n        } else {\n            request.setAttribute(\"hint\", \"Upload failed!\");\n        }\n        // 跳转回到上传页面\n        request.getRequestDispatcher(\"index.jsp\").forward(request, response);\n    }\n\n}<br></code></pre><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>116、服务器收到用户提交的表单数据，到底是调用Servlet的doGet()还是doPost()方法？&nbsp;</b><br>答：HTML的&lt;form&gt;元素有一个method属性，用来指定提交表单的方式，其值可以是get或post。我们自定义的Servlet一般情况下会重写doGet()或doPost()两个方法之一或全部，如果是GET请求就调用doGet()方法，如果是POST请求就调用doPost()方法，那为什么为什么这样呢？我们自定义的Servlet通常继承自HttpServlet，HttpServlet继承自GenericServlet并重写了其中的service()方法，这个方法是Servlet接口中定义的。HttpServlet重写的service()方法会先获取用户请求的方法，然后根据请求方法调用doGet()、doPost()、doPut()、doDelete()等方法，如果在自定义Servlet中重写了这些方法，那么显然会调用重写过的（自定义的）方法，这显然是对模板方法模式的应用（如果不理解，请参考阎宏博士的《Java与模式》一书的第37章）。当然，自定义Servlet中也可以直接重写service()方法，那么不管是哪种方式的请求，都可以通过自己的代码进行处理，这对于不区分请求方法的场景比较合适。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>117、JSP中的静态包含和动态包含有什么区别？&nbsp;</b><br>答：静态包含是通过JSP的include指令包含页面，动态包含是通过JSP标准动作&lt;jsp:forward&gt;包含页面。静态包含是编译时包含，如果包含的页面不存在则会产生编译错误，而且两个页面的\"contentType\"属性应保持一致，因为两个页面会合二为一，只产生一个class文件，因此被包含页面发生的变动再包含它的页面更新前不会得到更新。动态包含是运行时包含，可以向被包含的页面传递参数，包含页面和被包含页面是独立的，会编译出两个class文件，如果被包含的页面不存在，不会产生编译错误，也不影响页面其他部分的执行。代码如下所示：</p><pre><code class=\"lang-java\">&lt;%-- 静态包含 --%&gt;\n&lt;%@ include file=\"...\" %&gt;\n\n&lt;%-- 动态包含 --%&gt;\n&lt;jsp:include page=\"...\"&gt;\n    &lt;jsp:param name=\"...\" value=\"...\" /&gt;\n&lt;/jsp:include&gt;<br></code></pre><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>118、Servlet中如何获取用户提交的查询参数或表单数据？</b>&nbsp;<br>答：可以通过请求对象（HttpServletRequest）的getParameter()方法通过参数名获得参数值。如果有包含多个值的参数（例如复选框），可以通过请求对象的getParameterValues()方法获得。当然也可以通过请求对象的getParameterMap()获得一个参数名和参数值的映射（Map）。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>119、Servlet中如何获取用户配置的初始化参数以及服务器上下文参数？&nbsp;</b><br>答：可以通过重写Servlet接口的init(ServletConfig)方法并通过ServletConfig对象的getInitParameter()方法来获取Servlet的初始化参数。可以通过ServletConfig对象的getServletContext()方法获取ServletContext对象，并通过该对象的getInitParameter()方法来获取服务器上下文参数。当然，ServletContext对象也在处理用户请求的方法（如doGet()方法）中通过请求对象的getServletContext()方法来获得。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>120、如何设置请求的编码以及响应内容的类型？&nbsp;</b><br>答：通过请求对象（ServletRequest）的setCharacterEncoding(String)方法可以设置请求的编码，其实要彻底解决乱码问题就应该让页面、服务器、请求和响应、Java程序都使用统一的编码，最好的选择当然是UTF-8；通过响应对象（ServletResponse）的setContentType(String)方法可以设置响应内容的类型，当然也可以通过HttpServletResponsed对象的setHeader(String, String)方法来设置。</p><blockquote><p style=\"text-align: justify;\">说明：现在如果还有公司在面试的时候问JSP的声明标记、表达式标记、小脚本标记这些内容的话，这样的公司也不用去了，其实JSP内置对象、JSP指令这些东西基本上都可以忘却了，关于Java Web开发的相关知识，可以看一下我的<a href=\"http://blog.csdn.net/jackfrued/article/details/42617675\" target=\"_blank\">《Servlet&amp;JSP思维导图》</a>，上面有完整的知识点的罗列。想了解如何实现自定义MVC框架的，可以看一下我的<a href=\"http://blog.csdn.net/jackfrued/article/details/42774459\" target=\"_blank\">《Java Web自定义MVC框架详解》</a>。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>121、解释一下网络应用的模式及其特点。&nbsp;</b><br>答：典型的网络应用模式大致有三类：B/S、C/S、P2P。其中B代表浏览器（Browser）、C代表客户端（Client）、S代表服务器（Server），P2P是对等模式，不区分客户端和服务器。B/S应用模式中可以视为特殊的C/S应用模式，只是将C/S应用模式中的特殊的客户端换成了浏览器，因为几乎所有的系统上都有浏览器，那么只要打开浏览器就可以使用应用，没有安装、配置、升级客户端所带来的各种开销。P2P应用模式中，成千上万台彼此连接的计算机都处于对等的地位，整个网络一般来说不依赖专用的集中服务器。网络中的每一台计算机既能充当网络服务的请求者，又对其它计算机的请求作出响应，提供资源和服务。通常这些资源和服务包括：信息的共享和交换、计算资源（如CPU的共享）、存储共享（如缓存和磁盘空间的使用）等，这种应用模式最大的阻力安全性、版本等问题，目前有很多应用都混合使用了多种应用模型，最常见的网络视频应用，它几乎把三种模式都用上了。</p><blockquote><p style=\"text-align: justify;\">补充：此题要跟\"电子商务模式\"区分开，因为有很多人被问到这个问题的时候马上想到的是B2B（如阿里巴巴）、B2C（如当当、亚马逊、京东）、C2C（如淘宝、拍拍）、C2B（如威客）、O2O（如美团、饿了么）。对于这类问题，可以去<a href=\"http://www.baidu.com/\" target=\"_blank\">百度</a>上面科普一下。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>122、什么是Web Service（Web服务）？</b>&nbsp;<br>答：从表面上看，Web Service就是一个应用程序，它向外界暴露出一个能够通过Web进行调用的API。这就是说，你能够用编程的方法透明的调用这个应用程序，不需要了解它的任何细节，跟你使用的编程语言也没有关系。例如可以创建一个提供天气预报的Web Service，那么无论你用哪种编程语言开发的应用都可以通过调用它的API并传入城市信息来获得该城市的天气预报。之所以称之为Web Service，是因为它基于HTTP协议传输数据，这使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。</p><blockquote><p style=\"text-align: justify;\">补充：这里必须要提及的一个概念是SOA（Service-Oriented Architecture，面向服务的架构），SOA是一种思想，它将应用程序的不同功能单元通过中立的契约联系起来，独立于硬件平台、操作系统和编程语言，使得各种形式的功能单元能够更好的集成。显然，Web Service是SOA的一种较好的解决方案，它更多的是一种标准，而不是一种具体的技术。</p></blockquote><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>123、概念解释：SOAP、WSDL、UDDI。&nbsp;</b><br></p><p style=\"text-align: justify;\">答：&nbsp;<br>- SOAP：简单对象访问协议（<u>S</u>imple&nbsp;<u>O</u>bject&nbsp;<u>A</u>ccess&nbsp;<u>P</u>rotocol），是Web Service中交换数据的一种协议规范。&nbsp;<br>- WSDL：Web服务描述语言（Web Service Description Language），它描述了Web服务的公共接口。这是一个基于XML的关于如何与Web服务通讯和使用的服务描述；也就是描述与目录中列出的Web服务进行交互时需要绑定的协议和信息格式。通常采用抽象语言描述该服务支持的操作和信息，使用的时候再将实际的网络协议和信息格式绑定给该服务。&nbsp;<br>- UDDI：统一描述、发现和集成（Universal Description, Discovery and Integration），它是一个基于XML的跨平台的描述规范，可以使世界范围内的企业在互联网上发布自己所提供的服务。简单的说，UDDI是访问各种WSDL的一个门面（可以参考设计模式中的门面模式）。</p><blockquote><p style=\"text-align: justify;\">提示：关于Web Service的相关概念和知识可以在<a href=\"http://www.w3cschool.cc/webservices/webservices-tutorial.html\" target=\"_blank\">W3CSchool</a>上找到相关的资料。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>124、Java规范中和Web Service相关的规范有哪些？&nbsp;</b><br>答：Java规范中和Web Service相关的有三个：&nbsp;<br>- JAX-WS(JSR 224)：这个规范是早期的基于SOAP的Web Service规范JAX-RPC的替代版本，它并不提供向下兼容性，因为RPC样式的WSDL以及相关的API已经在Java EE5中被移除了。WS-MetaData是JAX-WS的依赖规范，提供了基于注解配置Web Service和SOAP消息的相关API。&nbsp;<br>- JAXM(JSR 67)：定义了发送和接收消息所需的API,相当于Web Service的服务器端。&nbsp;<br>- JAX-RS(JSR 311 &amp; JSR 339 &amp; JSR 370)：是Java针对REST（Representation State Transfer）架构风格制定的一套Web Service规范。REST是一种软件架构模式，是一种风格，它不像SOAP那样本身承载着一种消息协议， (两种风格的Web Service均采用了HTTP做传输协议，因为HTTP协议能穿越防火墙，Java的远程方法调用（RMI）等是重量级协议，通常不能穿越防火墙），因此可以将REST视为基于HTTP协议的软件架构。REST中最重要的两个概念是资源定位和资源操作，而HTTP协议恰好完整的提供了这两个点。HTTP协议中的URI可以完成资源定位，而GET、POST、OPTION、DELETE方法可以完成资源操作。因此REST完全依赖HTTP协议就可以完成Web Service，而不像SOAP协议那样只利用了HTTP的传输特性，定位和操作都是由SOAP协议自身完成的，也正是由于SOAP消息的存在使得基于SOAP的Web Service显得笨重而逐渐被淘汰。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>125、介绍一下你了解的Java领域的Web Service框架。&nbsp;</b><br>答：Java领域的Web Service框架很多，包括<a href=\"https://axis.apache.org/axis2/java/core/\" target=\"_blank\">Axis2</a>（Axis的升级版本）、<a href=\"https://jersey.java.net/\" target=\"_blank\">Jersey</a>（RESTful的Web Service框架）、<a href=\"http://cxf.apache.org/\" target=\"_blank\">CXF</a>（XFire的延续版本）、<a href=\"http://hessian.caucho.com/\" target=\"_blank\">Hessian</a>、<a href=\"https://github.com/ebay\" target=\"_blank\">Turmeric</a>、<a href=\"http://www.redhat.com/en/technologies/jboss-middleware\" target=\"_blank\">JBoss SOA</a>等，其中绝大多数都是开源框架。</p><blockquote><p style=\"text-align: justify;\">提示：面试被问到这类问题的时候一定选择自己用过的最熟悉的作答，如果之前没有了解过就应该在面试前花一些时间了解其中的两个，并比较其优缺点，这样才能在面试时给出一个漂亮的答案。</p></blockquote><p><br></p><p>原文地址：<a href=\"https://blog.csdn.net/jackfrued/article/details/44931137\" target=\"_blank\">https://blog.csdn.net/jackfrued/article/details/44931137</a></p>', '2018-06-18 11:42:17', '/articles/10008', '0', '0', 'publish', '这部分主要是与Java Web和Web Service相关的面试题。96、阐述Servlet和CGI的区别? 答：Servlet与C', 'Java,JavaWeb,面试', 'Java面试题全集（中）—— Java Web 篇', '2018-09-12 11:26:07', '13', '0', '10001', '1'), ('10009', '0', '2', '<p style=\"text-align: justify;\">  这部分主要是开源Java EE框架方面的内容，包括Hibernate、MyBatis、Spring、Spring MVC等，由于Struts 2已经是明日黄花，在这里就不讨论Struts 2的面试题，如果需要了解相关内容，可以参考我的另一篇文章<a href=\"http://blog.csdn.net/jackfrued/article/details/17596171\" target=\"_blank\">《Java面试题集（86-115）》</a>。此外，这篇文章还对企业应用架构、大型网站架构和应用服务器优化等内容进行了简单的探讨，这些内容相信对面试会很有帮助。</p><p style=\"text-align: justify;\"><b>126、什么是ORM？&nbsp;</b><br>答：对象关系映射（Object-Relational Mapping，简称ORM）是一种为了<span style=\"color: rgb(227, 55, 55);\">解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术</span>；简单的说，ORM是通过使用描述对象和数据库之间映射的元数据（在Java中可以用XML或者是注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>127、持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？</b>&nbsp;<br>答：所谓\"持久\"就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是<span style=\"color: rgb(227, 55, 55);\">将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中</span>。持久层就是系统中专注于实现数据持久化的相对独立的层面。</p><p style=\"text-align: justify;\">持久层设计的目标包括：&nbsp;<br>- 数据存储逻辑的分离，提供抽象化的数据访问接口。&nbsp;<br>- 数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。&nbsp;<br>- 资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。&nbsp;<br>- 数据抽象，提供更面向对象的数据操作。</p><p style=\"text-align: justify;\">持久层框架有：&nbsp;<br>-&nbsp;<a href=\"http://hibernate.org/\" target=\"_blank\">Hibernate</a>&nbsp;<br>-&nbsp;<a href=\"http://blog.mybatis.org/\" target=\"_blank\">MyBatis</a>&nbsp;<br>-&nbsp;<a href=\"http://www.oracle.com/technetwork/cn/middleware/toplink/overview/index.html\" target=\"_blank\">TopLink</a>&nbsp;<br>-&nbsp;<a href=\"https://code.google.com/p/guzz/\" target=\"_blank\">Guzz</a>&nbsp;<br>-&nbsp;<a href=\"http://www.jooq.org/\" target=\"_blank\">jOOQ</a>&nbsp;<br>-&nbsp;<a href=\"http://projects.spring.io/spring-data/\" target=\"_blank\">Spring Data</a>&nbsp;<br>-&nbsp;<a href=\"https://code.google.com/p/activejdbc/\" target=\"_blank\">ActiveJDBC</a></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>128、Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？&nbsp;</b><br>答：SessionFactory对应Hibernate的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。SessionFactory一般只会在启动的时候构建。对于应用程序，最好将SessionFactory通过单例模式进行封装以便于访问。Session是一个轻量级非线程安全的对象（线程间不能共享session），它表示与数据库进行交互的一个工作单元。Session是由SessionFactory创建的，在任务完成之后它会被关闭。Session是持久层服务对外提供的主要接口。Session会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的session，可以使用ThreadLocal将session和当前线程绑定在一起，这样可以让同一个线程获得的总是同一个session。Hibernate 3中SessionFactory的getCurrentSession()方法就可以做到。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>129、Hibernate中Session的load和get方法的区别是什么？</b>&nbsp;<br>答：主要有以下三项区别：&nbsp;<br>① 如果没有找到符合条件的记录，get方法返回null，load方法抛出异常。&nbsp;<br>② get方法直接返回实体类对象，load方法返回实体类对象的代理。&nbsp;<br>③ 在Hibernate 3之前，get方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，直接发出SQL语句完成数据读取；load方法则可以从二级缓存中获取数据；从Hibernate 3开始，get方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。</p><blockquote><p style=\"text-align: justify;\">说明：对于load()方法Hibernate认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加载，如果没有数据就抛出异常，而通过get()方法获取的数据可以不存在。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>130、Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？</b><br>答：<span style=\"color: rgb(227, 55, 55);\">Hibernate的对象有三种状态：瞬时态（transient）、持久态（persistent）和游离态（detached）</span>，如第135题中的图所示。瞬时态的实例可以通过调用save()、persist()或者saveOrUpdate()方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock()或者replicate()变成持久态。save()和persist()将会引发SQL的INSERT语句，而update()或merge()会引发UPDATE语句。save()和update()的区别在于一个是将瞬时态对象变成持久态，一个是将游离态对象变为持久态。merge()方法可以完成save()和update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。对于persist()方法，按照官方文档的说明：① persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时间；② persist()方法保证当它在一个事务外部被调用的时候并不触发一个INSERT语句，当需要封装一个长会话流程的时候，persist()方法是很有必要的；③ save()方法不保证第②条，它要返回标识符，所以它会立即执行INSERT语句，不管是在事务内部还是外部。至于lock()方法和update()方法的区别，update()方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>131、阐述Session加载实体对象的过程。</b>&nbsp;<br>答：Session加载实体对象的步骤是：&nbsp;<br>① Session在调用数据库查询功能之前，首先会在一级缓存中通过实体类型和主键进行查找，如果一级缓存查找命中且数据状态合法，则直接返回；&nbsp;<br>② 如果一级缓存没有命中，接下来Session会在当前NonExists记录（相当于一个查询黑名单，如果出现重复的无效查询可以迅速做出判断，从而提升性能）中进行查找，如果NonExists中存在同样的查询条件，则返回null；&nbsp;<br>③ 如果一级缓存查询失败则查询二级缓存，如果二级缓存命中则直接返回；&nbsp;<br>④ 如果之前的查询都未命中，则发出SQL语句，如果查询未发现对应记录则将此次查询添加到Session的NonExists中加以记录，并返回null；&nbsp;<br>⑤ 根据映射配置和SQL语句得到ResultSet，并创建对应的实体对象；&nbsp;<br>⑥ 将对象纳入Session（一级缓存）的管理；&nbsp;<br>⑦ 如果有对应的拦截器，则执行拦截器的onLoad方法；&nbsp;<br>⑧ 如果开启并设置了要使用二级缓存，则将数据对象纳入二级缓存；&nbsp;<br>⑨ 返回数据对象。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>132、Query接口的list方法和iterate方法有什么区别？</b>&nbsp;<br></p><p style=\"text-align: justify;\">答：&nbsp;<br>① list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。&nbsp;<br>② list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题</p><blockquote><p style=\"text-align: justify;\">说明：关于N+1查询问题，可以参考CSDN上的一篇文章<a href=\"http://blog.csdn.net/xtayhicbladwin/article/details/4739852\" target=\"_blank\">《什么是N+1查询》</a></p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>133、Hibernate如何实现分页查询？&nbsp;</b><br>答：通过Hibernate实现分页查询，开发人员只需要提供HQL语句（调用Session的createQuery()方法）或查询条件（调用Session的createCriteria()方法）、设置查询起始行数（调用Query或Criteria接口的setFirstResult()方法）和最大查询行数（调用Query或Criteria接口的setMaxResults()方法），并调用Query或Criteria接口的list()方法，Hibernate会自动生成分页查询的SQL语句。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>134、锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。</b>&nbsp;<br>答：有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的锁机制。&nbsp;<br>Hibernate支持悲观锁和乐观锁两种锁机制。悲观锁，顾名思义悲观的认为在数据处理过程中极有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理的数据设置为锁定状态。悲观锁必须依赖数据库本身的锁机制才能真正保证数据访问的排他性，关于数据库的锁机制和事务隔离级别在<a href=\"http://blog.csdn.net/jackfrued/article/details/44921941\" target=\"_blank\">《Java面试题大全（上）》</a>中已经讨论过了。乐观锁，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加1，然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的当前版本号则更新数据，否则认为是过期数据无法更新。Hibernate中通过Session的get()和load()方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加整型的版本字段再通过XML或@Version注解进行配置。</p><blockquote><p style=\"text-align: justify;\">提示：使用乐观锁会增加了一个版本字段，很明显这需要额外的空间来存储这个版本字段，浪费了空间，但是乐观锁会让系统具有更好的并发性，这是对时间的节省。因此<span style=\"color: rgb(227, 55, 55);\">乐观锁也是典型的空间换时间的策略</span>。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>135、阐述实体对象的三种状态以及转换关系。</b>&nbsp;<br>答：最新的Hibernate文档中为Hibernate对象定义了四种状态（原来是三种状态，面试的时候基本上问的也是三种状态），分别是：瞬时态（new, or transient）、持久态（managed, or persistent）、游状态（detached）和移除态（removed，以前Hibernate文档中定义的三种状态中没有移除态），如下图所示，就以前的Hibernate文档中移除态被视为是瞬时态。</p><p style=\"text-align: justify;\"><img src=\"https://img-blog.csdn.net/20150412180839610\" alt=\"这里写图片描述\"></p><ul><li>瞬时态：当new一个实体对象后，这个对象处于瞬时态，即这个对象只是一个保存临时数据的内存区域，如果没有变量引用这个对象，则会被JVM的垃圾回收机制回收。这个对象所保存的数据与数据库没有任何关系，除非通过Session的save()、saveOrUpdate()、persist()、merge()方法把瞬时态对象与数据库关联，并把数据插入或者更新到数据库，这个对象才转换为持久态对象。</li><li>持久态：持久态对象的实例在数据库中有对应的记录，并拥有一个持久化标识（ID）。对持久态对象进行delete操作后，数据库中对应的记录将被删除，那么持久态对象与数据库记录不再存在对应关系，持久态对象变成移除态（可以视为瞬时态）。持久态对象被修改变更后，不会马上同步到数据库，直到数据库事务提交。</li><li>游离态：当Session进行了close()、clear()、evict()或flush()后，实体对象从持久态变成游离态，对象虽然拥有持久和与数据库对应记录一致的标识值，但是因为对象已经从会话中清除掉，对象不在持久化管理之内，所以处于游离态（也叫脱管态）。游离态的对象与临时状态对象是十分相似的，只是它还含有持久化标识。</li></ul><blockquote><p style=\"text-align: justify;\">提示：关于这个问题，在<a href=\"http://docs.jboss.org/hibernate/orm/4.3/devguide/en-US/html_single/#d5e874\" target=\"_blank\">Hibernate的官方文档</a>中有更为详细的解读。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>136、如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？&nbsp;</b><br>答：延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate使用了虚拟代理机制实现延迟加载，我们使用Session的load()方法加载数据或者一对多关联映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用getter方法时才会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。</p><p style=\"text-align: justify;\">延迟加载与session关闭的矛盾一般可以这样处理：&nbsp;<br>① 关闭延迟加载特性。这种方式操作起来比较简单，因为Hibernate的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现\"no session or session was closed\"通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询的开销都会变得很大。&nbsp;<br>② 在session关闭之前先获取需要查询的数据，可以使用工具方法Hibernate.isInitialized()判断对象是否被加载，如果没有被加载则可以使用Hibernate.initialize()方法加载对象。&nbsp;<br>③ 使用拦截器或过滤器延长Session的生命周期直到视图获得数据。Spring整合Hibernate提供的OpenSessionInViewFilter和OpenSessionInViewInterceptor就是这种做法。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>137、举一个多对多关联的例子，并说明如何实现多对多关联映射。</b>&nbsp;<br>答：例如：商品和订单、学生和课程都是典型的多对多关系。可以在实体类上通过@ManyToMany注解配置多对多关联或者通过映射文件中的和标签配置多对多关联，但是实际项目开发中，很多时候都是将多对多关联映射转换成两个多对一关联映射来实现的。</p><p style=\"text-align: justify;\"><b>138、谈一下你对继承映射的理解。&nbsp;</b><br>答：继承关系的映射策略有三种：&nbsp;<br>① 每个继承结构一张表（table per class hierarchy），不管多少个子类都用一张表。&nbsp;<br>② 每个子类一张表（table per subclass），公共信息放一张表，特有信息放单独的表。&nbsp;<br>③ 每个具体类一张表（table per concrete class），有多少个子类就有多少张表。&nbsp;<br>第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是需要进行连接查询，不适合多态查询。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>139、简述Hibernate常见优化策略。&nbsp;</b><br>答：这个问题应当挑自己使用过的优化策略回答，常用的有：&nbsp;<br>① 制定合理的缓存策略（二级缓存、查询缓存）。&nbsp;<br>② 采用合理的Session管理机制。&nbsp;<br>③ 尽量使用延迟加载特性。&nbsp;<br>④ 设定合理的批处理参数。&nbsp;<br>⑤ 如果可以，选用UUID作为主键生成器。&nbsp;<br>⑥ 如果可以，选用基于版本号的乐观锁替代悲观锁。&nbsp;<br>⑦ 在开发过程中, 开启hibernate.show_sql选项查看生成的SQL，从而了解底层的状况；开发完成后关闭此选项。&nbsp;<br>⑧ 考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观的提升，但这些需要专业的DBA（数据库管理员）提供支持。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>140、谈一谈Hibernate的一级缓存、二级缓存和查询缓存。&nbsp;</b><br>答：Hibernate的Session提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实体、修改持久化实体时，Session并不会立即把这种改变提交到数据库，而是缓存在当前的Session中，除非显示调用了Session的flush()方法或通过close()方法关闭Session。通过一级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。&nbsp;<br>SessionFactory级别的二级缓存是全局性的，所有的Session可以共享这个二级缓存。不过二级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，SessionFactory就会缓存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。&nbsp;<br>一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓存，可以使用查询缓存。查询缓存是将HQL或SQL语句以及它们的查询结果作为键值对进行缓存，对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>141、Hibernate中DetachedCriteria类是做什么的？&nbsp;</b><br>答：DetachedCriteria和Criteria的用法基本上是一致的，但Criteria是由Session的createCriteria()方法创建的，也就意味着离开创建它的Session，Criteria就无法使用了。DetachedCriteria不需要Session就可以创建（使用DetachedCriteria.forClass()方法创建），所以通常也称其为离线的Criteria，在需要进行查询操作的时候再和Session绑定（调用其getExecutableCriteria(Session)方法），这也就意味着一个DetachedCriteria可以在需要的时候和不同的Session进行绑定。</p><p style=\"text-align: justify;\"><b>142、@OneToMany注解的mappedBy属性有什么作用？</b>&nbsp;<br>答：@OneToMany用来配置一对多关联映射，但通常情况下，<span style=\"color: rgb(227, 55, 55);\">一对多关联映射都由<b>多的一方</b>来维护关联关系</span>，例如学生和班级，应该在学生类中添加班级属性来维持学生和班级的关联关系（在数据库中是由学生表中的外键班级编号来维护学生表和班级表的多对一关系），如果要使用双向关联，在班级类中添加一个容器属性来存放学生，并使用@OneToMany注解进行映射，此时mappedBy属性就非常重要。如果使用XML进行配置，可以用&lt;set&gt;标签的inverse=\"true\"设置来达到同样的效果。</p><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>143、MyBatis中使用<code>#</code>和<code>$</code>书写占位符有什么区别？&nbsp;</b><br>答：<code>#</code>将传入的数据都当成一个字符串，会对传入的数据自动加上引号；<code>$</code>将传入的数据直接显示生成在SQL中。注意：使用<code>$</code>占位符可能会导致SQL注射攻击，能用<code>#</code>的地方就不要使用<code>$</code>，写order by子句的时候应该用<code>$</code>而不是<code>#</code>。</p><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>144、解释一下MyBatis中命名空间（namespace）的作用。</b>&nbsp;<br>答：在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>145、MyBatis中的动态SQL是什么意思？&nbsp;</b><br>答：对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，例如在58同城上面找房子，我们可能会指定面积、楼层和所在位置来查找房源，也可能会指定面积、价格、户型和所在位置来查找房源，此时就需要根据用户指定的条件动态生成SQL语句。如果不使用持久层框架我们可能需要自己拼装SQL语句，还好MyBatis提供了动态SQL的功能来解决这个问题。MyBatis中用于实现动态SQL的元素主要有：&nbsp;<br>- if&nbsp;<br>- choose / when / otherwise&nbsp;<br>- trim&nbsp;<br>- where&nbsp;<br>- set&nbsp;<br>- foreach</p><p style=\"text-align: justify;\">下面是映射文件的片段。</p><pre><code class=\"lang-sql\">&lt;select id=\"foo\" parameterType=\"Blog\" resultType=\"Blog\"&gt;\n        select * from t_blog where 1 = 1\n        &lt;if test=\"title != null\"&gt;\n            and title = #{title}\n        &lt;/if&gt;\n        &lt;if test=\"content != null\"&gt;\n            and content = #{content}\n        &lt;/if&gt;\n        &lt;if test=\"owner != null\"&gt;\n            and owner = #{owner}\n        &lt;/if&gt;\n   &lt;/select&gt;<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">当然也可以像下面这些书写。</span><br></p><pre><code class=\"lang-java\">    &lt;select id=\"foo\" parameterType=\"Blog\" resultType=\"Blog\"&gt;\n        select * from t_blog where 1 = 1 \n        &lt;choose&gt;\n            &lt;when test=\"title != null\"&gt;\n                and title = #{title}\n            &lt;/when&gt;\n            &lt;when test=\"content != null\"&gt;\n                and content = #{content}\n            &lt;/when&gt;\n            &lt;otherwise&gt;\n                and owner = \"owner1\"\n            &lt;/otherwise&gt;\n        &lt;/choose&gt;\n    &lt;/select&gt;<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">再看看下面这个例子。</span><br></p><pre><code class=\"lang-java\">    &lt;select id=\"bar\" resultType=\"Blog\"&gt;\n        select * from t_blog where id in\n        &lt;foreach collection=\"array\" index=\"index\" \n            item=\"item\" open=\"(\" separator=\",\" close=\")\"&gt;\n            #{item}\n        &lt;/foreach&gt;\n    &lt;/select&gt;<br></code></pre><p><br></p><p style=\"text-align: justify;\"><b>146、什么是IoC和DI？DI是如何实现的？</b>&nbsp;<br>答：IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。控制反转是把传统上由<span style=\"color: rgb(227, 55, 55);\">程序代码直接操控的对象的调用权交给容器</span>，通过容器来实现对象组件的装配和管理。所谓的\"控制反转\"就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。IoC体现了好莱坞原则 - \"Don’t call me, we will call you\"。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p><p style=\"text-align: justify;\">举个例子：一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。</p><p style=\"text-align: justify;\"><span style=\"color: rgb(227, 55, 55);\">依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现</span>，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。</p><p style=\"text-align: justify;\"><b><br></b></p><p style=\"text-align: justify;\"><b>147、Spring中Bean的作用域有哪些？</b>&nbsp;<br>答：在Spring的早期版本中，仅有两个作用域：singleton和prototype，<span style=\"color: rgb(227, 55, 55);\">前者表示Bean以单例的方式存在</span>；后者表示每次从容器中调用Bean时，都会返回一个新的实例，<span style=\"color: rgb(227, 55, 55);\">prototype通常翻译为原型</span>。</p><blockquote><p style=\"text-align: justify;\">补充：设计模式中的创建型模式中也有一个原型模式，原型模式也是一个常用的模式，例如做一个室内设计软件，所有的素材都在工具箱中，而每次从工具箱中取出的都是素材对象的一个原型，可以通过对象克隆来实现原型模式。</p></blockquote><p style=\"text-align: justify;\">Spring 2.x中针对WebApplicationContext新增了3个作用域，分别是：request（每次HTTP请求都会创建一个新的Bean）、session（同一个HttpSession共享同一个Bean，不同的HttpSession使用不同的Bean）和globalSession（同一个全局Session共享一个Bean）。</p><blockquote><p style=\"text-align: justify;\">说明：单例模式和原型模式都是重要的设计模式。一般情况下，无状态或状态不可变的类适合使用单例模式。在传统开发中，由于DAO持有Connection这个非线程安全对象因而没有使用单例模式；但在Spring环境下，所有DAO类对可以采用单例模式，因为Spring利用AOP和Java API中的ThreadLocal对非线程安全的对象进行了特殊处理。</p></blockquote><p style=\"text-align: justify;\">ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。ThreadLocal，顾名思义是线程的一个本地化对象，当工作于多线程中的对象使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程分配一个独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不影响其他线程所对应的副本。从线程的角度看，这个变量就像是线程的本地变量。</p><p style=\"text-align: justify;\">ThreadLocal类非常简单好用，只有四个方法，能用上的也就是下面三个方法：&nbsp;<br>- void set(T value)：设置当前线程的线程局部变量的值。&nbsp;<br>- T get()：获得当前线程所对应的线程局部变量的值。&nbsp;<br>- void remove()：删除当前线程中线程局部变量的值。</p><p style=\"text-align: justify;\">ThreadLocal是如何做到为每一个线程维护一份独立的变量副本的呢？在ThreadLocal类中有一个Map，键为线程对象，值是其线程对应的变量的副本，自己要模拟实现一个ThreadLocal类其实并不困难，代码如下所示：</p><pre><code class=\"lang-java\">import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MyThreadLocal&lt;T&gt; {\n    private Map&lt;Thread, T&gt; map = Collections.synchronizedMap(new HashMap&lt;Thread, T&gt;());\n\n    public void set(T newValue) {\n        map.put(Thread.currentThread(), newValue);\n    }\n\n    public T get() {\n        return map.get(Thread.currentThread());\n    }\n\n    public void remove() {\n        map.remove(Thread.currentThread());\n    }\n}<br></code></pre><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>148、解释一下什么叫AOP（面向切面编程）？&nbsp;</b><br>答：AOP（Aspect-Oriented Programming）指一种程序设计范型，该范型以一种称为切面（aspect）的语言构造为基础，切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点（crosscutting concern）。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>149、你是如何理解\"横切关注\"这个概念的？&nbsp;</b><br>答：\"横切关注\"是会影响到整个应用程序的关注功能，它跟正常的业务逻辑是正交的，没有必然的联系，但是几乎所有的业务逻辑都会涉及到这些关注功能。通常，事务、日志、安全性等关注就是应用中的横切关注功能。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>150、你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？&nbsp;</b><br>答：&nbsp;<br>a. 连接点（Joinpoint）：程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。&nbsp;<br>b. 切点（Pointcut）：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。&nbsp;<br>c. 增强（Advice）：增强是织入到目标类连接点上的一段程序代码。Spring提供的增强接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice等。很多资料上将增强译为“通知”，这明显是个词不达意的翻译，让很多程序员困惑了许久。</p><blockquote><p style=\"text-align: justify;\">说明：&nbsp;Advice在国内的很多书面资料中都被翻译成\"通知\"，但是很显然这个翻译无法表达其本质，有少量的读物上将这个词翻译为\"增强\"，这个翻译是对Advice较为准确的诠释，我们通过AOP将横切关注功能加到原有的业务逻辑上，这就是对原有业务逻辑的一种增强，这种增强可以是前置增强、后置增强、返回后增强、抛异常时增强和包围型增强。</p></blockquote><p style=\"text-align: justify;\">d. 引介（Introduction）：引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过引介功能，可以动态的未该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。&nbsp;<br>e. 织入（Weaving）：织入是将增强添加到目标类具体连接点上的过程，AOP有三种织入方式：①编译期织入：需要特殊的Java编译期（例如AspectJ的ajc）；②装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强；③运行时织入：在运行时为目标类生成代理实现增强。Spring采用了动态代理的方式实现了运行时织入，而AspectJ采用了编译期织入和装载期织入的方式。&nbsp;<br>f. 切面（Aspect）：切面是由切点和增强（引介）组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。</p><blockquote><p style=\"text-align: justify;\">补充：代理模式是GoF提出的23种设计模式中最为经典的模式之一，代理模式是对象的结构模式，它给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。简单的说，代理对象可以完成比原对象更多的职责，当需要为原对象添加横切关注功能时，就可以使用原对象的代理对象。我们在打开Office系列的Word文档时，如果文档中有插图，当文档刚加载时，文档中的插图都只是一个虚框占位符，等用户真正翻到某页要查看该图片时，才会真正加载这张图，这其实就是对代理模式的使用，代替真正图片的虚框就是一个虚拟代理；Hibernate的load方法也是返回一个虚拟代理对象，等用户真正需要访问对象的属性时，才向数据库发出SQL语句获得真实对象。</p></blockquote><p style=\"text-align: justify;\">下面用一个找枪手代考的例子演示代理模式的使用：</p><pre><code class=\"lang-java\">/**\n * 参考人员接口\n * @author 骆昊\n *\n */\npublic interface Candidate {\n\n    /**\n     * 答题\n     */\n    public void answerTheQuestions();\n}<br></code></pre><pre><code class=\"lang-java\">/**\n * 懒学生\n * @author 骆昊\n *\n */\npublic class LazyStudent implements Candidate {\n    private String name;        // 姓名\n\n    public LazyStudent(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void answerTheQuestions() {\n        // 懒学生只能写出自己的名字不会答题\n        System.out.println(\"姓名: \" + name);\n    }\n\n}<br></code></pre><pre><code class=\"lang-java\">/**\n * 枪手\n * @author 骆昊\n *\n */\npublic class Gunman implements Candidate {\n    private Candidate target;   // 被代理对象\n\n    public Gunman(Candidate target) {\n        this.target = target;\n    }\n\n    @Override\n    public void answerTheQuestions() {\n        // 枪手要写上代考的学生的姓名\n        target.answerTheQuestions();\n        // 枪手要帮助懒学生答题并交卷\n        System.out.println(\"奋笔疾书正确答案\");\n        System.out.println(\"交卷\");\n    }\n\n}<br></code></pre><pre><code class=\"lang-java\">public class ProxyTest1 {\n\n    public static void main(String[] args) {\n        Candidate c = new Gunman(new LazyStudent(\"王小二\"));\n        c.answerTheQuestions();\n    }\n}<br></code></pre><blockquote><p><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">说明：</span><span style=\"color: rgb(153, 153, 153); font-size: 14px;\">从JDK 1.3开始，Java提供了动态代理技术，允许开发者在运行时创建接口的代理实例，主要包括Proxy类和InvocationHandler接口。下面的例子使用动态代理为ArrayList编写一个代理，在添加和删除元素时，在控制台打印添加或删除的元素以及ArrayList的大小：</span><br></p></blockquote><pre><code class=\"lang-java\">import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.util.List;\n\npublic class ListProxy&lt;T&gt; implements InvocationHandler {\n    private List&lt;T&gt; target;\n\n    public ListProxy(List&lt;T&gt; target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args)\n            throws Throwable {\n        Object retVal = null;\n        System.out.println(\"[\" + method.getName() + \": \" + args[0] + \"]\");\n        retVal = method.invoke(target, args);\n        System.out.println(\"[size=\" + target.size() + \"]\");\n        return retVal;\n    }\n\n}<br></code></pre><pre><code class=\"lang-java\">import java.lang.reflect.Proxy;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ProxyTest2 {\n\n    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) {\n        List&lt;String&gt; list = new ArrayList&lt;String&gt;();\n        Class&lt;?&gt; clazz = list.getClass();\n        ListProxy&lt;String&gt; myProxy = new ListProxy&lt;String&gt;(list);\n        List&lt;String&gt; newList = (List&lt;String&gt;) \n                Proxy.newProxyInstance(clazz.getClassLoader(), \n                clazz.getInterfaces(), myProxy);\n        newList.add(\"apple\");\n        newList.add(\"banana\");\n        newList.add(\"orange\");\n        newList.remove(\"banana\");\n    }\n}<br></code></pre><blockquote><p style=\"text-align: justify;\">说明：使用Java的动态代理有一个局限性就是代理的类必须要实现接口，虽然面向接口编程是每个优秀的Java程序都知道的规则，但现实往往不尽如人意，对于没有实现接口的类如何为其生成代理呢？继承！继承是最经典的扩展已有代码能力的手段，虽然继承常常被初学者滥用，但继承也常常被进阶的程序员忽视。CGLib采用非常底层的字节码生成技术，通过为一个类创建子类来生成代理，它弥补了Java动态代理的不足，因此Spring中动态代理和CGLib都是创建代理的重要手段，对于实现了接口的类就用动态代理为其生成代理类，而没有实现接口的类就用CGLib通过继承的方式为其创建代理。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>151、Spring中自动装配的方式有哪些？&nbsp;</b><br>答：&nbsp;<br>- no：不进行自动装配，手动设置Bean的依赖关系。&nbsp;<br>- byName：根据Bean的名字进行自动装配。&nbsp;<br>- byType：根据Bean的类型进行自动装配。&nbsp;<br>- constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。&nbsp;<br>- autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。</p><blockquote><p style=\"text-align: justify;\">说明：自动装配没有自定义装配方式那么精确，而且不能自动装配简单属性（基本类型、字符串等），在使用时应注意。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>152、Spring中如何使用注解来配置Bean？有哪些相关的注解？&nbsp;</b><br>答：首先需要在Spring配置文件中增加如下配置：</p><pre><code class=\"lang-java\">&lt;context:component-scan base-package=\"org.example\"/&gt;<br></code></pre><p style=\"text-align: justify;\">然后可以用@Component、@Controller、@Service、@Repository注解来标注需要由Spring IoC容器进行对象托管的类。这几个注解没有本质区别，只不过@Controller通常用于控制器，@Service通常用于业务逻辑类，@Repository通常用于仓储类（例如我们的DAO实现类），普通的类用@Component来标注。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>153、Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？&nbsp;</b><br>答：Spring支持编程式事务管理和声明式事务管理。许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理，因为编程式事务允许你通过代码控制业务。</p><p style=\"text-align: justify;\">事务分为全局事务和局部事务。全局事务由应用服务器管理，需要底层服务器JTA支持（如WebLogic、WildFly等）。局部事务和底层采用的持久化方案有关，例如使用JDBC进行持久化时，需要使用Connetion对象来操作事务；而采用Hibernate进行持久化时，需要使用Session对象来操作事务。</p><p style=\"text-align: justify;\">Spring提供了如下所示的事务管理器。</p><table><colgroup><col width=\"49.88066825775656%\"><col width=\"50.11933174224343%\"></colgroup><thead><tr><th>事务管理器实现类</th><th>目标对象</th></tr></thead><tbody><tr><td style=\"text-align: left;\">DataSourceTransactionManager</td><td style=\"text-align: left;\">注入DataSource</td></tr><tr><td style=\"text-align: left;\">HibernateTransactionManager</td><td style=\"text-align: left;\">注入SessionFactory</td></tr><tr><td style=\"text-align: left;\">JdoTransactionManager</td><td style=\"text-align: left;\">管理JDO事务</td></tr><tr><td style=\"text-align: left;\">JtaTransactionManager</td><td style=\"text-align: left;\">使用JTA管理事务</td></tr><tr><td style=\"text-align: left;\">PersistenceBrokerTransactionManager</td><td style=\"text-align: left;\">管理Apache的OJB事务</td></tr></tbody></table><p style=\"text-align: justify;\">这些事务的父接口都是PlatformTransactionManager。Spring的事务管理机制是一种典型的策略模式，PlatformTransactionManager代表事务管理接口，该接口定义了三个方法，该接口并不知道底层如何管理事务，但是它的实现类必须提供getTransaction()方法（开启事务）、commit()方法（提交事务）、rollback()方法（回滚事务）的多态实现，这样就可以用不同的实现类代表不同的事务管理策略。使用JTA全局事务策略时，需要底层应用服务器支持，而不同的应用服务器所提供的JTA全局事务可能存在细节上的差异，因此实际配置全局事务管理器是可能需要使用JtaTransactionManager的子类，如：WebLogicJtaTransactionManager（Oracle的WebLogic服务器提供）、UowJtaTransactionManager（IBM的WebSphere服务器提供）等。</p><p style=\"text-align: justify;\">编程式事务管理如下所示。</p><pre><code class=\"lang-html\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n &lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xmlns:p=\"http://www.springframework.org/schema/p\"\n    xmlns:p=\"http://www.springframework.org/schema/context\"\n     xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n     http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;\n\n     &lt;context:component-scan base-package=\"com.jackfrued\"/&gt;\n\n     &lt;bean id=\"propertyConfig\"\n         class=\"org.springframework.beans.factory.config.\n  PropertyPlaceholderConfigurer\"&gt;\n         &lt;property name=\"location\"&gt;\n             &lt;value&gt;jdbc.properties&lt;/value&gt;\n         &lt;/property&gt;\n     &lt;/bean&gt;\n\n     &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt;\n         &lt;property name=\"driverClassName\"&gt;\n             &lt;value&gt;${db.driver}&lt;/value&gt;\n         &lt;/property&gt;\n         &lt;property name=\"url\"&gt;\n             &lt;value&gt;${db.url}&lt;/value&gt;\n         &lt;/property&gt;\n         &lt;property name=\"username\"&gt;\n             &lt;value&gt;${db.username}&lt;/value&gt;\n         &lt;/property&gt;\n         &lt;property name=\"password\"&gt;\n             &lt;value&gt;${db.password}&lt;/value&gt;\n         &lt;/property&gt;\n     &lt;/bean&gt;\n\n     &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt;\n         &lt;property name=\"dataSource\"&gt;\n             &lt;ref bean=\"dataSource\" /&gt;\n         &lt;/property&gt;\n     &lt;/bean&gt;\n\n     &lt;!-- JDBC事务管理器 --&gt;\n     &lt;bean id=\"transactionManager\"\n         class=\"org.springframework.jdbc.datasource.\n       DataSourceTransactionManager\"　scope=\"singleton\"&gt;\n         &lt;property name=\"dataSource\"&gt;\n             &lt;ref bean=\"dataSource\" /&gt;\n         &lt;/property&gt;\n     &lt;/bean&gt;\n\n     &lt;!-- 声明事务模板 --&gt;\n     &lt;bean id=\"transactionTemplate\"\n         class=\"org.springframework.transaction.support.\n   TransactionTemplate\"&gt;\n         &lt;property name=\"transactionManager\"&gt;\n             &lt;ref bean=\"transactionManager\" /&gt;\n         &lt;/property&gt;\n     &lt;/bean&gt;\n\n&lt;/beans&gt;<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.dao.impl;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport com.jackfrued.dao.EmpDao;\nimport com.jackfrued.entity.Emp;\n\n@Repository\npublic class EmpDaoImpl implements EmpDao {\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @Override\n    public boolean save(Emp emp) {\n        String sql = \"insert into emp values (?,?,?)\";\n        return jdbcTemplate.update(sql, emp.getId(), emp.getName(), emp.getBirthday()) == 1;\n    }\n\n}<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.biz.impl;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.TransactionStatus;\nimport org.springframework.transaction.support.TransactionCallbackWithoutResult;\nimport org.springframework.transaction.support.TransactionTemplate;\n\nimport com.jackfrued.biz.EmpService;\nimport com.jackfrued.dao.EmpDao;\nimport com.jackfrued.entity.Emp;\n\n@Service\npublic class EmpServiceImpl implements EmpService {\n    @Autowired\n    private TransactionTemplate txTemplate;\n    @Autowired\n    private EmpDao empDao;\n\n    @Override\n    public void addEmp(final Emp emp) {\n        txTemplate.execute(new TransactionCallbackWithoutResult() {\n\n            @Override\n            protected void doInTransactionWithoutResult(TransactionStatus txStatus) {\n                empDao.save(emp);\n            }\n        });\n    }\n\n\n}<br></code></pre><p>声明式事务如下图所示，以Spring整合Hibernate 3为例，包括完整的DAO和业务逻辑代码。<br></p><pre><code class=\"lang-java\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n    xmlns:p=\"http://www.springframework.org/schema/p\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\" \n    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\n           http://www.springframework.org/schema/context\n           http://www.springframework.org/schema/context/spring-context-3.2.xsd\n           http://www.springframework.org/schema/aop\n           http://www.springframework.org/schema/aop/spring-aop-3.2.xsd\n           http://www.springframework.org/schema/tx\n           http://www.springframework.org/schema/tx/spring-tx-3.2.xsd\"&gt;\n\n    &lt;!-- 配置由Spring IoC容器托管的对象对应的被注解的类所在的包 --&gt;\n    &lt;context:component-scan base-package=\"com.jackfrued\" /&gt;\n\n    &lt;!-- 配置通过自动生成代理实现AOP功能 --&gt;\n    &lt;aop:aspectj-autoproxy /&gt;\n\n    &lt;!-- 配置数据库连接池 (DBCP) --&gt;\n    &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"\n        destroy-method=\"close\"&gt;\n        &lt;!-- 配置驱动程序类 --&gt;\n        &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt;\n        &lt;!-- 配置连接数据库的URL --&gt;\n        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/myweb\" /&gt;\n        &lt;!-- 配置访问数据库的用户名 --&gt;\n        &lt;property name=\"username\" value=\"root\" /&gt;\n        &lt;!-- 配置访问数据库的口令 --&gt;\n        &lt;property name=\"password\" value=\"123456\" /&gt;\n        &lt;!-- 配置最大连接数 --&gt;\n        &lt;property name=\"maxActive\" value=\"150\" /&gt;\n        &lt;!-- 配置最小空闲连接数 --&gt;\n        &lt;property name=\"minIdle\" value=\"5\" /&gt;\n        &lt;!-- 配置最大空闲连接数 --&gt;\n        &lt;property name=\"maxIdle\" value=\"20\" /&gt;\n        &lt;!-- 配置初始连接数 --&gt;\n        &lt;property name=\"initialSize\" value=\"10\" /&gt;\n        &lt;!-- 配置连接被泄露时是否生成日志 --&gt;\n        &lt;property name=\"logAbandoned\" value=\"true\" /&gt;\n        &lt;!-- 配置是否删除超时连接 --&gt;\n        &lt;property name=\"removeAbandoned\" value=\"true\" /&gt;\n        &lt;!-- 配置删除超时连接的超时门限值(以秒为单位) --&gt;\n        &lt;property name=\"removeAbandonedTimeout\" value=\"120\" /&gt;\n        &lt;!-- 配置超时等待时间(以毫秒为单位) --&gt;\n        &lt;property name=\"maxWait\" value=\"5000\" /&gt;\n        &lt;!-- 配置空闲连接回收器线程运行的时间间隔(以毫秒为单位) --&gt;\n        &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"300000\" /&gt;\n        &lt;!-- 配置连接空闲多长时间后(以毫秒为单位)被断开连接 --&gt;\n        &lt;property name=\"minEvictableIdleTimeMillis\" value=\"60000\" /&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 配置Spring提供的支持注解ORM映射的Hibernate会话工厂 --&gt;\n    &lt;bean id=\"sessionFactory\"\n        class=\"org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean\"&gt;\n        &lt;!-- 通过setter注入数据源属性 --&gt;\n        &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;\n        &lt;!-- 配置实体类所在的包 --&gt;\n        &lt;property name=\"packagesToScan\" value=\"com.jackfrued.entity\" /&gt;\n        &lt;!-- 配置Hibernate的相关属性 --&gt;\n        &lt;property name=\"hibernateProperties\"&gt;\n            &lt;!-- 在项目调试完成后要删除show_sql和format_sql属性否则对性能有显著影响 --&gt;\n            &lt;value&gt;\n                hibernate.dialect=org.hibernate.dialect.MySQL5Dialect\n            &lt;/value&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 配置Spring提供的Hibernate事务管理器 --&gt;\n    &lt;bean id=\"transactionManager\"\n        class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\"&gt;\n        &lt;!-- 通过setter注入Hibernate会话工厂 --&gt;\n        &lt;property name=\"sessionFactory\" ref=\"sessionFactory\" /&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 配置基于注解配置声明式事务 --&gt;\n    &lt;tx:annotation-driven /&gt;\n\n&lt;/beans&gt;<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.dao;\n\nimport java.io.Serializable;\nimport java.util.List;\n\nimport com.jackfrued.comm.QueryBean;\nimport com.jackfrued.comm.QueryResult;\n\n/**\n * 数据访问对象接口(以对象为单位封装CRUD操作)\n * @author 骆昊\n *\n * @param &lt;E&gt; 实体类型\n * @param &lt;K&gt; 实体标识字段的类型\n */\npublic interface BaseDao &lt;E, K extends Serializable&gt; {\n\n    /**\n     * 新增\n     * @param entity 业务实体对象\n     * @return 增加成功返回实体对象的标识\n     */\n    public K save(E entity);\n\n    /**\n     * 删除\n     * @param entity 业务实体对象\n     */\n    public void delete(E entity);\n\n    /**\n     * 根据ID删除\n     * @param id 业务实体对象的标识\n     * @return 删除成功返回true否则返回false\n     */\n    public boolean deleteById(K id);\n\n    /**\n     * 修改\n     * @param entity 业务实体对象\n     * @return 修改成功返回true否则返回false\n     */\n    public void update(E entity);\n\n    /**\n     * 根据ID查找业务实体对象\n     * @param id 业务实体对象的标识\n     * @return 业务实体对象对象或null\n     */\n    public E findById(K id);\n\n    /**\n     * 根据ID查找业务实体对象\n     * @param id 业务实体对象的标识\n     * @param lazy 是否使用延迟加载\n     * @return 业务实体对象对象\n     */\n    public E findById(K id, boolean lazy);\n\n    /**\n     * 查找所有业务实体对象\n     * @return 装所有业务实体对象的列表容器\n     */\n    public List&lt;E&gt; findAll();\n\n    /**\n     * 分页查找业务实体对象\n     * @param page 页码\n     * @param size 页面大小\n     * @return 查询结果对象\n     */\n    public QueryResult&lt;E&gt; findByPage(int page, int size);\n\n    /**\n     * 分页查找业务实体对象\n     * @param queryBean 查询条件对象\n     * @param page 页码\n     * @param size 页面大小\n     * @return 查询结果对象\n     */\n    public QueryResult&lt;E&gt; findByPage(QueryBean queryBean, int page, int size);\n\n}<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.dao;\n\nimport java.io.Serializable;\nimport java.util.List;\n\nimport com.jackfrued.comm.QueryBean;\nimport com.jackfrued.comm.QueryResult;\n\n/**\n * BaseDao的缺省适配器\n * @author 骆昊\n *\n * @param &lt;E&gt; 实体类型\n * @param &lt;K&gt; 实体标识字段的类型\n */\npublic abstract class BaseDaoAdapter&lt;E, K extends Serializable&gt; implements\n        BaseDao&lt;E, K&gt; {\n\n    @Override\n    public K save(E entity) {\n        return null;\n    }\n\n    @Override\n    public void delete(E entity) {\n    }\n\n    @Override\n    public boolean deleteById(K id) {\n        E entity = findById(id);\n        if(entity != null) {\n            delete(entity);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public void update(E entity) {\n    }\n\n    @Override\n    public E findById(K id) {\n        return null;\n    }\n\n    @Override\n    public E findById(K id, boolean lazy) {\n        return null;\n    }\n\n    @Override\n    public List&lt;E&gt; findAll() {\n        return null;\n    }\n\n    @Override\n    public QueryResult&lt;E&gt; findByPage(int page, int size) {\n        return null;\n    }\n\n    @Override\n    public QueryResult&lt;E&gt; findByPage(QueryBean queryBean, int page, int size) {\n        return null;\n    }\n\n}<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.dao;\n\nimport java.io.Serializable;\nimport java.lang.reflect.ParameterizedType;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.hibernate.Query;\nimport org.hibernate.Session;\nimport org.hibernate.SessionFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport com.jackfrued.comm.HQLQueryBean;\nimport com.jackfrued.comm.QueryBean;\nimport com.jackfrued.comm.QueryResult;\n\n/**\n * 基于Hibernate的BaseDao实现类\n * @author 骆昊\n *\n * @param &lt;E&gt; 实体类型\n * @param &lt;K&gt; 主键类型\n */\n@SuppressWarnings(value = {\"unchecked\"})\npublic abstract class BaseDaoHibernateImpl&lt;E, K extends Serializable&gt; extends BaseDaoAdapter&lt;E, K&gt; {\n    @Autowired\n    protected SessionFactory sessionFactory;\n\n    private Class&lt;?&gt; entityClass;       // 业务实体的类对象\n    private String entityName;          // 业务实体的名字\n\n    public BaseDaoHibernateImpl() {\n        ParameterizedType pt = (ParameterizedType) this.getClass().getGenericSuperclass();\n        entityClass = (Class&lt;?&gt;) pt.getActualTypeArguments()[0];\n        entityName = entityClass.getSimpleName();\n    }\n\n    @Override\n    public K save(E entity) {\n        return (K) sessionFactory.getCurrentSession().save(entity);\n    }\n\n    @Override\n    public void delete(E entity) {\n        sessionFactory.getCurrentSession().delete(entity);\n    }\n\n    @Override\n    public void update(E entity) {\n        sessionFactory.getCurrentSession().update(entity);\n    }\n\n    @Override\n    public E findById(K id) {\n        return findById(id, false);\n    }\n\n    @Override\n    public E findById(K id, boolean lazy) {\n        Session session = sessionFactory.getCurrentSession();\n        return (E) (lazy? session.load(entityClass, id) : session.get(entityClass, id));\n    }\n\n    @Override\n    public List&lt;E&gt; findAll() {\n        return sessionFactory.getCurrentSession().createCriteria(entityClass).list();\n    }\n\n    @Override\n    public QueryResult&lt;E&gt; findByPage(int page, int size) {\n        return new QueryResult&lt;E&gt;(\n            findByHQLAndPage(\"from \" + entityName , page, size),\n            getCountByHQL(\"select count(*) from \" + entityName)\n        );\n    }\n\n    @Override\n    public QueryResult&lt;E&gt; findByPage(QueryBean queryBean, int page, int size) {\n        if(queryBean instanceof HQLQueryBean) {\n            HQLQueryBean hqlQueryBean = (HQLQueryBean) queryBean;\n            return new QueryResult&lt;E&gt;(\n                findByHQLAndPage(hqlQueryBean.getQueryString(), page, size, hqlQueryBean.getParameters()),\n                getCountByHQL(hqlQueryBean.getCountString(), hqlQueryBean.getParameters())\n            );\n        }\n        return null;\n    }\n\n    /**\n     * 根据HQL和可变参数列表进行查询\n     * @param hql 基于HQL的查询语句\n     * @param params 可变参数列表\n     * @return 持有查询结果的列表容器或空列表容器\n     */\n    protected List&lt;E&gt; findByHQL(String hql, Object... params) {\n        return this.findByHQL(hql, getParamList(params));\n    }\n\n    /**\n     * 根据HQL和参数列表进行查询\n     * @param hql 基于HQL的查询语句\n     * @param params 查询参数列表\n     * @return 持有查询结果的列表容器或空列表容器\n     */\n    protected List&lt;E&gt; findByHQL(String hql, List&lt;Object&gt; params) {\n        List&lt;E&gt; list = createQuery(hql, params).list();\n        return list != null &amp;&amp; list.size() &gt; 0 ? list : Collections.EMPTY_LIST;\n    }\n\n    /**\n     * 根据HQL和参数列表进行分页查询\n     * @param hql 基于HQL的查询语句\n     * @page 页码\n     * @size 页面大小\n     * @param params 可变参数列表\n     * @return 持有查询结果的列表容器或空列表容器\n     */\n    protected List&lt;E&gt; findByHQLAndPage(String hql, int page, int size, Object... params) {\n        return this.findByHQLAndPage(hql, page, size, getParamList(params));\n    }\n\n    /**\n     * 根据HQL和参数列表进行分页查询\n     * @param hql 基于HQL的查询语句\n     * @page 页码\n     * @size 页面大小\n     * @param params 查询参数列表\n     * @return 持有查询结果的列表容器或空列表容器\n     */\n    protected List&lt;E&gt; findByHQLAndPage(String hql, int page, int size, List&lt;Object&gt; params) {\n        List&lt;E&gt; list = createQuery(hql, params)\n                .setFirstResult((page - 1) * size)\n                .setMaxResults(size)\n                .list();\n        return list != null &amp;&amp; list.size() &gt; 0 ? list : Collections.EMPTY_LIST;\n    }\n\n    /**\n     * 查询满足条件的记录数\n     * @param hql 基于HQL的查询语句\n     * @param params 可变参数列表\n     * @return 满足查询条件的总记录数\n     */\n    protected long getCountByHQL(String hql, Object... params) {\n        return this.getCountByHQL(hql, getParamList(params));\n    }\n\n    /**\n     * 查询满足条件的记录数\n     * @param hql 基于HQL的查询语句\n     * @param params 参数列表容器\n     * @return 满足查询条件的总记录数\n     */\n    protected long getCountByHQL(String hql, List&lt;Object&gt; params) {\n        return (Long) createQuery(hql, params).uniqueResult();\n    }\n\n    // 创建Hibernate查询对象(Query)\n    private Query createQuery(String hql, List&lt;Object&gt; params) {\n        Query query = sessionFactory.getCurrentSession().createQuery(hql);\n        for(int i = 0; i &lt; params.size(); i++) {\n            query.setParameter(i, params.get(i));\n        }\n        return query;\n    }\n\n    // 将可变参数列表组装成列表容器\n    private List&lt;Object&gt; getParamList(Object... params) {\n        List&lt;Object&gt; paramList = new ArrayList&lt;&gt;();\n        if(params != null) {\n            for(int i = 0; i &lt; params.length; i++) {\n                paramList.add(params[i]);\n            }\n        }\n        return paramList.size() == 0? Collections.EMPTY_LIST : paramList;\n    }\n\n}<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.comm;\n\nimport java.util.List;\n\n/**\n * 查询条件的接口\n * @author 骆昊\n *\n */\npublic interface QueryBean {\n\n    /**\n     * 添加排序字段\n     * @param fieldName 用于排序的字段\n     * @param asc 升序还是降序\n     * @return 查询条件对象自身(方便级联编程)\n     */\n    public QueryBean addOrder(String fieldName, boolean asc);\n\n    /**\n     * 添加排序字段\n     * @param available 是否添加此排序字段\n     * @param fieldName 用于排序的字段\n     * @param asc 升序还是降序\n     * @return 查询条件对象自身(方便级联编程)\n     */\n    public QueryBean addOrder(boolean available, String fieldName, boolean asc);\n\n    /**\n     * 添加查询条件\n     * @param condition 条件\n     * @param params 替换掉条件中参数占位符的参数\n     * @return 查询条件对象自身(方便级联编程)\n     */\n    public QueryBean addCondition(String condition, Object... params);\n\n    /**\n     * 添加查询条件\n     * @param available 是否需要添加此条件\n     * @param condition 条件\n     * @param params 替换掉条件中参数占位符的参数\n     * @return 查询条件对象自身(方便级联编程)\n     */\n    public QueryBean addCondition(boolean available, String condition, Object... params);\n\n    /**\n     * 获得查询语句\n     * @return 查询语句\n     */\n    public String getQueryString();\n\n    /**\n     * 获取查询记录数的查询语句\n     * @return 查询记录数的查询语句\n     */\n    public String getCountString();\n\n    /**\n     * 获得查询参数\n     * @return 查询参数的列表容器\n     */\n    public List&lt;Object&gt; getParameters();\n}<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.comm;\n\nimport java.util.List;\n\n/**\n * 查询结果\n * @author 骆昊\n *\n * @param &lt;T&gt; 泛型参数\n */\npublic class QueryResult&lt;T&gt; {\n    private List&lt;T&gt; result;     // 持有查询结果的列表容器\n    private long totalRecords;  // 查询到的总记录数\n\n    /**\n     * 构造器\n     */\n    public QueryResult() {\n    }\n\n    /**\n     * 构造器\n     * @param result 持有查询结果的列表容器\n     * @param totalRecords 查询到的总记录数\n     */\n    public QueryResult(List&lt;T&gt; result, long totalRecords) {\n        this.result = result;\n        this.totalRecords = totalRecords;\n    }\n\n    public List&lt;T&gt; getResult() {\n        return result;\n    }\n\n    public void setResult(List&lt;T&gt; result) {\n        this.result = result;\n    }\n\n    public long getTotalRecords() {\n        return totalRecords;\n    }\n\n    public void setTotalRecords(long totalRecords) {\n        this.totalRecords = totalRecords;\n    }\n}<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.dao;\n\nimport com.jackfrued.comm.QueryResult;\nimport com.jackfrued.entity.Dept;\n\n/**\n * 部门数据访问对象接口\n * @author 骆昊\n *\n */\npublic interface DeptDao extends BaseDao&lt;Dept, Integer&gt; {\n\n    /**\n     * 分页查询顶级部门\n     * @param page 页码\n     * @param size 页码大小\n     * @return 查询结果对象\n     */\n    public QueryResult&lt;Dept&gt; findTopDeptByPage(int page, int size);\n\n}<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.dao.impl;\n\nimport java.util.List;\n\nimport org.springframework.stereotype.Repository;\n\nimport com.jackfrued.comm.QueryResult;\nimport com.jackfrued.dao.BaseDaoHibernateImpl;\nimport com.jackfrued.dao.DeptDao;\nimport com.jackfrued.entity.Dept;\n\n@Repository\npublic class DeptDaoImpl extends BaseDaoHibernateImpl&lt;Dept, Integer&gt; implements DeptDao {\n    private static final String HQL_FIND_TOP_DEPT = \" from Dept as d where d.superiorDept is null \";\n\n    @Override\n    public QueryResult&lt;Dept&gt; findTopDeptByPage(int page, int size) {\n        List&lt;Dept&gt; list = findByHQLAndPage(HQL_FIND_TOP_DEPT, page, size);\n        long totalRecords = getCountByHQL(\" select count(*) \" + HQL_FIND_TOP_DEPT);\n        return new QueryResult&lt;&gt;(list, totalRecords);\n    }\n\n}<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.comm;\n\nimport java.util.List;\n\n/**\n * 分页器\n * @author 骆昊\n *\n * @param &lt;T&gt; 分页数据对象的类型\n */\npublic class PageBean&lt;T&gt; {\n    private static final int DEFAUL_INIT_PAGE = 1;\n    private static final int DEFAULT_PAGE_SIZE = 10;\n    private static final int DEFAULT_PAGE_COUNT = 5;\n\n    private List&lt;T&gt; data;           // 分页数据\n    private PageRange pageRange;    // 页码范围\n    private int totalPage;          // 总页数\n    private int size;               // 页面大小\n    private int currentPage;        // 当前页码\n    private int pageCount;          // 页码数量\n\n    /**\n     * 构造器\n     * @param currentPage 当前页码\n     * @param size 页码大小\n     * @param pageCount 页码数量\n     */\n    public PageBean(int currentPage, int size, int pageCount) {\n        this.currentPage = currentPage &gt; 0 ? currentPage : 1;\n        this.size = size &gt; 0 ? size : DEFAULT_PAGE_SIZE;\n        this.pageCount = pageCount &gt; 0 ? size : DEFAULT_PAGE_COUNT;\n    }\n\n    /**\n     * 构造器\n     * @param currentPage 当前页码\n     * @param size 页码大小\n     */\n    public PageBean(int currentPage, int size) {\n        this(currentPage, size, DEFAULT_PAGE_COUNT);\n    }\n\n    /**\n     * 构造器\n     * @param currentPage 当前页码\n     */\n    public PageBean(int currentPage) {\n        this(currentPage, DEFAULT_PAGE_SIZE, DEFAULT_PAGE_COUNT);\n    }\n\n    /**\n     * 构造器\n     */\n    public PageBean() {\n        this(DEFAUL_INIT_PAGE, DEFAULT_PAGE_SIZE, DEFAULT_PAGE_COUNT);\n    }\n\n    public List&lt;T&gt; getData() {\n        return data;\n    }\n\n    public int getStartPage() {\n        return pageRange != null ? pageRange.getStartPage() : 1;\n    }\n\n    public int getEndPage() {\n        return pageRange != null ? pageRange.getEndPage() : 1;\n    }\n\n    public long getTotalPage() {\n        return totalPage;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public int getCurrentPage() {\n        return currentPage;\n    }\n\n    /**\n     * 将查询结果转换为分页数据\n     * @param queryResult 查询结果对象\n     */\n    public void transferQueryResult(QueryResult&lt;T&gt; queryResult) {\n        long totalRecords = queryResult.getTotalRecords();\n\n        data = queryResult.getResult();\n        totalPage = (int) ((totalRecords + size - 1) / size); \n        totalPage = totalPage &gt;= 0 ? totalPage : Integer.MAX_VALUE;\n        this.pageRange = new PageRange(pageCount, currentPage, totalPage);\n    }\n\n}<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.comm;\n\n/**\n * 页码范围\n * @author 骆昊\n *\n */\npublic class PageRange {\n    private int startPage;  // 起始页码\n    private int endPage;    // 终止页码\n\n    /**\n     * 构造器\n     * @param pageCount 总共显示几个页码\n     * @param currentPage 当前页码\n     * @param totalPage 总页数\n     */\n    public PageRange(int pageCount, int currentPage, int totalPage) {\n        startPage = currentPage - (pageCount - 1) / 2;\n        endPage = currentPage + pageCount / 2;\n        if(startPage &lt; 1) {\n            startPage = 1;\n            endPage = totalPage &gt; pageCount ? pageCount : totalPage;\n        }\n        if (endPage &gt; totalPage) {\n            endPage = totalPage;\n            startPage = (endPage - pageCount &gt; 0) ? endPage - pageCount + 1 : 1;\n        }\n    }\n\n    /**\n     * 获得起始页页码\n     * @return 起始页页码\n     */\n    public int getStartPage() {\n        return startPage;\n    }\n\n    /**\n     * 获得终止页页码\n     * @return 终止页页码\n     */\n    public int getEndPage() {\n        return endPage;\n    }\n\n}<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.biz;\n\nimport com.jackfrued.comm.PageBean;\nimport com.jackfrued.entity.Dept;\n\n/**\n * 部门业务逻辑接口\n * @author 骆昊\n *\n */\npublic interface DeptService {\n\n    /**\n     * 创建新的部门\n     * @param department 部门对象\n     * @return 创建成功返回true否则返回false\n     */\n    public boolean createNewDepartment(Dept department);\n\n    /**\n     * 删除指定部门\n     * @param id 要删除的部门的编号\n     * @return 删除成功返回true否则返回false\n     */\n    public boolean deleteDepartment(Integer id);\n\n    /**\n     * 分页获取顶级部门\n     * @param page 页码\n     * @param size 页码大小\n     * @return 部门对象的分页器对象\n     */\n    public PageBean&lt;Dept&gt; getTopDeptByPage(int page, int size);\n\n}<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.biz.impl;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport com.jackfrued.biz.DeptService;\nimport com.jackfrued.comm.PageBean;\nimport com.jackfrued.comm.QueryResult;\nimport com.jackfrued.dao.DeptDao;\nimport com.jackfrued.entity.Dept;\n\n@Service\n@Transactional  // 声明式事务的注解\npublic class DeptServiceImpl implements DeptService {\n    @Autowired\n    private DeptDao deptDao;\n\n    @Override\n    public boolean createNewDepartment(Dept department) {\n        return deptDao.save(department) != null;\n    }\n\n    @Override\n    public boolean deleteDepartment(Integer id) {\n        return deptDao.deleteById(id);\n    }\n\n    @Override\n    public PageBean&lt;Dept&gt; getTopDeptByPage(int page, int size) {\n        QueryResult&lt;Dept&gt; queryResult = deptDao.findTopDeptByPage(page, size);\n        PageBean&lt;Dept&gt; pageBean = new PageBean&lt;&gt;(page, size);\n        pageBean.transferQueryResult(queryResult);\n        return pageBean;\n    }\n\n}<br></code></pre><p><br></p><p><b><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">154、如何在Web项目中配置Spring的IoC容器？</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></b></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：如果需要在Web项目中使用Spring的IoC容器，可以在Web项目配置文件web.xml中做出如下配置</span></p><pre><code class=\"lang-java\">&lt;context-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;\n&lt;/context-param&gt;\n\n&lt;listener&gt;\n    &lt;listener-class&gt;\n        org.springframework.web.context.ContextLoaderListener\n    &lt;/listener-class&gt;\n&lt;/listener&gt;<br></code></pre><p><br></p><p><b><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">155、如何在Web项目中配置Spring MVC？</span><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">&nbsp;</span></b></p><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">答：要使用Spring MVC需要在Web项目配置文件中配置其前端控制器DispatcherServlet，如下所示：</span></p><pre><code class=\"lang-java\">&lt;web-app&gt;\n\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;example&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;\n            org.springframework.web.servlet.DispatcherServlet\n        &lt;/servlet-class&gt;\n        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n    &lt;/servlet&gt;\n\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;example&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n\n&lt;/web-app&gt;</code></pre><blockquote><p style=\"text-align: justify;\">说明：上面的配置中使用了*.html的后缀映射，这样做一方面不能够通过URL推断采用了何种服务器端的技术，另一方面可以欺骗搜索引擎，因为搜索引擎不会搜索动态页面，这种做法称为伪静态化。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>156、Spring MVC的工作原理是怎样的？&nbsp;</b><br>答：Spring MVC的工作原理如下图所示：&nbsp;<br><img src=\"https://img-blog.csdn.net/20150414170229132\" alt=\"这里写图片描述\">&nbsp;<br>① 客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。&nbsp;<br>② DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。&nbsp;<br>③在这个地方Spring会通过HandlerAdapter对该处理器进行封装。&nbsp;<br>④ HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。&nbsp;<br>⑤ Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。&nbsp;<br>⑥ ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。&nbsp;<br>⑦ 当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。&nbsp;<br>⑧ 客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>157、如何在Spring IoC容器中配置数据源？&nbsp;</b><br>答：&nbsp;<br>DBCP配置：</p><pre><code class=\"lang-java\">&lt;bean id=\"dataSource\"\n        class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt;\n    &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/&gt;\n    &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;\n    &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;\n    &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;\n&lt;/bean&gt;\n\n&lt;context:property-placeholder location=\"jdbc.properties\"/&gt;<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">C3P0配置：</span><br></p><pre><code class=\"lang-java\">&lt;bean id=\"dataSource\"\n        class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" destroy-method=\"close\"&gt;\n    &lt;property name=\"driverClass\" value=\"${jdbc.driverClassName}\"/&gt;\n    &lt;property name=\"jdbcUrl\" value=\"${jdbc.url}\"/&gt;\n    &lt;property name=\"user\" value=\"${jdbc.username}\"/&gt;\n    &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;\n&lt;/bean&gt;\n\n&lt;context:property-placeholder location=\"jdbc.properties\"/&gt;<br></code></pre><blockquote><p style=\"text-align: justify;\">提示：&nbsp;DBCP的详细配置在第153题中已经完整的展示过了。</p></blockquote><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>158、如何配置配置事务增强？&nbsp;</b><br>答：</p><pre><code class=\"lang-java\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n     xmlns:aop=\"http://www.springframework.org/schema/aop\"\n     xmlns:tx=\"http://www.springframework.org/schema/tx\"\n     xsi:schemaLocation=\"\n     http://www.springframework.org/schema/beans\n     http://www.springframework.org/schema/beans/spring-beans.xsd\n     http://www.springframework.org/schema/tx\n     http://www.springframework.org/schema/tx/spring-tx.xsd\n     http://www.springframework.org/schema/aop\n     http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;\n\n  &lt;!-- this is the service object that we want to make transactional --&gt;\n  &lt;bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/&gt;\n\n  &lt;!-- the transactional advice --&gt;\n  &lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"&gt;\n  &lt;!-- the transactional semantics... --&gt;\n  &lt;tx:attributes&gt;\n    &lt;!-- all methods starting with \'get\' are read-only --&gt;\n    &lt;tx:method name=\"get*\" read-only=\"true\"/&gt;\n    &lt;!-- other methods use the default transaction settings (see below) --&gt;\n    &lt;tx:method name=\"*\"/&gt;\n  &lt;/tx:attributes&gt;\n  &lt;/tx:advice&gt;\n\n  &lt;!-- ensure that the above transactional advice runs for any execution\n    of an operation defined by the FooService interface --&gt;\n  &lt;aop:config&gt;\n  &lt;aop:pointcut id=\"fooServiceOperation\" \n    expression=\"execution(* x.y.service.FooService.*(..))\"/&gt;\n  &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"fooServiceOperation\"/&gt;\n  &lt;/aop:config&gt;\n\n  &lt;!-- don\'t forget the DataSource --&gt;\n  &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" \n    destroy-method=\"close\"&gt;\n  &lt;property name=\"driverClassName\" value=\"oracle.jdbc.driver.OracleDriver\"/&gt;\n  &lt;property name=\"url\" value=\"jdbc:oracle:thin:@localhost:1521:orcl\"/&gt;\n  &lt;property name=\"username\" value=\"scott\"/&gt;\n  &lt;property name=\"password\" value=\"tiger\"/&gt;\n  &lt;/bean&gt;\n\n  &lt;!-- similarly, don\'t forget the PlatformTransactionManager --&gt;\n  &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;\n  &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n  &lt;/bean&gt;\n\n  &lt;!-- other &lt;bean/&gt; definitions here --&gt;\n\n&lt;/beans&gt;<br></code></pre><p><br></p><p style=\"text-align: justify;\"><b>159、选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？&nbsp;</b><br>答：可以从以下几个方面作答：&nbsp;<br>- 非侵入式：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类。&nbsp;<br>- IoC容器：IoC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了IoC容器，程序员再也不需要自己编写工厂、单例，这一点特别符合Spring的精神\"不要重复的发明轮子\"。&nbsp;<br>- AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。&nbsp;<br>- MVC：Spring的MVC框架是非常优秀的，从各个方面都可以甩Struts 2几条街，为Web表示层提供了更好的解决方案。&nbsp;<br>- 事务管理：Spring以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。&nbsp;<br>- 其他：选择Spring框架的原因还远不止于此，Spring为Java企业级开发提供了一站式选择，你可以在需要的时候使用它的部分和全部，更重要的是，你甚至可以在感觉不到Spring存在的情况下，在你的项目中使用Spring提供的各种优秀的功能。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>160、Spring IoC容器配置Bean的方式？&nbsp;</b><br>答：&nbsp;<br>- 基于XML文件进行配置。&nbsp;<br>- 基于注解进行配置。&nbsp;<br>- 基于Java程序进行配置（Spring 3+）</p><pre><code class=\"lang-java\">package com.jackfrued.bean;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class Person {\n    private String name;\n    private int age;\n    @Autowired\n    private Car car;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public void setCar(Car car) {\n        this.car = car;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person [name=\" + name + \", age=\" + age + \", car=\" + car + \"]\";\n    }\n\n}<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.bean;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class Car {\n    private String brand;\n    private int maxSpeed;\n\n    public Car(String brand, int maxSpeed) {\n        this.brand = brand;\n        this.maxSpeed = maxSpeed;\n    }\n\n    @Override\n    public String toString() {\n        return \"Car [brand=\" + brand + \", maxSpeed=\" + maxSpeed + \"]\";\n    }\n\n}<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport com.jackfrued.bean.Car;\nimport com.jackfrued.bean.Person;\n\n@Configuration\npublic class AppConfig {\n\n    @Bean\n    public Car car() {\n        return new Car(\"Benz\", 320);\n    }\n\n    @Bean\n    public Person person() {\n        return new Person(\"骆昊\", 34);\n    }\n}<br></code></pre><pre><code class=\"lang-java\">package com.jackfrued.test;\n\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\nimport com.jackfrued.bean.Person;\nimport com.jackfrued.config.AppConfig;\n\nclass Test {\n\n    public static void main(String[] args) {\n        // TWR (Java 7+)\n        try(ConfigurableApplicationContext factory = new AnnotationConfigApplicationContext(AppConfig.class)) {\n            Person person = factory.getBean(Person.class);\n            System.out.println(person);\n        }\n    }\n}<br></code></pre><p><br></p><p style=\"text-align: justify;\"><b>161、阐述Spring框架中Bean的生命周期？&nbsp;</b><br>答：&nbsp;<br>① Spring IoC容器找到关于Bean的定义并实例化该Bean。&nbsp;<br>② Spring IoC容器对Bean进行依赖注入。&nbsp;<br>③ 如果Bean实现了BeanNameAware接口，则将该Bean的id传给setBeanName方法。&nbsp;<br>④ 如果Bean实现了BeanFactoryAware接口，则将BeanFactory对象传给setBeanFactory方法。&nbsp;<br>⑤ 如果Bean实现了BeanPostProcessor接口，则调用其postProcessBeforeInitialization方法。&nbsp;<br>⑥ 如果Bean实现了InitializingBean接口，则调用其afterPropertySet方法。&nbsp;<br>⑦ 如果有和Bean关联的BeanPostProcessors对象，则这些对象的postProcessAfterInitialization方法被调用。&nbsp;<br>⑧ 当销毁Bean实例时，如果Bean实现了DisposableBean接口，则调用其destroy方法。</p><p style=\"text-align: justify;\">162、依赖注入时如何注入集合属性？&nbsp;<br>答：可以在定义Bean属性时，通过&lt;list&gt; / &lt;set&gt; / &lt;map&gt; / &lt;props&gt;分别为其注入列表、集合、映射和键值都是字符串的映射属性。</p><p style=\"text-align: justify;\">163、Spring中的自动装配有哪些限制？&nbsp;<br>答：&nbsp;<br>- 如果使用了构造器注入或者setter注入，那么将覆盖自动装配的依赖关系。&nbsp;<br>- 基本数据类型的值、字符串字面量、类字面量无法使用自动装配来注入。&nbsp;<br>- 优先考虑使用显式的装配来进行更精确的依赖注入而不是使用自动装配。</p><p style=\"text-align: justify;\">164、在Web项目中如何获得Spring的IoC容器？&nbsp;<br>答：</p><pre><code class=\"lang-html\">WebApplicationContext ctx = \nWebApplicationContextUtils.getWebApplicationContext(servletContext);<br></code></pre><p><br></p><p style=\"text-align: justify;\"><b>165. 大型网站在架构上应当考虑哪些问题？&nbsp;</b><br>答：&nbsp;<br>- <b style=\"color: rgb(227, 55, 55);\">分层</b>：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI/RM）和Internet的TCP/IP模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。&nbsp;<br>- <b style=\"color: rgb(227, 55, 55);\">分割</b>：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。&nbsp;<br>- <span style=\"color: rgb(227, 55, 55);\">分布式</span>：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的NoSQL产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用Hadoop以及MapReduce分布式计算框架来处理。&nbsp;<br>- <span style=\"color: rgb(227, 55, 55);\"><b>集群</b></span>：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。&nbsp;<br>- <b style=\"color: rgb(227, 55, 55);\">缓存</b>：所谓<span style=\"color: rgb(227, 55, 55);\">缓存就是用空间换取时间的技术</span>，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。<span style=\"color: rgb(227, 55, 55);\">我们通常说的CDN、反向代理、热点数据都是对缓存技术的使用</span>。&nbsp;<br>- <b style=\"color: rgb(227, 55, 55);\">异步</b>：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用Ajax加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。&amp;quot；能推迟处理的都要推迟处理\"是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。&nbsp;<br>- <b style=\"color: rgb(227, 55, 55);\">冗余</b>：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。</p><p style=\"text-align: justify;\"><b>166、你用过的网站前端优化的技术有哪些？</b>&nbsp;<br>答：&nbsp;<br>① 浏览器访问优化：&nbsp;<br>- 减少HTTP请求数量：合并CSS、合并JavaScript、合并图片（CSS Sprite）&nbsp;<br>- 使用浏览器缓存：通过设置HTTP响应头中的Cache-Control和Expires属性，将CSS、JavaScript、图片等在浏览器中缓存，当这些静态资源需要更新时，可以更新HTML文件中的引用来让浏览器重新请求新的资源&nbsp;<br>- 启用压缩&nbsp;<br>- CSS前置，JavaScript后置&nbsp;<br>- 减少Cookie传输&nbsp;<br>② CDN加速：CDN（Content Distribute Network）的本质仍然是缓存，将数据缓存在离用户最近的地方，CDN通常部署在网络运营商的机房，不仅可以提升响应速度，还可以减少应用服务器的压力。当然，CDN缓存的通常都是静态资源。&nbsp;<br>③ 反向代理：反向代理相当于应用服务器的一个门面，可以保护网站的安全性，也可以实现负载均衡的功能，当然最重要的是它缓存了用户访问的热点资源，可以直接从反向代理将某些内容返回给用户浏览器。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>167、你使用过的应用服务器优化技术有哪些？&nbsp;</b><br>答：&nbsp;<br>① 分布式缓存：缓存的本质就是内存中的哈希表，如果设计一个优质的哈希函数，那么理论上哈希表读写的渐近时间复杂度为O(1)。缓存主要用来存放那些读写比很高、变化很少的数据，这样应用程序读取数据时先到缓存中读取，如果没有或者数据已经失效再去访问数据库或文件系统，并根据拟定的规则将数据写入缓存。对网站数据的访问也符合二八定律（Pareto分布，幂律分布），即80%的访问都集中在20%的数据上，如果能够将这20%的数据缓存起来，那么系统的性能将得到显著的改善。当然，使用缓存需要解决以下几个问题：&nbsp;<br>- 频繁修改的数据；&nbsp;<br>- 数据不一致与脏读；&nbsp;<br>- 缓存雪崩（可以采用分布式缓存服务器集群加以解决，<a href=\"http://memcached.org/\" target=\"_blank\">memcached</a>是广泛采用的解决方案）；&nbsp;<br>- 缓存预热；&nbsp;<br>- 缓存穿透（恶意持续请求不存在的数据）。&nbsp;<br>② 异步操作：可以使用消息队列将调用异步化，通过异步处理将短时间高并发产生的事件消息存储在消息队列中，从而起到削峰作用。电商网站在进行促销活动时，可以将用户的订单请求存入消息队列，这样可以抵御大量的并发订单请求对系统和数据库的冲击。目前，绝大多数的电商网站即便不进行促销活动，订单系统都采用了消息队列来处理。&nbsp;<br>③ 使用集群。&nbsp;<br>④ 代码优化：&nbsp;<br>- 多线程：基于Java的Web开发基本上都通过多线程的方式响应用户的并发请求，使用多线程技术在编程上要解决线程安全问题，主要可以考虑以下几个方面：A. 将对象设计为无状态对象（这和面向对象的编程观点是矛盾的，在面向对象的世界中被视为不良设计），这样就不会存在并发访问时对象状态不一致的问题。B. 在方法内部创建对象，这样对象由进入方法的线程创建，不会出现多个线程访问同一对象的问题。使用ThreadLocal将对象与线程绑定也是很好的做法，这一点在前面已经探讨过了。C. 对资源进行并发访问时应当使用合理的锁机制。&nbsp;<br>- 非阻塞I/O： 使用单线程和非阻塞I/O是目前公认的比多线程的方式更能充分发挥服务器性能的应用模式，基于Node.js构建的服务器就采用了这样的方式。Java在JDK 1.4中就引入了NIO（Non-blocking I/O）,在Servlet 3规范中又引入了异步Servlet的概念，这些都为在服务器端采用非阻塞I/O提供了必要的基础。&nbsp;<br>- 资源复用：资源复用主要有两种方式，一是单例，二是对象池，我们使用的数据库连接池、线程池都是对象池化技术，这是典型的用空间换取时间的策略，另一方面也实现对资源的复用，从而避免了不必要的创建和释放资源所带来的开销。</p><p style=\"text-align: justify;\">168、什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？&nbsp;<br>答：&nbsp;<br>- XSS（Cross Site Script，跨站脚本攻击）是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。跨站脚本攻击分有两种形式：反射型攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发布含有恶意脚本的URL就属于这种方式）和持久型攻击（将恶意脚本提交到被攻击网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行，QQ邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台）。XSS虽然不是什么新鲜玩意，但是攻击的手法却不断翻新，防范XSS主要有两方面：消毒（对危险字符进行转义）和HttpOnly（防范XSS攻击者窃取Cookie数据）。&nbsp;<br>- SQL注入攻击是注入攻击最常见的形式（此外还有OS注入攻击（Struts 2的高危漏洞就是通过OGNL实施OS注入攻击导致的）），当服务器使用请求参数构造SQL语句时，恶意的SQL被嵌入到SQL中交给数据库执行。SQL注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者想要获得表结构有多种方式：（1）如果使用开源系统搭建网站，数据库结构也是公开的（目前有很多现成的系统可以直接搭建论坛，电商网站，虽然方便快捷但是风险是必须要认真评估的）；（2）错误回显（如果将服务器的错误信息直接显示在页面上，攻击者可以通过非法参数引发页面错误从而通过错误信息了解数据库结构，Web应用应当设置友好的错误页，一方面符合最小惊讶原则，一方面屏蔽掉可能给系统带来危险的错误回显信息）；（3）盲注。防范SQL注入攻击也可以采用消毒的方式，通过正则表达式对请求参数进行验证，此外，参数绑定也是很好的手段，这样恶意的SQL会被当做SQL的参数而不是命令被执行，JDBC中的PreparedStatement就是支持参数绑定的语句对象，从性能和安全性上都明显优于Statement。&nbsp;<br>- CSRF攻击（Cross Site Request Forgery，跨站请求伪造）是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份，其原理如下图所示。防范CSRF的主要手段是识别请求者的身份，主要有以下几种方式：（1）在表单中添加令牌（token）；（2）验证码；（3）检查请求头中的Referer（前面提到防图片盗链接也是用的这种方式）。令牌和验证都具有一次消费性的特征，因此在原理上一致的，但是验证码是一种糟糕的用户体验，不是必要的情况下不要轻易使用验证码，目前很多网站的做法是如果在短时间内多次提交一个表单未获得成功后才要求提供验证码，这样会获得较好的用户体验。</p><p style=\"text-align: justify;\"><img src=\"https://img-blog.csdn.net/20150414123625761\" alt=\"这里写图片描述\"></p><blockquote><p style=\"text-align: justify;\">补充：防火墙的架设是Web安全的重要保障，<a href=\"http://www.modsecurity.org/\" target=\"_blank\">ModSecurity</a>是开源的Web防火墙中的佼佼者。企业级防火墙的架设应当有两级防火墙，Web服务器和部分应用服务器可以架设在两级防火墙之间的DMZ，而数据和资源服务器应当架设在第二级防火墙之后。</p></blockquote><p style=\"text-align: justify;\">169. 什么是领域模型(domain model)？贫血模型(anaemic domain model)和充血模型(rich domain model)有什么区别？&nbsp;<br>答：领域模型是领域内的概念类或现实世界中对象的可视化表示，又称为概念模型或分析对象模型，它专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。贫血模型是指使用的领域对象中只有setter和getter方法（POJO），所有的业务逻辑都不包含在领域对象中而是放在业务逻辑层。有人将我们这里说的贫血模型进一步划分成失血模型（领域对象完全没有业务逻辑）和贫血模型（领域对象有少量的业务逻辑），我们这里就不对此加以区分了。充血模型将大多数业务逻辑和持久化放在领域对象中，业务逻辑（业务门面）只是完成对业务逻辑的封装、事务和权限等的处理。下面两张图分别展示了贫血模型和充血模型的分层架构。</p><p style=\"text-align: justify;\">贫血模型&nbsp;<br><img src=\"https://img-blog.csdn.net/20150414123848158\" alt=\"这里写图片描述\"></p><p style=\"text-align: justify;\">充血模型&nbsp;<br><img src=\"https://img-blog.csdn.net/20150414123813701\" alt=\"这里写图片描述\"></p><p style=\"text-align: justify;\">贫血模型下组织领域逻辑通常使用事务脚本模式，让每个过程对应用户可能要做的一个动作，每个动作由一个过程来驱动。也就是说在设计业务逻辑接口的时候，每个方法对应着用户的一个操作，这种模式有以下几个有点：&nbsp;<br>- 它是一个大多数开发者都能够理解的简单过程模型（适合国内的绝大多数开发者）。&nbsp;<br>- 它能够与一个使用行数据入口或表数据入口的简单数据访问层很好的协作。&nbsp;<br>- 事务边界的显而易见，一个事务开始于脚本的开始，终止于脚本的结束，很容易通过代理（或切面）实现声明式事务。&nbsp;<br>然而，事务脚本模式的缺点也是很多的，随着领域逻辑复杂性的增加，系统的复杂性将迅速增加，程序结构将变得极度混乱。开源中国社区上有一篇很好的译文<a href=\"http://www.oschina.net/translate/how-anaemic-domain-models-cause-bad-software\" target=\"_blank\">《贫血领域模型是如何导致糟糕的软件产生》</a>对这个问题做了比较细致的阐述。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\">1<b>70. 谈一谈测试驱动开发（TDD）的好处以及你的理解。&nbsp;</b><br>答：TDD是指在编写真正的功能实现代码之前先写测试代码，然后根据需要重构实现代码。在JUnit的作者Kent Beck的大作《测试驱动开发：实战与模式解析》（Test-Driven Development: by Example）一书中有这么一段内容：“消除恐惧和不确定性是编写测试驱动代码的重要原因”。因为编写代码时的恐惧会让你小心试探，让你回避沟通，让你羞于得到反馈，让你变得焦躁不安，而TDD是消除恐惧、让Java开发者更加自信更加乐于沟通的重要手段。TDD会带来的好处可能不会马上呈现，但是你在某个时候一定会发现，这些好处包括：&nbsp;<br>- 更清晰的代码 — 只写需要的代码&nbsp;<br>- 更好的设计&nbsp;<br>- 更出色的灵活性 — 鼓励程序员面向接口编程&nbsp;<br>- 更快速的反馈 — 不会到系统上线时才知道bug的存在</p><blockquote><p style=\"text-align: justify;\">补充：敏捷软件开发的概念已经有很多年了，而且也部分的改变了软件开发这个行业，TDD也是敏捷开发所倡导的。</p></blockquote><p style=\"text-align: justify;\">TDD可以在多个层级上应用，包括单元测试（测试一个类中的代码）、集成测试（测试类之间的交互）、系统测试（测试运行的系统）和系统集成测试（测试运行的系统包括使用的第三方组件）。TDD的实施步骤是：红（失败测试）- 绿（通过测试） - 重构。关于实施TDD的详细步骤请参考另一篇文章<a href=\"http://blog.csdn.net/jackfrued/article/details/44433249\" target=\"_blank\">《测试驱动开发之初窥门径》</a>。&nbsp;<br>在使用TDD开发时，经常会遇到需要被测对象需要依赖其他子系统的情况，但是你希望将测试代码跟依赖项隔离，以保证测试代码仅仅针对当前被测对象或方法展开，这时候你需要的是测试替身。测试替身可以分为四类：&nbsp;<br>- 虚设替身：只传递但是不会使用到的对象，一般用于填充方法的参数列表&nbsp;<br>- 存根替身：总是返回相同的预设响应，其中可能包括一些虚设状态&nbsp;<br>- 伪装替身：可以取代真实版本的可用版本（比真实版本还是会差很多）&nbsp;<br>- 模拟替身：可以表示一系列期望值的对象，并且可以提供预设响应&nbsp;<br>Java世界中实现模拟替身的第三方工具非常多，包括EasyMock、Mockito、jMock等。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\">原文地址：<a href=\"https://blog.csdn.net/jackfrued/article/details/44931161\" target=\"_blank\">https://blog.csdn.net/jackfrued/article/details/44931161</a></p>', '2018-06-18 15:24:42', '/articles/10009', '0', '0', 'publish', '  这部分主要是开源Java EE框架方面的内容，包括Hibernate、MyBatis、Spring、Spring MVC等，由于Struts 2已经是明日黄花，在这里就不讨论Struts 2的面试题，如果需要了解相关内容，可以参考我', 'Java,面试,框架', 'Java面试题全集（下）—— 框架篇', '2018-12-22 21:08:38', '21', '0', '10001', '1');
INSERT INTO `article` VALUES ('10010', '1', '3', '<h1><span style=\"color: rgb(227, 55, 55);\"><b>一、JAVA基础</b></span></h1><p><b>1、 JAVA中的几种基本类型，各占用多少字节？</b></p><p style=\"text-align: justify;\"><img alt=\"1.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529391828971\" width=\"544\" height=\"249\">&nbsp;<br><br></p><p style=\"text-align: justify;\">下图单位是bit,非字节 1B=8bit&nbsp;</p><p style=\"text-align: justify;\"><img alt=\"2.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529391846748\" width=\"726\" height=\"431\"><br><br></p><h2><br></h2><p><b>2、 String能被继承吗？为什么？</b></p><p style=\"text-align: justify;\">不可以，<span style=\"color: rgb(227, 55, 55);\">因为String类有final修饰符，而final修饰的类是不能被继承的</span>，实现细节不允许改变。平常我们定义的String str=”a”;其实和String str=new String(“a”)还有差异的。</p><p style=\"text-align: justify;\">前者默认调用的是String.valueOf来返回String实例对象，至于调用哪个则取决于你的赋值，比如String num=1,调用的是&nbsp;<br>public static String valueOf(int i) {&nbsp;<br>return Integer.toString(i);&nbsp;<br>}</p><p style=\"text-align: justify;\">后者则是调用如下部分：&nbsp;<br>public String(String original) {&nbsp;<br>this.value = original.value;&nbsp;<br>this.hash = original.hash;&nbsp;<br>}&nbsp;<br>最后我们的变量都存储在一个char数组中&nbsp;<br>private final char value[];</p><p><b><br></b></p><p><b>3、 String， Stringbuffer， StringBuilder 的区别。</b></p><p style=\"text-align: justify;\">String 字符串常量(final修饰，不可被继承)，String是常量，当创建之后即不能更改。(可以通过StringBuffer和StringBuilder创建String对象(常用的两个字符串操作类)。)&nbsp;<br>StringBuffer 字符串变量（线程安全）,其也是final类别的，不允许被继承，<span style=\"color: rgb(227, 55, 55);\">其中的绝大多数方法都进行了同步处理</span>，包括常用的Append方法也做了同步处理(synchronized修饰)。其自jdk1.0起就已经出现。其toString方法会进行对象缓存，以减少元素复制开销。&nbsp;<br>public synchronized String toString() {&nbsp;<br>if (toStringCache == null) {&nbsp;<br>toStringCache = Arrays.copyOfRange(value, 0, count);&nbsp;<br>}&nbsp;<br>return new String(toStringCache, true);&nbsp;<br>}</p><p style=\"text-align: justify;\">StringBuilder 字符串变量（非线程安全）其自jdk1.5起开始出现。与StringBuffer一样都继承和实现了同样的接口和类，方法除了没使用synch修饰以外基本一致，不同之处在于最后toString的时候，会直接返回一个新对象。&nbsp;<br>public String toString() {&nbsp;<br>// Create a copy, don’t share the array&nbsp;<br>return new String(value, 0, count);&nbsp;<br>}</p><p style=\"text-align: justify;\"><br></p><p><b>4、 ArrayList 和 LinkedList 有什么区别。</b></p><p style=\"text-align: justify;\">ArrayList和LinkedList都实现了List接口，有以下的不同点：&nbsp;<br>1、ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。&nbsp;<br>2、相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。&nbsp;<br>3、LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p><p style=\"text-align: justify;\"><br></p><p><b>5、 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当 new 的时候， 他们的执行顺序。</b></p><p style=\"text-align: justify;\">此题考察的是类加载器实例化时进行的操作步骤（加载–&gt;连接-&gt;初始化）。&nbsp;<br>父类静态代变量、&nbsp;<br>父类静态代码块、&nbsp;<br>子类静态变量、&nbsp;<br>子类静态代码块、&nbsp;<br>父类非静态变量（父类实例成员变量）、&nbsp;<br>父类构造函数、&nbsp;<br>子类非静态变量（子类实例成员变量）、&nbsp;<br>子类构造函数。&nbsp;<br>测试demo：<a href=\"http://blog.csdn.net/u014042066/article/details/77574956\" target=\"_blank\">http://blog.csdn.net/u014042066/article/details/77574956</a>&nbsp;<br>参阅我的博客《深入理解类加载》：<a href=\"http://blog.csdn.net/u014042066/article/details/77394480\" target=\"_blank\">http://blog.csdn.net/u014042066/article/details/77394480</a></p><p><b><br></b></p><p><b>6、 用过哪些 Map 类，都有什么区别，HashMap 是线程安全的吗,并发下使用的 Map 是什么，他们内部原理分别是什么，比如存储方式， hashcode，扩容， 默认容量等。</b></p><p style=\"text-align: justify;\">hashMap是线程不安全的，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，采用哈希表来存储的，&nbsp;<br>参照该链接：<a href=\"https://zhuanlan.zhihu.com/p/21673805\" target=\"_blank\">https://zhuanlan.zhihu.com/p/21673805</a>&nbsp;<br>JAVA8 的 ConcurrentHashMap 为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。&nbsp;<br>参照：<a href=\"https://yq.aliyun.com/articles/36781\" target=\"_blank\">https://yq.aliyun.com/articles/36781</a></p><h2><br></h2><p><b>7、 有没有有顺序的 Map 实现类， 如果有， 他们是怎么保证有序的。</b></p><p style=\"text-align: justify;\">TreeMap和LinkedHashMap是有序的（TreeMap默认升序，LinkedHashMap则记录了插入顺序）。&nbsp;<br>参照：<a href=\"http://uule.iteye.com/blog/1522291\" target=\"_blank\">http://uule.iteye.com/blog/1522291</a></p><p><b><br></b></p><p><b>8、 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。</b></p><p style=\"text-align: justify;\">1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。&nbsp;<br>2、抽象类要被子类继承，接口要被类实现。&nbsp;<br>3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现&nbsp;<br>4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。&nbsp;<br>5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。&nbsp;<br>6、抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。&nbsp;<br>7、抽象类里可以没有抽象方法&nbsp;<br>8、如果一个类里有抽象方法，那么这个类只能是抽象类&nbsp;<br>9、抽象方法要被实现，所以不能是静态的，也不能是私有的。&nbsp;<br>10、接口可继承接口，并可多继承接口，但类只能单根继承。</p><p><b><br></b></p><p><b>9、 继承和聚合的区别在哪。</b></p><p style=\"text-align: justify;\">继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性；&nbsp;<br><img alt=\"20170825174725594.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529391884147\" width=\"293\" height=\"204\"><br><span style=\"color: rgb(227, 55, 55);\">聚合是关联关系的一种特例</span>，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分；&nbsp;<br><img alt=\"20170825174736941.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529391900740\" width=\"430\" height=\"108\"><br></p><p style=\"text-align: justify;\">参考：<a href=\"http://www.cnblogs.com/jiqing9006/p/5915023.html\" target=\"_blank\">http://www.cnblogs.com/jiqing9006/p/5915023.html</a></p><h2><br></h2><p><b>10 讲讲你理解的 nio和 bio 的区别是啥，谈谈 reactor 模型。</b></p><p style=\"text-align: justify;\">IO是面向流的，NIO是面向缓冲区的&nbsp;<br>参考：<a href=\"https://zhuanlan.zhihu.com/p/23488863\" target=\"_blank\">https://zhuanlan.zhihu.com/p/23488863</a>&nbsp;<br><a href=\"http://developer.51cto.com/art/201103/252367.htm\" target=\"_blank\">http://developer.51cto.com/art/201103/252367.htm</a>&nbsp;<br><a href=\"http://www.jianshu.com/p/3f703d3d804c\" target=\"_blank\">http://www.jianshu.com/p/3f703d3d804c</a></p><p style=\"text-align: justify;\"><br></p><p><b>11、反射的原理，反射创建类实例的三种方式是什么</b></p><p style=\"text-align: justify;\">参照：<a href=\"http://www.jianshu.com/p/3ea4a6b57f87?amp\" target=\"_blank\">http://www.jianshu.com/p/3ea4a6b57f87?amp</a></p><p style=\"text-align: justify;\"><a href=\"http://blog.csdn.net/yongjian1092/article/details/7364451\" target=\"_blank\">http://blog.csdn.net/yongjian1092/article/details/7364451</a></p><p><b><br></b></p><p><b>12、反射中，Class.forName 和 ClassLoader 区别。</b></p><p style=\"text-align: justify;\"><a href=\"https://my.oschina.net/gpzhang/blog/486743\" target=\"_blank\">https://my.oschina.net/gpzhang/blog/486743</a></p><p><b><br></b></p><p><b>13、描述动态代理的几种实现方式，分别说出相应的优缺点。</b></p><p style=\"text-align: justify;\">Jdk cglib jdk底层是利用反射机制，需要基于接口方式，这是由于&nbsp;<br>Proxy.newProxyInstance(target.getClass().getClassLoader(),&nbsp;<br>target.getClass().getInterfaces(), this);&nbsp;<br>Cglib则是基于asm框架，实现了无反射机制进行代理，利用空间来换取了时间，代理效率高于jdk&nbsp;<br><a href=\"http://lrd.ele.me/2017/01/09/dynamic_proxy/\" target=\"_blank\">http://lrd.ele.me/2017/01/09/dynamic_proxy/</a></p><p><b><br></b></p><p><b>14、动态代理与 cglib 实现的区别</b></p><p style=\"text-align: justify;\">同上（基于invocationHandler和methodInterceptor）</p><h2><br></h2><p><b>15、为什么 CGlib 方式可以对接口实现代理。</b></p><p style=\"text-align: justify;\">同上</p><h2><br></h2><p><b>16、final 的用途</b></p><p style=\"text-align: justify;\">类、变量、方法&nbsp;<br><a href=\"http://www.importnew.com/7553.html\" target=\"_blank\">http://www.importnew.com/7553.html</a></p><p><b><br></b></p><p><b>17、写出三种单例模式实现。</b></p><p style=\"text-align: justify;\">懒汉式单例，饿汉式单例，双重检查等&nbsp;<br>参考：<a href=\"https://my.oschina.net/dyyweb/blog/609021\" target=\"_blank\">https://my.oschina.net/dyyweb/blog/609021</a></p><p><b><br></b></p><p><b>18、如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。</b></p><p style=\"text-align: justify;\">同时复写hashcode和equals方法，优势可以添加自定义逻辑，且不必调用超类的实现。&nbsp;<br>参照：<a href=\"http://java-min.iteye.com/blog/1416727\" target=\"_blank\">http://java-min.iteye.com/blog/1416727</a></p><p><br></p><p><b>19、请结合 OO 设计理念，谈谈访问修饰符 public、private、protected、default 在应用设计中的作用。</b></p><p style=\"text-align: justify;\">访问修饰符，主要标示修饰块的作用域，方便隔离防护</p><pre><code>同一个类    同一个包    不同包的子类  不同包的非子类</code></pre><p style=\"text-align: justify;\">Private √&nbsp;<br>Default √ √&nbsp;<br>Protected √ √ √&nbsp;<br>Public √ √ √ √&nbsp;<br>public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不&nbsp;<br>　　　　　仅可以跨类访问，而且允许跨包（package）访问。&nbsp;<br>private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以&nbsp;<br>　　　　　及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。&nbsp;<br>protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、&nbsp;<br>　　　　　属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。&nbsp;<br>default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访&nbsp;<br>　　　　　问。</p><p><b><br></b></p><p><b>20、深拷贝和浅拷贝区别。</b></p><p style=\"text-align: justify;\"><a href=\"http://www.oschina.net/translate/java-copy-shallow-vs-deep-in-which-you-will-swim\" target=\"_blank\">http://www.oschina.net/translate/java-copy-shallow-vs-deep-in-which-you-will-swim</a></p><p><b><br></b></p><p><b>21、数组和链表数据结构描述，各自的时间复杂度</b></p><p style=\"text-align: justify;\"><a href=\"http://blog.csdn.net/snow_wu/article/details/53172721\" target=\"_blank\">http://blog.csdn.net/snow_wu/article/details/53172721</a></p><p><b><br></b></p><p><b>22、error 和 exception 的区别，CheckedException，RuntimeException 的区别</b></p><p style=\"text-align: justify;\"><a href=\"http://blog.csdn.net/woshixuye/article/details/8230407\" target=\"_blank\">http://blog.csdn.net/woshixuye/article/details/8230407</a></p><p><b><br></b></p><p><b>23、请列出 5 个运行时异常。</b></p><p style=\"text-align: justify;\">同上</p><p><b><br></b></p><p><b>24、在自己的代码中，如果创建一个 java.lang.String 对象，这个对象是否可以被类加载器加载？为什么</b></p><p style=\"text-align: justify;\">类加载无须等到“首次使用该类”时加载，jvm允许预加载某些类。。。。&nbsp;<br><a href=\"http://www.cnblogs.com/jasonstorm/p/5663864.html\" target=\"_blank\">http://www.cnblogs.com/jasonstorm/p/5663864.html</a></p><p><b><br></b></p><p><b>25、说一说你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需要重新实现这两个方法。</b></p><p style=\"text-align: justify;\">参考上边试题</p><p><b><br></b></p><p><b>26、在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题。</b></p><p style=\"text-align: justify;\">泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数，泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率&nbsp;<br><a href=\"http://baike.baidu.com/item/java%E6%B3%9B%E5%9E%8B\" target=\"_blank\">http://baike.baidu.com/item/java%E6%B3%9B%E5%9E%8B</a></p><p><b><br></b></p><p><b>27、这样的 a.hashcode() 有什么用，与 a.equals(b)有什么关系。</b></p><p style=\"text-align: justify;\">hashcode&nbsp;<br>hashcode（）方法提供了对象的hashCode值，是一个native方法，返回的默认值与System.identityHashCode(obj)一致。</p><p style=\"text-align: justify;\">通常这个值是对象头部的一部分二进制位组成的数字，具有一定的标识对象的意义存在，但绝不定于地址。</p><p style=\"text-align: justify;\">作用是：用一个数字来标识对象。比如在HashMap、HashSet等类似的集合类中，如果用某个对象本身作为Key，即要基于这个对象实现Hash的写入和查找，那么对象本身如何实现这个呢？就是基于hashcode这样一个数字来完成的，只有数字才能完成计算和对比操作。</p><p style=\"text-align: justify;\">hashcode是否唯一&nbsp;<br>hashcode只能说是标识对象，在hash算法中可以将对象相对离散开，这样就可以在查找数据的时候根据这个key快速缩小数据的范围，但hashcode不一定是唯一的，所以hash算法中定位到具体的链表后，需要循环链表，然后通过equals方法来对比Key是否是一样的。</p><p style=\"text-align: justify;\">equals与hashcode的关系&nbsp;<br>equals相等两个对象，则hashcode一定要相等。但是hashcode相等的两个对象不一定equals相等。&nbsp;<br><a href=\"https://segmentfault.com/a/1190000004520827\" target=\"_blank\">https://segmentfault.com/a/1190000004520827</a></p><p><b><br></b></p><p><b>28、有没有可能 2 个不相等的对象有相同的 hashcode。</b></p><p style=\"text-align: justify;\">有</p><p><b><br></b></p><p><b>29、Java 中的 HashSet 内部是如何工作的。</b></p><p style=\"text-align: justify;\">底层是基于hashmap实现的&nbsp;<br><a href=\"http://wiki.jikexueyuan.com/project/java-collection/hashset.html\" target=\"_blank\">http://wiki.jikexueyuan.com/project/java-collection/hashset.html</a>&nbsp;<br>什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。&nbsp;<br><a href=\"http://www.importnew.com/17964.html\" target=\"_blank\">http://www.importnew.com/17964.html</a></p><h1><span style=\"color: rgb(227, 55, 55);\"><b>二、JVM 知识</b></span></h1><p><b>1、什么情况下会发生栈内存溢出。</b></p><p style=\"text-align: justify;\">如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。&nbsp;<br>参照：<a href=\"http://wiki.jikexueyuan.com/project/java-vm/storage.html\" target=\"_blank\">http://wiki.jikexueyuan.com/project/java-vm/storage.html</a></p><h2><br></h2><p><b>2、JVM 的内存结构，Eden 和 Survivor 比例。</b></p><p style=\"text-align: justify;\"><img alt=\"20170825175141848.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529391926888\" width=\"679\" height=\"351\"><br>eden 和 survior 是按8比1分配的&nbsp;<br><a href=\"http://blog.csdn.net/lojze_ly/article/details/49456255\" target=\"_blank\">http://blog.csdn.net/lojze_ly/article/details/49456255</a></p><p><b><br></b></p><p><b>3、jvm 中一次完整的 GC 流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的jvm 参数。</b></p><p style=\"text-align: justify;\">对象诞生即新生代-&gt;eden，在进行minor gc过程中，如果依旧存活，移动到from，变成Survivor，进行标记代数，如此检查一定次数后，晋升为老年代，&nbsp;<br><a href=\"http://www.cnblogs.com/redcreen/archive/2011/05/04/2037056.html\" target=\"_blank\">http://www.cnblogs.com/redcreen/archive/2011/05/04/2037056.html</a>&nbsp;<br><a href=\"http://ifeve.com/useful-jvm-flags/\" target=\"_blank\">http://ifeve.com/useful-jvm-flags/</a>&nbsp;<br><a href=\"https://wangkang007.gitbooks.io/jvm/content/jvmcan_shu_xiang_jie.html\" target=\"_blank\">https://wangkang007.gitbooks.io/jvm/content/jvmcan_shu_xiang_jie.html</a></p><p><b><br></b></p><p><b>4、你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms，包括原理，流程，优缺点</b></p><p style=\"text-align: justify;\">Serial、parNew、ParallelScavenge、SerialOld、ParallelOld、CMS、G1&nbsp;<br><a href=\"https://wangkang007.gitbooks.io/jvm/content/chapter1.html\" target=\"_blank\">https://wangkang007.gitbooks.io/jvm/content/chapter1.html</a></p><p><b><br></b></p><p><b>5、垃圾回收算法的实现原理。</b></p><p style=\"text-align: justify;\"><a href=\"http://www.importnew.com/13493.html\" target=\"_blank\">http://www.importnew.com/13493.html</a></p><p><b><br></b></p><p><b>6、当出现了内存溢出，你怎么排错。</b></p><p style=\"text-align: justify;\">首先分析是什么类型的内存溢出，对应的调整参数或者优化代码。&nbsp;<br><a href=\"https://wangkang007.gitbooks.io/jvm/content/4jvmdiao_you.html\" target=\"_blank\">https://wangkang007.gitbooks.io/jvm/content/4jvmdiao_you.html</a></p><p><b><br></b></p><p><b>7、JVM 内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。</b></p><p style=\"text-align: justify;\">内存屏障：为了保障执行顺序和可见性的一条cpu指令&nbsp;<br>重排序：为了提高性能，编译器和处理器会对执行进行重拍&nbsp;<br>happen-before：操作间执行的顺序关系。有些操作先发生。&nbsp;<br>主内存：共享变量存储的区域即是主内存&nbsp;<br>工作内存：每个线程copy的本地内存，存储了该线程以读/写共享变量的副本&nbsp;<br><a href=\"http://ifeve.com/java-memory-model-1/\" target=\"_blank\">http://ifeve.com/java-memory-model-1/</a>&nbsp;<br><a href=\"http://www.jianshu.com/p/d3fda02d4cae\" target=\"_blank\">http://www.jianshu.com/p/d3fda02d4cae</a>&nbsp;<br><a href=\"http://blog.csdn.net/kenzyq/article/details/50918457\" target=\"_blank\">http://blog.csdn.net/kenzyq/article/details/50918457</a></p><p><b><br></b></p><p><b>8、简单说说你了解的类加载器。</b></p><p style=\"text-align: justify;\">类加载器的分类（bootstrap,ext,app,curstom），类加载的流程(load-link-init)&nbsp;<br><a href=\"http://blog.csdn.net/gjanyanlig/article/details/6818655/\" target=\"_blank\">http://blog.csdn.net/gjanyanlig/article/details/6818655/</a></p><p><b><br></b></p><p><b>9、讲讲 JAVA 的反射机制。</b></p><p style=\"text-align: justify;\">Java程序在运行状态可以动态的获取类的所有属性和方法，并实例化该类，调用方法的功能&nbsp;<br><a href=\"http://baike.baidu.com/link?url=C7p1PeLa3ploAgkfAOK-4XHE8HzQuOAB7K5GPcK_zpbAa_Aw-nO3997K1oir8N--1_wxXZfOThFrEcA0LjVP6wNOwidVTkLBzKlQVK6JvXYvVNhDWV9yF-NIOebtg1hwsnagsjUhOE2wxmiup20RRa#7\" target=\"_blank\">http://baike.baidu.com/link?url=C7p1PeLa3ploAgkfAOK-4XHE8HzQuOAB7K5GPcK_zpbAa_Aw-nO3997K1oir8N–1_wxXZfOThFrEcA0LjVP6wNOwidVTkLBzKlQVK6JvXYvVNhDWV9yF-NIOebtg1hwsnagsjUhOE2wxmiup20RRa#7</a></p><p><b><br></b></p><p><b>10、你们线上应用的 JVM 参数有哪些。</b></p><p style=\"text-align: justify;\">-server&nbsp;<br>Xms6000M&nbsp;<br>-Xmx6000M&nbsp;<br>-Xmn500M&nbsp;<br>-XX:PermSize=500M&nbsp;<br>-XX:MaxPermSize=500M&nbsp;<br>-XX:SurvivorRatio=65536&nbsp;<br>-XX:MaxTenuringThreshold=0&nbsp;<br>-Xnoclassgc&nbsp;<br>-XX:+DisableExplicitGC&nbsp;<br>-XX:+UseParNewGC&nbsp;<br>-XX:+UseConcMarkSweepGC&nbsp;<br>-XX:+UseCMSCompactAtFullCollection&nbsp;<br>-XX:CMSFullGCsBeforeCompaction=0&nbsp;<br>-XX:+CMSClassUnloadingEnabled&nbsp;<br>-XX:-CMSParallelRemarkEnabled&nbsp;<br>-XX:CMSInitiatingOccupancyFraction=90&nbsp;<br>-XX:SoftRefLRUPolicyMSPerMB=0&nbsp;<br>-XX:+PrintClassHistogram&nbsp;<br>-XX:+PrintGCDetails&nbsp;<br>-XX:+PrintGCTimeStamps&nbsp;<br>-XX:+PrintHeapAtGC&nbsp;<br>-Xloggc:log/gc.log</p><p><b><br></b></p><p><b>10、g1 和 cms 区别,吞吐量优先和响应优先的垃圾收集器选择。</b></p><p style=\"text-align: justify;\">Cms是以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现。比较占用cpu资源，切易造成碎片。&nbsp;<br>G1是面向服务端的垃圾收集器，是jdk9默认的收集器，基于标记-整理算法实现。可利用多核、多cpu，保留分代，实现可预测停顿，可控。&nbsp;<br><a href=\"http://blog.csdn.net/linhu007/article/details/48897597\" target=\"_blank\">http://blog.csdn.net/linhu007/article/details/48897597</a>&nbsp;<br>请解释如下 jvm 参数的含义：&nbsp;<br>-server -Xms512m -Xmx512m -Xss1024K&nbsp;<br>-XX:PermSize=256m -XX:MaxPermSize=512m -XX:MaxTenuringThreshold=20&nbsp;<br>XX:CMSInitiatingOccupancyFraction=80 -XX:+UseCMSInitiatingOccupancyOnly。</p><p style=\"text-align: justify;\">Server模式启动&nbsp;<br>最小堆内存512m&nbsp;<br>最大512m&nbsp;<br>每个线程栈空间1m&nbsp;<br>永久代256&nbsp;<br>最大永久代256&nbsp;<br>最大转为老年代检查次数20&nbsp;<br>Cms回收开启时机：内存占用80%&nbsp;<br>命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期</p><h1><b><span style=\"color: rgb(227, 55, 55);\">三、开源框架知识</span></b></h1><p><b>1、简单讲讲 tomcat 结构，以及其类加载器流程。</b></p><p style=\"text-align: justify;\">Server- –多个service&nbsp;<br>Container级别的：–&gt;engine–》host–&gt;context&nbsp;<br>Listenter&nbsp;<br>Connector&nbsp;<br>Logging、Naming、Session、JMX等等&nbsp;<br><img alt=\"20170825175358599.jpeg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529391947246\" width=\"900\" height=\"488\"><br>通过WebappClassLoader 加载class&nbsp;<br><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/\" target=\"_blank\">http://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/</a>&nbsp;<br><a href=\"http://blog.csdn.net/dc_726/article/details/11873343\" target=\"_blank\">http://blog.csdn.net/dc_726/article/details/11873343</a>&nbsp;<br><a href=\"http://www.cnblogs.com/xing901022/p/4574961.html\" target=\"_blank\">http://www.cnblogs.com/xing901022/p/4574961.html</a>&nbsp;<br><a href=\"http://www.jianshu.com/p/62ec977996df\" target=\"_blank\">http://www.jianshu.com/p/62ec977996df</a></p><p><b><br></b></p><p><b>2、tomcat 如何调优，涉及哪些参数。</b></p><p style=\"text-align: justify;\">硬件上选择，操作系统选择，版本选择，jdk选择，配置jvm参数，配置connector的线程数量，开启gzip压缩，trimSpaces，集群等&nbsp;<br><a href=\"http://blog.csdn.net/lifetragedy/article/details/7708724\" target=\"_blank\">http://blog.csdn.net/lifetragedy/article/details/7708724</a></p><p><b><br></b></p><p><b>3、讲讲 Spring 加载流程。</b></p><p style=\"text-align: justify;\">通过listener入口，核心是在AbstractApplicationContext的refresh方法，在此处进行装载bean工厂，bean，创建bean实例，拦截器，后置处理器等。&nbsp;<br><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/\" target=\"_blank\">https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/</a></p><p><b><br></b></p><p><b>4、讲讲 Spring 事务的传播属性。</b></p><p style=\"text-align: justify;\">七种传播属性。&nbsp;<br>事务传播行为&nbsp;<br>所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：&nbsp;<br>TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。&nbsp;<br>TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。&nbsp;<br>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。&nbsp;<br>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。&nbsp;<br>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。&nbsp;<br>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。&nbsp;<br>TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。&nbsp;<br><a href=\"https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/\" target=\"_blank\">https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/</a></p><p><b><br></b></p><p><b>5、Spring 如何管理事务的。</b></p><p style=\"text-align: justify;\">编程式和声明式&nbsp;<br>同上</p><p><b><br></b></p><p><b>6、Spring 怎么配置事务（具体说出一些关键的 xml 元素）。</b></p><p><b><br></b></p><p><b>7、说说你对 Spring 的理解，非单例注入的原理？它的生命周期？循环注入的原理， aop 的实现原理，说说 aop 中的几个术语，它们是怎么相互工作的。</b></p><p style=\"text-align: justify;\">核心组件：bean，context，core，单例注入是通过单例beanFactory进行创建，生命周期是在创建的时候通过接口实现开启，循环注入是通过后置处理器，aop其实就是通过反射进行动态代理，pointcut，advice等。&nbsp;<br>Aop相关：<a href=\"http://blog.csdn.net/csh624366188/article/details/7651702/\" target=\"_blank\">http://blog.csdn.net/csh624366188/article/details/7651702/</a></p><p><b><br></b></p><p><b>8、Springmvc 中 DispatcherServlet 初始化过程。</b></p><p style=\"text-align: justify;\">入口是web.xml中配置的ds，ds继承了HttpServletBean，FrameworkServlet，通过其中的init方法进行初始化装载bean和实例，initServletBean是实际完成上下文工作和bean初始化的方法。&nbsp;<br><a href=\"http://www.mamicode.com/info-detail-512105.html\" target=\"_blank\">http://www.mamicode.com/info-detail-512105.html</a></p><h1><b style=\"color: rgb(227, 55, 55);\"><br></b></h1><h1><b style=\"color: rgb(227, 55, 55);\">四、操作系统</b></h1><p><b>1、Linux 系统下你关注过哪些内核参数，说说你知道的。</b></p><p style=\"text-align: justify;\"><img alt=\"20170825175512427.jpeg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529391965087\" width=\"319\" height=\"249\">&nbsp;<br>Tcp/ip io cpu memory&nbsp;<br>net.ipv4.tcp_syncookies = 1&nbsp;<br>#启用syncookies&nbsp;<br>net.ipv4.tcp_max_syn_backlog = 8192&nbsp;<br>#SYN队列长度&nbsp;<br>net.ipv4.tcp_synack_retries=2&nbsp;<br>#SYN ACK重试次数&nbsp;<br>net.ipv4.tcp_fin_timeout = 30&nbsp;<br>#主动关闭方FIN-WAIT-2超时时间&nbsp;<br>net.ipv4.tcp_keepalive_time = 1200&nbsp;<br>#TCP发送keepalive消息的频度&nbsp;<br>net.ipv4.tcp_tw_reuse = 1&nbsp;<br>#开启TIME-WAIT重用&nbsp;<br>net.ipv4.tcp_tw_recycle = 1&nbsp;<br>#开启TIME-WAIT快速回收&nbsp;<br>net.ipv4.ip_local_port_range = 1024 65000&nbsp;<br>#向外连接的端口范围&nbsp;<br>net.ipv4.tcp_max_tw_buckets = 5000&nbsp;<br>#最大TIME-WAIT数量，超过立即清除&nbsp;<br>net.ipv4.tcp_syn_retries = 2&nbsp;<br>#SYN重试次数&nbsp;<br>echo “fs.file-max=65535” &gt;&gt; /etc/sysctl.conf&nbsp;<br>sysctl -p</p><p style=\"text-align: justify;\"><a href=\"http://www.haiyun.me/category/system/\" target=\"_blank\">http://www.haiyun.me/category/system/</a></p><p><b><br></b></p><p><b>2、Linux 下 IO 模型有几种，各自的含义是什么。</b></p><p style=\"text-align: justify;\">阻塞式io，非阻塞io，io复用模型，信号驱动io模型，异步io模型。&nbsp;<br><a href=\"https://yq.aliyun.com/articles/46404\" target=\"_blank\">https://yq.aliyun.com/articles/46404</a>&nbsp;<br><a href=\"https://yq.aliyun.com/articles/46402\" target=\"_blank\">https://yq.aliyun.com/articles/46402</a></p><p><b><br></b></p><p><b>3、epoll 和 poll 有什么区别。</b></p><p style=\"text-align: justify;\">select的本质是采用32个整数的32位，即32*32= 1024来标识，fd值为1-1024。当fd的值超过1024限制时，就必须修改FD_SETSIZE的大小。这个时候就可以标识32*max值范围的fd。&nbsp;<br>对于单进程多线程，每个线程处理多个fd的情况，select是不适合的。&nbsp;<br>1.所有的线程均是从1-32*max进行扫描，每个线程处理的均是一段fd值，这样做有点浪费&nbsp;<br>2.1024上限问题，一个处理多个用户的进程，fd值远远大于1024&nbsp;<br>所以这个时候应该采用poll，&nbsp;<br>poll传递的是数组头指针和该数组的长度，只要数组的长度不是很长，性能还是很不错的，因为poll一次在内核中申请4K（一个页的大小来存放fd），尽量控制在4K以内&nbsp;<br>epoll还是poll的一种优化，返回后不需要对所有的fd进行遍历，在内核中维持了fd的列表。select和poll是将这个内核列表维持在用户态，然后传递到内核中。但是只有在2.6的内核才支持。&nbsp;<br>epoll更适合于处理大量的fd ，且活跃fd不是很多的情况，毕竟fd较多还是一个串行的操作&nbsp;<br><a href=\"https://yq.aliyun.com/articles/10525\" target=\"_blank\">https://yq.aliyun.com/articles/10525</a></p><p><b><br></b></p><p><b>4、平时用到哪些 Linux 命令。</b></p><p style=\"text-align: justify;\">Ls,find,tar,tail,cp,rm,vi，grep,ps,pkill等等&nbsp;<br><a href=\"https://yq.aliyun.com/articles/69417?spm=5176.100240.searchblog.18.Zrbh9R\" target=\"_blank\">https://yq.aliyun.com/articles/69417?spm=5176.100240.searchblog.18.Zrbh9R</a></p><p><br></p><p><b>5、用一行命令查看文件的最后五行。</b></p><p style=\"text-align: justify;\">Tail -n 5 filename</p><h2><br></h2><p><b>6、用一行命令输出正在运行的 java 进程。</b></p><p style=\"text-align: justify;\">ps -ef|grep Java</p><h2><br></h2><p><b>7、介绍下你理解的操作系统中线程切换过程。</b></p><p style=\"text-align: justify;\">控制权的转换，根据优先级切换上下文（用户，寄存器，系统）&nbsp;<br><a href=\"http://www.cnblogs.com/kkshaq/p/4544426.html\" target=\"_blank\">http://www.cnblogs.com/kkshaq/p/4544426.html</a></p><h2><br></h2><p><b>8、进程和线程的区别。</b></p><p style=\"text-align: justify;\">Linux 实现并没有区分这两个概念（进程和线程）&nbsp;<br>1. 进程：程序的一次执行&nbsp;<br>2. 线程：CPU的基本调度单位&nbsp;<br>一个进程可以包含多个线程。</p><p style=\"text-align: justify;\"><a href=\"http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html\" target=\"_blank\">http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html</a></p><h1><b style=\"color: rgb(227, 55, 55);\"><br></b></h1><h1><b style=\"color: rgb(227, 55, 55);\">五、多线程</b></h1><p><b>1、多线程的几种实现方式，什么是线程安全。</b></p><p style=\"text-align: justify;\">实现runable接口，继承thread类。&nbsp;<br><a href=\"http://ifeve.com/java-multi-threading-concurrency-interview-questions-with-answers/\" target=\"_blank\">http://ifeve.com/java-multi-threading-concurrency-interview-questions-with-answers/</a></p><h2><br></h2><p><b>2、volatile 的原理，作用，能代替锁么。</b></p><p style=\"text-align: justify;\">Volatile利用内存栅栏机制来保持变量的一致性。不能代替锁，其只具备数据可见性一致性，不具备原子性。&nbsp;<br><a href=\"http://blog.csdn.net/gongzi2311/article/details/20715185\" target=\"_blank\">http://blog.csdn.net/gongzi2311/article/details/20715185</a></p><p><b><br></b></p><p><b>3、画一个线程的生命周期状态图。</b></p><p style=\"text-align: justify;\">新建，可运行，运行中， 睡眠，阻塞，等待，死亡。&nbsp;<br><img alt=\"20170825175714106.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529391979540\" width=\"550\" height=\"315\">&nbsp;<br><a href=\"http://ifeve.com/thread-status\" target=\"_blank\">http://ifeve.com/thread-status</a></p><p><b><br></b></p><p><b>4、sleep 和 wait 的区别。</b></p><p style=\"text-align: justify;\">Sleep是休眠线程，wait是等待，sleep是thread的静态方法，wait则是object的方法。&nbsp;<br>Sleep依旧持有锁，并在指定时间自动唤醒。wait则释放锁。&nbsp;<br><a href=\"http://www.jianshu.com/p/4ec3f4b3903d\" target=\"_blank\">http://www.jianshu.com/p/4ec3f4b3903d</a></p><p><b><br></b></p><p><b>5、Lock 与 Synchronized 的区别。</b></p><p style=\"text-align: justify;\">首先两者都保持了并发场景下的原子性和可见性，区别则是synchronized的释放锁机制是交由其自身控制，且互斥性在某些场景下不符合逻辑，无法进行干预，不可人为中断等。&nbsp;<br>而lock常用的则有ReentrantLock和readwritelock两者，添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。&nbsp;<br><a href=\"http://blog.csdn.net/vking_wang/article/details/9952063\" target=\"_blank\">http://blog.csdn.net/vking_wang/article/details/9952063</a></p><p><b><br></b></p><p><b>6、synchronized 的原理是什么，解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。</b></p><p style=\"text-align: justify;\">Synchronized底层是通过监视器的enter和exit实现&nbsp;<br><a href=\"https://my.oschina.net/cnarthurs/blog/847801\" target=\"_blank\">https://my.oschina.net/cnarthurs/blog/847801</a>&nbsp;<br><a href=\"http://blog.csdn.net/a314773862/article/details/54095819\" target=\"_blank\">http://blog.csdn.net/a314773862/article/details/54095819</a></p><p><b><br></b></p><p><b>7、用过哪些原子类，他们的原理是什么。</b></p><p style=\"text-align: justify;\">AtomicInteger； AtomicLong； AtomicReference； AtomicBoolean；基于CAS原语实现 ，比较并交换、加载链接/条件存储，最坏的情况下是旋转锁&nbsp;<br><a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp11234/index.html\" target=\"_blank\">https://www.ibm.com/developerworks/cn/java/j-jtp11234/index.html</a>&nbsp;<br><a href=\"http://www.jmatrix.org/java/848.html\" target=\"_blank\">http://www.jmatrix.org/java/848.html</a></p><p><b><br></b></p><p><b>8、用过线程池吗，newCache 和 newFixed 有什么区别，他们的原理简单概括下，构造函数的各个参数的含义是什么，比如 coreSize，maxsize 等。</b></p><p style=\"text-align: justify;\">newSingleThreadExecutor返回以个包含单线程的Executor,将多个任务交给此Exector时，这个线程处理完一个任务后接着处理下一个任务，若该线程出现异常，将会有一个新的线程来替代。</p><p style=\"text-align: justify;\">　　newFixedThreadPool返回一个包含指定数目线程的线程池，如果任务数量多于线程数目，那么没有没有执行的任务必须等待，直到有任务完成为止。</p><p style=\"text-align: justify;\">newCachedThreadPool根据用户的任务数创建相应的线程来处理，该线程池不会对线程数目加以限制，完全依赖于JVM能创建线程的数量，可能引起内存不足。&nbsp;<br>底层是基于ThreadPoolExecutor实现，借助reentrantlock保证并发。&nbsp;<br>coreSize核心线程数，maxsize最大线程数。&nbsp;<br><a href=\"http://ifeve.com/java-threadpoolexecutor/\" target=\"_blank\">http://ifeve.com/java-threadpoolexecutor/</a></p><p><b><br></b></p><p><b>9、线程池的关闭方式有几种，各自的区别是什么。</b></p><p style=\"text-align: justify;\">Shutdown shutdownNow tryTerminate 清空工作队列，终止线程池中各个线程，销毁线程池&nbsp;<br><a href=\"http://blog.csdn.net/xxcupid/article/details/51993235\" target=\"_blank\">http://blog.csdn.net/xxcupid/article/details/51993235</a></p><p><b><br></b></p><p><b>10、假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有 10 个线程同时调用它，如何做到。</b><br></p><p style=\"text-align: justify;\">ScheduledThreadPoolExecutor 设置定时，进行调度。&nbsp;<br>public ScheduledThreadPoolExecutor(int corePoolSize,&nbsp;<br>ThreadFactory threadFactory) {&nbsp;<br>super(corePoolSize, Integer.MAX_VALUE, 0, TimeUnit.NANOSECONDS,&nbsp;<br>new DelayedWorkQueue(), threadFactory);&nbsp;<br>}</p><p style=\"text-align: justify;\"><a href=\"http://ifeve.com/java-scheduledthreadpoolexecutor/\" target=\"_blank\">http://ifeve.com/java-scheduledthreadpoolexecutor/</a></p><p><b><br></b></p><p><b>11、spring 的 controller 是单例还是多例，怎么保证并发的安全。</b></p><p style=\"text-align: justify;\">单例&nbsp;<br>通过单例工厂 DefaultSingletonBeanRegistry实现单例&nbsp;<br>通过保AsyncTaskExecutor持安全</p><p><b><br></b></p><p><b>12、用三个线程按顺序循环打印 abc 三个字母，比如 abcabcabc。</b></p><p style=\"text-align: justify;\">public static void main(String[] args) {&nbsp;<br>final String str=”abc”;&nbsp;<br>ExecutorService executorService= Executors.newFixedThreadPool(3);&nbsp;<br>executorService.execute(new Runnable() {&nbsp;<br>@Override&nbsp;<br>public void run() {&nbsp;<br>System.out.println(“1”+str);&nbsp;<br>}&nbsp;<br>});executorService.execute(new Runnable() {&nbsp;<br>@Override&nbsp;<br>public void run() {&nbsp;<br>System.out.println(“2”+str);&nbsp;<br>}&nbsp;<br>});executorService.execute(new Runnable() {&nbsp;<br>@Override&nbsp;<br>public void run() {&nbsp;<br>System.out.println(“2”+str);&nbsp;<br>}&nbsp;<br>});&nbsp;<br>}</p><p><b><br></b></p><p><b>13、ThreadLocal 用过么，用途是什么，原理是什么，用的时候要注意什么。</b></p><p style=\"text-align: justify;\">Threadlocal底层是通过threadlocalMap进行存储键值 每个ThreadLocal类创建一个Map，然后用线程的ID作为Map的key，实例对象作为Map的value，这样就能达到各个线程的值隔离的效果。&nbsp;<br>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。&nbsp;<br>谁设置谁负责移除&nbsp;<br><a href=\"http://qifuguang.me/2015/09/02/%5BJava%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83%5D%E8%A7%A3%E5%AF%86ThreadLocal/\" target=\"_blank\">http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/</a></p><h2><br></h2><p><b>14、如果让你实现一个并发安全的链表，你会怎么做。</b></p><p style=\"text-align: justify;\">Collections.synchronizedList() ConcurrentLinkedQueue&nbsp;<br><a href=\"http://blog.csdn.net/xingjiarong/article/details/48046751\" target=\"_blank\">http://blog.csdn.net/xingjiarong/article/details/48046751</a></p><h2><br></h2><p><b>15、有哪些无锁数据结构，他们实现的原理是什么。</b></p><p style=\"text-align: justify;\">LockFree，CAS&nbsp;<br>基于jdk提供的原子类原语实现，例如AtomicReference&nbsp;<br><a href=\"http://blog.csdn.net/b_h_l/article/details/8704480\" target=\"_blank\">http://blog.csdn.net/b_h_l/article/details/8704480</a></p><h2><br></h2><p><b>16、讲讲 java 同步机制的 wait 和 notify。</b></p><p style=\"text-align: justify;\">首先这两个方法只能在同步代码块中调用，wait会释放掉对象锁，等待notify唤醒。&nbsp;<br><a href=\"http://blog.csdn.net/ithomer/article/details/7685594\" target=\"_blank\">http://blog.csdn.net/ithomer/article/details/7685594</a></p><p><b><br></b></p><p><b>17、多线程如果线程挂住了怎么办。</b></p><p style=\"text-align: justify;\">根据具体情况（sleep,wait,join等），酌情选择notifyAll，notify进行线程唤醒。&nbsp;<br><a href=\"http://blog.chinaunix.net/uid-122937-id-215913.html\" target=\"_blank\">http://blog.chinaunix.net/uid-122937-id-215913.html</a></p><p><b><br></b></p><p><b>18、countdowlatch 和 cyclicbarrier 的内部原理和用法，以及相互之间的差别。</b></p><p style=\"text-align: justify;\">CountDownLatch是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它运行一个或者多个线程一直处于等待状态。&nbsp;<br>CyclicBarrier要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。&nbsp;<br>CyclicBarrier初始化的时候，设置一个屏障数。线程调用await()方法的时候，这个线程就会被阻塞，当调用await()的线程数量到达屏障数的时候，主线程就会取消所有被阻塞线程的状态。&nbsp;<br>前者是递减，不可循环，后者是递加，可循环用&nbsp;<br>countdowlatch 基于abq cb基于ReentrantLock Condition&nbsp;<br><a href=\"http://www.jianshu.com/p/a101ae9797e3\" target=\"_blank\">http://www.jianshu.com/p/a101ae9797e3</a>&nbsp;<br><a href=\"http://blog.csdn.net/tolcf/article/details/50925145\" target=\"_blank\">http://blog.csdn.net/tolcf/article/details/50925145</a></p><p><b><br></b></p><p><b>19、使用 synchronized 修饰静态方法和非静态方法有什么区别。</b></p><p style=\"text-align: justify;\">对象锁和类锁&nbsp;<br><a href=\"https://yq.aliyun.com/articles/24226\" target=\"_blank\">https://yq.aliyun.com/articles/24226</a></p><p><b><br></b></p><p><b>20、简述 ConcurrentLinkedQueue LinkedBlockingQueue 的用处和不同之处。</b></p><p style=\"text-align: justify;\">LinkedBlockingQueue 是一个基于单向链表的、范围任意的（其实是有界的）、FIFO 阻塞队列。&nbsp;<br>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见参考资料一。&nbsp;<br><a href=\"http://ifeve.com/concurrentlinkedqueue/\" target=\"_blank\">http://ifeve.com/concurrentlinkedqueue/</a>&nbsp;<br><a href=\"http://ifeve.com/juc-linkedblockingqueue/\" target=\"_blank\">http://ifeve.com/juc-linkedblockingqueue/</a>&nbsp;<br><a href=\"http://blog.csdn.net/xiaohulunb/article/details/38932923\" target=\"_blank\">http://blog.csdn.net/xiaohulunb/article/details/38932923</a></p><p><b><br></b></p><p><b>21、导致线程死锁的原因？怎么解除线程死锁。</b></p><p style=\"text-align: justify;\">死锁问题是多线程特有的问题，它可以被认为是线程间切换消耗系统性能的一种极端情况。在死锁时，线程间相互等待资源，而又不释放自身的资源，导致无穷无尽的等待，其结果是系统任务永远无法执行完成。死锁问题是在多线程开发中应该坚决避免和杜绝的问题。&nbsp;<br>一般来说，要出现死锁问题需要满足以下条件：&nbsp;<br>1. 互斥条件：一个资源每次只能被一个线程使用。&nbsp;<br>2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。&nbsp;<br>3. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。&nbsp;<br>4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。&nbsp;<br>只要破坏死锁 4 个必要条件之一中的任何一个，死锁问题就能被解决。&nbsp;<br><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-deadlock/\" target=\"_blank\">https://www.ibm.com/developerworks/cn/java/j-lo-deadlock/</a></p><p><b><br></b></p><p><b>22、非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。</b></p><p style=\"text-align: justify;\">此问题的本质是保持顺序执行。可以使用executors</p><h1><br></h1><h1><b style=\"color: rgb(227, 55, 55);\">六、TCP 与 HTTP</b></h1><p><b>1、http1.0 和 http1.1 有什么区别。</b></p><p style=\"text-align: justify;\">HTTP 1.0主要有以下几点变化：&nbsp;<br>请求和相应可以由于多行首部字段构成&nbsp;<br>响应对象前面添加了一个响应状态行&nbsp;<br>响应对象不局限于超文本&nbsp;<br>服务器与客户端之间的连接在每次请求之后都会关闭&nbsp;<br>实现了Expires等传输内容的缓存控制&nbsp;<br>内容编码Accept-Encoding、字符集Accept-Charset等协商内容的支持&nbsp;<br>这时候开始有了请求及返回首部的概念，开始传输不限于文本（其他二进制内容）</p><p style=\"text-align: justify;\">HTTP 1.1加入了很多重要的性能优化：持久连接、分块编码传输、字节范围请求、增强的缓存机制、传输编码及请求管道。&nbsp;<br><a href=\"http://imweb.io/topic/554c5879718ba1240cc1dd8a\" target=\"_blank\">http://imweb.io/topic/554c5879718ba1240cc1dd8a</a></p><p><b><br></b></p><p><b>2、TCP 三次握手和四次挥手的流程，为什么断开连接要 4 次,如果握手只有两次，会出现什么。</b></p><ul><li><p style=\"text-align: justify;\">第一次握手(SYN=1, seq=x):</p><p style=\"text-align: justify;\">客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</p><p style=\"text-align: justify;\">发送完毕后，客户端进入&nbsp;<code>SYN_SEND</code>&nbsp;状态。</p></li><li><p style=\"text-align: justify;\">第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):</p><p style=\"text-align: justify;\">服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。&nbsp;<br>发送完毕后，服务器端进入&nbsp;<code>SYN_RCVD</code>&nbsp;状态。</p></li><li><p style=\"text-align: justify;\">第三次握手(ACK=1，ACKnum=y+1)</p><p style=\"text-align: justify;\">客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</p></li></ul><p style=\"text-align: justify;\">发送完毕后，客户端进入&nbsp;<code>ESTABLISHED</code>&nbsp;状态，当服务器端接收到这个包时，也进入&nbsp;<code>ESTABLISHED</code>&nbsp;状态，TCP 握手结束。</p><p style=\"text-align: justify;\">第一次挥手(FIN=1，seq=x)</p><p style=\"text-align: justify;\">假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p style=\"text-align: justify;\">发送完毕后，客户端进入 FIN_WAIT_1 状态。</p><p style=\"text-align: justify;\">第二次挥手(ACK=1，ACKnum=x+1)</p><p style=\"text-align: justify;\">服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p style=\"text-align: justify;\">发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。</p><p style=\"text-align: justify;\">第三次挥手(FIN=1，seq=y)</p><p style=\"text-align: justify;\">服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p><p style=\"text-align: justify;\">发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</p><p style=\"text-align: justify;\">第四次挥手(ACK=1，ACKnum=y+1)</p><p style=\"text-align: justify;\">客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。</p><p style=\"text-align: justify;\">服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p><p style=\"text-align: justify;\">客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。&nbsp;<br>两次后会重传直到超时。如果多了会有大量半链接阻塞队列。&nbsp;<br><a href=\"https://segmentfault.com/a/1190000006885287\" target=\"_blank\">https://segmentfault.com/a/1190000006885287</a>&nbsp;<br><a href=\"https://hit-alibaba.github.io/interview/basic/network/TCP.html\" target=\"_blank\">https://hit-alibaba.github.io/interview/basic/network/TCP.html</a></p><p><b><br></b></p><p><b>3、TIME_WAIT 和 CLOSE_WAIT 的区别。</b></p><p style=\"text-align: justify;\">TIME_WAIT状态就是用来重发可能丢失的ACK报文。&nbsp;<br>TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关闭。</p><h2><br></h2><p><b>4、说说你知道的几种 HTTP 响应码，比如 200, 302, 404。</b></p><p style=\"text-align: justify;\">1xx：信息，请求收到，继续处理&nbsp;<br>2xx：成功，行为被成功地接受、理解和采纳&nbsp;<br>3xx：重定向，为了完成请求，必须进一步执行的动作&nbsp;<br>4xx：客户端错误，请求包含语法错误或者请求无法实现&nbsp;<br>5xx：服务器错误，服务器不能实现一种明显无效的请求&nbsp;<br>200 ok 一切正常&nbsp;<br>302 Moved Temporatily 文件临时移出&nbsp;<br>404 not found&nbsp;<br><a href=\"https://my.oschina.net/gavinjin/blog/42856\" target=\"_blank\">https://my.oschina.net/gavinjin/blog/42856</a></p><p><b><br></b></p><p><b>5、当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。</b></p><p style=\"text-align: justify;\">Dns解析–&gt;端口分析–&gt;tcp请求–&gt;服务器处理请求–&gt;服务器响应–&gt;浏览器解析—&gt;链接关闭</p><p><b><br></b></p><p><b>6、TCP/IP 如何保证可靠性，说说 TCP 头的结构。</b></p><p style=\"text-align: justify;\">使用序号，对收到的TCP报文段进行排序以及检测重复的数据；使用校验和来检测报文段的错误；使用确认和计时器来检测和纠正丢包或延时。//TCP头部，总长度20字节&nbsp;<br>typedef struct _tcp_hdr&nbsp;<br>{&nbsp;<br>unsigned short src_port; //源端口号&nbsp;<br>unsigned short dst_port; //目的端口号&nbsp;<br>unsigned int seq_no; //序列号&nbsp;<br>unsigned int ack_no; //确认号&nbsp;<br>#if LITTLE_ENDIAN&nbsp;<br>unsigned char reserved_1:4; //保留6位中的4位首部长度&nbsp;<br>unsigned char thl:4; //tcp头部长度&nbsp;<br>unsigned char flag:6; //6位标志&nbsp;<br>unsigned char reseverd_2:2; //保留6位中的2位&nbsp;<br>#else&nbsp;<br>unsigned char thl:4; //tcp头部长度&nbsp;<br>unsigned char reserved_1:4; //保留6位中的4位首部长度&nbsp;<br>unsigned char reseverd_2:2; //保留6位中的2位&nbsp;<br>unsigned char flag:6; //6位标志&nbsp;<br>#endif&nbsp;<br>unsigned short wnd_size; //16位窗口大小&nbsp;<br>unsigned short chk_sum; //16位TCP检验和&nbsp;<br>unsigned short urgt_p; //16为紧急指针&nbsp;<br>}tcp_hdr;</p><p style=\"text-align: justify;\"><a href=\"https://zh.bywiki.com/zh-hans/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE\" target=\"_blank\">https://zh.bywiki.com/zh-hans/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE</a></p><p><b><br></b></p><p><b>7、如何避免浏览器缓存。</b></p><p style=\"text-align: justify;\">无法被浏览器缓存的请求：&nbsp;<br>HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache，或Cache-Control:max-age=0等告诉浏览器不用缓存的请求&nbsp;<br>需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的&nbsp;<br>经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》）&nbsp;<br>POST请求无法被缓存&nbsp;<br>HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存&nbsp;<br><a href=\"http://www.alloyteam.com/2012/03/web-cache-2-browser-cache/\" target=\"_blank\">http://www.alloyteam.com/2012/03/web-cache-2-browser-cache/</a></p><p><b><br></b></p><p><b>8、简述 Http 请求 get 和 post 的区别以及数据包格式。</b></p><p style=\"text-align: justify;\"><img alt=\"20170825180113222.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529392000882\" width=\"738\" height=\"438\"><br></p><p style=\"text-align: justify;\"><img alt=\"20170825180121891.jpeg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529392010694\" width=\"466\" height=\"165\">&nbsp;<br><a href=\"http://www.w3school.com.cn/tags/html_ref_httpmethods.asp\" target=\"_blank\">http://www.w3school.com.cn/tags/html_ref_httpmethods.asp</a>&nbsp;<br><a href=\"http://www.360doc.com/content/12/0612/14/8093902_217673378.shtml\" target=\"_blank\">http://www.360doc.com/content/12/0612/14/8093902_217673378.shtml</a></p><p><b><br></b></p><p><b>9、简述 HTTP 请求的报文格式。</b></p><p style=\"text-align: justify;\">参考上面</p><p><b><br></b></p><p><b>10、HTTPS 的加密方式是什么，讲讲整个加密解密流程。</b></p><p style=\"text-align: justify;\">加密方式是tls/ssl，底层是通过对称算法，非对称，hash算法实现&nbsp;<br>客户端发起HTTPS请求 –》2. 服务端的配置 –》&nbsp;<br>3. 传送证书 —》4. 客户端解析证书 5. 传送加密信息 6. 服务段解密信息 7. 传输加密后的信息 8. 客户端解密信息&nbsp;<br><a href=\"http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html\" target=\"_blank\">http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html</a></p><h1><b style=\"color: rgb(227, 55, 55);\"><br></b></h1><h1><b style=\"color: rgb(227, 55, 55);\">七、架构设计与分布式</b></h1><p><b>1、常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的。</b></p><p style=\"text-align: justify;\">Cdn缓存，redis缓存，ehcache缓存等&nbsp;<br>Cdn 图片资源 js等， redis一主一从 echcache缓存数据</p><p><b><br></b></p><p><b>2、用 java 自己实现一个 LRU。</b></p><p style=\"text-align: justify;\">final int cacheSize = 100;&nbsp;<br>Map</p><p><b><br></b></p><p><b>3、分布式集群下如何做到唯一序列号。</b></p><p style=\"text-align: justify;\">Redis生成，mongodb的objectId，zk生成&nbsp;<br><a href=\"http://www.cnblogs.com/haoxinyue/p/5208136.html\" target=\"_blank\">http://www.cnblogs.com/haoxinyue/p/5208136.html</a></p><h2><b><br></b></h2><p><b>4、设计一个秒杀系统，30 分钟没付款就自动关闭交易。</b></p><p style=\"text-align: justify;\">分流 – 限流–异步–公平性（只能参加一次）–用户体验（第几位，多少分钟，一抢完）&nbsp;<br>容错处理&nbsp;<br>Redis 队列 mysql</p><p style=\"text-align: justify;\">30分钟关闭 可以借助redis的发布订阅机制 在失效时进行后续操作，其他mq也可以&nbsp;<br><a href=\"http://www.infoq.com/cn/articles/yhd-11-11-queuing-system-design\" target=\"_blank\">http://www.infoq.com/cn/articles/yhd-11-11-queuing-system-design</a></p><p><b><br></b></p><p><b>5、如何使用 redis 和 zookeeper 实现分布式锁？有什么区别优缺点，分别适用什么场景。</b></p><p style=\"text-align: justify;\">首先分布式锁实现常见的有数据库锁(表记录)，缓存锁，基于zk（临时有序节点可以实现的）的三种</p><p style=\"text-align: justify;\">Redis适用于对性能要求特别高的场景。redis可以每秒执行10w次，内网延迟不超过1ms&nbsp;<br>缺点是数据存放于内存，宕机后锁丢失。</p><p style=\"text-align: justify;\">锁无法释放？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</p><p style=\"text-align: justify;\">非阻塞锁？使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</p><p style=\"text-align: justify;\">不可重入？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</p><p style=\"text-align: justify;\">单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</p><p style=\"text-align: justify;\"><a href=\"http://www.hollischuang.com/archives/1716\" target=\"_blank\">http://www.hollischuang.com/archives/1716</a></p><p><b><br></b></p><p><b>6、如果有人恶意创建非法连接，怎么解决。</b></p><p style=\"text-align: justify;\">可以使用filter过滤处理</p><p><b><br></b></p><p><b>7、分布式事务的原理，优缺点，如何使用分布式事务。</b></p><p style=\"text-align: justify;\">Two Phase commit协议&nbsp;<br>优点是可以管理多机事务，拥有无线扩展性 确定是易用性难，承担延时风险&nbsp;<br>JTA，atomiks等&nbsp;<br><a href=\"https://yq.aliyun.com/webinar/join/185?spm=5176.8067841.0.0.RL4GDa\" target=\"_blank\">https://yq.aliyun.com/webinar/join/185?spm=5176.8067841.0.0.RL4GDa</a></p><p><b><br></b></p><p><b>8、什么是一致性 hash。</b></p><p style=\"text-align: justify;\">一致性hash是一种分布式hash实现算法。满足平衡性 单调性 分散性 和负载。&nbsp;<br><a href=\"http://blog.csdn.net/cywosp/article/details/23397179/\" target=\"_blank\">http://blog.csdn.net/cywosp/article/details/23397179/</a></p><p><b><br></b></p><p><b>9、什么是 restful，讲讲你理解的 restful。</b></p><p style=\"text-align: justify;\">REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。&nbsp;<br><a href=\"http://baike.baidu.com/link?url=fTSAdL-EyYvTp9z7mZsCOdS3kbs4VKKAnpBLg3WS_1Z4cmLMp3S-zrjcy5wakLTO5AIoPTopWVkG-IenloPKxq\" target=\"_blank\">http://baike.baidu.com/link?url=fTSAdL-EyYvTp9z7mZsCOdS3kbs4VKKAnpBLg3WS_1Z4cmLMp3S-zrjcy5wakLTO5AIoPTopWVkG-IenloPKxq</a></p><p><b><br></b></p><p><b>10、如何设计建立和保持 100w 的长连接。</b></p><p style=\"text-align: justify;\">服务器内核调优(tcp，文件数)，客户端调优，框架选择(netty)</p><p><b><br></b></p><p><b>11、如何防止缓存雪崩。</b></p><p style=\"text-align: justify;\">缓存雪崩可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。&nbsp;<br>解决思路：&nbsp;<br>1，采用加锁计数，或者使用合理的队列数量来避免缓存失效时对数据库造成太大的压力。这种办法虽然能缓解数据库的压力，但是同时又降低了系统的吞吐量。&nbsp;<br>2，分析用户行为，尽量让失效时间点均匀分布。避免缓存雪崩的出现。&nbsp;<br>3，如果是因为某台缓存服务器宕机，可以考虑做主备，比如：redis主备，但是双缓存涉及到更新事务的问题，update可能读到脏数据，需要好好解决。</p><p style=\"text-align: justify;\"><a href=\"http://www.cnblogs.com/jinjiangongzuoshi/archive/2016/03/03/5240280.html\" target=\"_blank\">http://www.cnblogs.com/jinjiangongzuoshi/archive/2016/03/03/5240280.html</a></p><p><b><br></b></p><p><b>12、解释什么是 MESI 协议(缓存一致性)。</b></p><p style=\"text-align: justify;\">MESI是四种缓存段状态的首字母缩写，任何多核系统中的缓存段都处于这四种状态之一。我将以相反的顺序逐个讲解，因为这个顺序更合理：</p><p style=\"text-align: justify;\">失效（Invalid）缓存段，要么已经不在缓存中，要么它的内容已经过时。为了达到缓存的目的，这种状态的段将会被忽略。一旦缓存段被标记为失效，那效果就等同于它从来没被加载到缓存中。&nbsp;<br>共享（Shared）缓存段，它是和主内存内容保持一致的一份拷贝，在这种状态下的缓存段只能被读取，不能被写入。多组缓存可以同时拥有针对同一内存地址的共享缓存段，这就是名称的由来。&nbsp;<br>独占（Exclusive）缓存段，和S状态一样，也是和主内存内容保持一致的一份拷贝。区别在于，如果一个处理器持有了某个E状态的缓存段，那其他处理器就不能同时持有它，所以叫“独占”。这意味着，如果其他处理器原本也持有同一缓存段，那么它会马上变成“失效”状态。&nbsp;<br>已修改（Modified）缓存段，属于脏段，它们已经被所属的处理器修改了。如果一个段处于已修改状态，那么它在其他处理器缓存中的拷贝马上会变成失效状态，这个规律和E状态一样。此外，已修改缓存段如果被丢弃或标记为失效，那么先要把它的内容回写到内存中——这和回写模式下常规的脏段处理方式一样。</p><p><b><br></b></p><p><b>13、说说你知道的几种 HASH 算法，简单的也可以。</b></p><p style=\"text-align: justify;\">哈希(Hash)算法,即散列函数。 它是一种单向密码体制,即它是一个从明文到密文的不可逆的映射,只有加密过程,没有解密过程。 同时,哈希函数可以将任意长度的输入经过变化以后得到固定长度的输出&nbsp;<br>MD4 MD5 SHA&nbsp;<br><a href=\"http://blog.jobbole.com/106733/\" target=\"_blank\">http://blog.jobbole.com/106733/</a></p><p><b><br></b></p><p><b>14、什么是 paxos 算法。</b></p><p style=\"text-align: justify;\">Paxos算法是莱斯利·兰伯特（Leslie Lamport，就是 LaTeX 中的”La”，此人现在在微软研究院）于1990年提出的一种基于消息传递的一致性算法。</p><p style=\"text-align: justify;\"><a href=\"http://baike.baidu.com/item/Paxos%20%E7%AE%97%E6%B3%95\" target=\"_blank\">http://baike.baidu.com/item/Paxos%20%E7%AE%97%E6%B3%95</a></p><p><b><br></b></p><p><b>15、什么是 zab 协议。</b></p><p style=\"text-align: justify;\">ZAB 是 Zookeeper 原子广播协议的简称</p><p style=\"text-align: justify;\">整个ZAB协议主要包括消息广播和崩溃恢复两个过程，进一步可以分为三个阶段，分别是：</p><p style=\"text-align: justify;\">发现 Discovery&nbsp;<br>同步 Synchronization&nbsp;<br>广播 Broadcast&nbsp;<br>组成ZAB协议的每一个分布式进程，都会循环执行这三个阶段，将这样一个循环称为一个主进程周期。&nbsp;<br><a href=\"https://zzzvvvxxxd.github.io/2016/08/09/ZAB/\" target=\"_blank\">https://zzzvvvxxxd.github.io/2016/08/09/ZAB/</a></p><p><b><br></b></p><p><b>16、一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新。</b></p><p style=\"text-align: justify;\">点击编辑的时候，利用redis进行加锁setNX完了之后 expire 一下&nbsp;<br>也可以用版本号进行控制</p><p><b><br></b></p><p><b>17、线上系统突然变得异常缓慢，你如何查找问题。</b></p><p style=\"text-align: justify;\">逐级排查（网络，磁盘，内存，cpu），数据库，日志，中间件等也可通过监控工具排查。</p><p><b><br></b></p><p><b>18、说说你平时用到的设计模式。</b></p><p style=\"text-align: justify;\">单例， 代理，模板，策略，命令&nbsp;<br><a href=\"http://www.jianshu.com/p/bdf65e4afbb0\" target=\"_blank\">http://www.jianshu.com/p/bdf65e4afbb0</a></p><p><b><br></b></p><p><b>18、Dubbo 的原理，数据怎么流转的，怎么实现集群，负载均衡，服务注册和发现。重试转发，快速失败的策略是怎样的。</b></p><p style=\"text-align: justify;\">Dubbo[]是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。</p><p><b><br></b></p><p><b>19、Cluster 实现集群</b></p><p style=\"text-align: justify;\">在集群负载均衡时，Dubbo提供了多种均衡策略，缺省为random随机调用。&nbsp;<br>Random LoadBalance：随机，按权重比率设置随机概率。&nbsp;<br>RoundRobin LoadBalance：轮循，按公约后的权重比率设置轮循比率。&nbsp;<br>LeastActive LoadBalance：最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。&nbsp;<br>ConsistentHash LoadBalance：一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。&nbsp;<br>快速失败，只发起一次调用，失败立即报错。</p><p style=\"text-align: justify;\"><a href=\"https://my.oschina.net/u/1378920/blog/693374\" target=\"_blank\">https://my.oschina.net/u/1378920/blog/693374</a></p><p><b><br></b></p><p><b>20、一次 RPC 请求的流程是什么。</b></p><p style=\"text-align: justify;\">1）服务消费方（client）调用以本地调用方式调用服务；&nbsp;<br>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；&nbsp;<br>3）client stub找到服务地址，并将消息发送到服务端；&nbsp;<br>4）server stub收到消息后进行解码；&nbsp;<br>5）server stub根据解码结果调用本地的服务；&nbsp;<br>6）本地服务执行并将结果返回给server stub；&nbsp;<br>7）server stub将返回结果打包成消息并发送至消费方；&nbsp;<br>8）client stub接收到消息，并进行解码；&nbsp;<br>9）服务消费方得到最终结果。</p><p><b><br></b></p><p><b>21、异步模式的用途和意义。</b></p><p style=\"text-align: justify;\">异步模式使用与服务器多核，并发严重的场景&nbsp;<br>可提高服务吞吐量大，不容易受到冲击，可以采用并发策略，提高响应时间&nbsp;<br>缓存数据过期后的更新如何设计。&nbsp;<br>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。&nbsp;<br>命中：应用程序从cache中取数据，取到后返回。&nbsp;<br>更新：先把数据存到数据库中，成功后，再让缓存失效。</p><p><b><br></b></p><p><b>22、编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。</b></p><p style=\"text-align: justify;\"><span style=\"color: rgb(227, 55, 55);\">开闭原则</span>（Open Close Principle）&nbsp;<br>一个软件实体如类、模块和函数应该<span style=\"color: rgb(32, 147, 97);\">对扩展开放，对修改关闭</span>。&nbsp;<br><span style=\"color: rgb(227, 55, 55);\">里氏代换原则</span>（Liskov Substitution Principle）&nbsp;<br><span style=\"color: rgb(32, 147, 97);\">子类型必须能够替换掉它们的父类型。&nbsp;</span><br><span style=\"color: rgb(227, 55, 55);\">依赖倒转原则</span>（Dependence Inversion Principle）&nbsp;<br>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即<span style=\"color: rgb(32, 147, 97);\">针对接口编程</span>，不要针对实现编程&nbsp;<br><span style=\"color: rgb(227, 55, 55);\">接口隔离原则</span>（Interface Segregation Principle）&nbsp;<br>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，<span style=\"color: rgb(32, 147, 97);\">接口中的方法尽量少</span>&nbsp;<br><span style=\"color: rgb(227, 55, 55);\">组合/聚合复用原则&nbsp;</span><br>说要尽量的使用合成和聚合，而不是继承关系达到复用的目的&nbsp;<br><span style=\"color: rgb(227, 55, 55);\">迪米特法则</span>（Law Of Demeter）&nbsp;<br>迪米特法则其根本思想，是强调了类之间的松耦合，类之间的耦合越弱,越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成影响，也就是说，信息的隐藏促进了软件的复用。&nbsp;<br><span style=\"color: rgb(227, 55, 55);\">单一职责原则</span>（Single Responsibility Principle）&nbsp;<br>一个类只负责一项职责，应该仅有一个引起它变化的原因&nbsp;<br><a href=\"http://www.banzg.com/archives/225.html\" target=\"_blank\">http://www.banzg.com/archives/225.html</a></p><p><b><br></b></p><p><b>23、设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。</b></p><p style=\"text-align: justify;\">MVC 模式，即常见的 MVC 框架。&nbsp;<br>SSM SSH SSI等</p><p style=\"text-align: justify;\"><br></p><p><b>24、聊了下曾经参与设计的服务器架构。</b></p><p><b><br></b></p><p><b>25、应用服务器怎么监控性能，各种方式的区别。</b></p><p><b><br></b></p><p><b>26、如何设计一套高并发支付方案，架构如何设计。</b></p><p><b><br></b></p><p><b>27、如何实现负载均衡，有哪些算法可以实现。</b></p><p><b><br></b></p><p><b>28、Zookeeper 的用途，选举的原理是什么。</b></p><p><b><br></b></p><p><b>29、Mybatis 的底层实现原理。</b></p><p><b><br></b></p><p><b>30、请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。</b></p><p><b><br></b></p><p><b>31、请思考一个方案，实现分布式环境下的 countDownLatch。</b></p><p><b><br></b></p><p><b>32、后台系统怎么防止请求重复提交。</b></p><p style=\"text-align: justify;\">可以通过token值进行防止重复提交，存放到redis中，在表单初始化的时候隐藏在表单中，添加的时候在移除。判断这个状态即可防止重复提交。&nbsp;<br>如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。本地缓存在并发使用时的注意事项。</p><p style=\"text-align: justify;\"><br></p><p><b>33、描述一个服务从发布到被消费的详细过程。</b></p><p><b><br></b></p><p><b>34、讲讲你理解的服务治理。</b></p><p><b><br></b></p><p><b>35、如何做到接口的幂等性。</b></p><p><b><br></b></p><h1><b style=\"color: rgb(227, 55, 55);\">八、算法</b></h1><p><b>1、10 亿个数字里里面找最小的 10 个。</b></p><p><b><br></b></p><p><b>2、有 1 亿个数字，其中有 2 个是重复的，快速找到它，时间和空间要最优。</b></p><p><b><br></b></p><p><b>3、2 亿个随机生成的无序整数,找出中间大小的值。</b></p><p><b><br></b></p><p><b>4、给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。</b></p><p><b><br></b></p><p><b>5、遍历二叉树。</b></p><p><b><br></b></p><p><b>6、有 3n+1 个数字，其中 3n 个中是重复的，只有 1 个是不重复的，怎么找出来。</b></p><p><b><br></b></p><p><b>7、写一个字符串反转函数。</b></p><p><b><br></b></p><p><b>8、常用的排序算法，快排，归并、冒泡。 快排的最优时间复杂度，最差复杂度。冒泡排序的优化方案。</b></p><p><b><br></b></p><p><b>9、二分查找的时间复杂度，优势。</b></p><p><b><br></b></p><p><b>10、一个已经构建好的 TreeSet，怎么完成倒排序。</b></p><p><b><br></b></p><p><b>11、什么是 B+树，B-树，列出实际的使用场景。</b></p><h1><b><span style=\"color: rgb(227, 55, 55);\"><br></span></b></h1><h1><b><span style=\"color: rgb(227, 55, 55);\">九、数据库知识</span></b></h1><p><b>1、数据库隔离级别有哪些，各自的含义是什么，MYSQL 默认的隔离级别是是什么。</b></p><p style=\"text-align: justify;\">·未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</p><p style=\"text-align: justify;\">·提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</p><p style=\"text-align: justify;\">·可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读</p><p style=\"text-align: justify;\">·串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</p><p style=\"text-align: justify;\">MYSQL默认是RepeatedRead级别</p><p><b><br></b></p><p><b>2、MYSQL 有哪些存储引擎，各自优缺点。</b></p><p style=\"text-align: justify;\">MyISAM： 拥有较高的插入，查询速度，但不支持事务&nbsp;<br>InnoDB ：5.5版本后Mysql的默认数据库，事务型数据库的首选引擎，支持ACID事务，支持行级锁定&nbsp;<br>BDB： 源自Berkeley DB，事务型数据库的另一种选择，支持COMMIT和ROLLBACK等其他事务特性&nbsp;<br>Memory ：所有数据置于内存的存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。并且其内容会在Mysql重新启动时丢失&nbsp;<br>Merge ：将一定数量的MyISAM表联合而成一个整体，在超大规模数据存储时很有用&nbsp;<br>Archive ：非常适合存储大量的独立的，作为历史记录的数据。因为它们不经常被读取。Archive拥有高效的插入速度，但其对查询的支持相对较差&nbsp;<br>Federated： 将不同的Mysql服务器联合起来，逻辑上组成一个完整的数据库。非常适合分布式应用&nbsp;<br>Cluster/NDB ：高冗余的存储引擎，用多台数据机器联合提供服务以提高整体性能和安全性。适合数据量大，安全和性能要求高的应用&nbsp;<br>CSV： 逻辑上由逗号分割数据的存储引擎。它会在数据库子目录里为每个数据表创建一个.CSV文件。这是一种普通文本文件，每个数据行占用一个文本行。CSV存储引擎不支持索引。&nbsp;<br>BlackHole ：黑洞引擎，写入的任何数据都会消失，一般用于记录binlog做复制的中继&nbsp;<br>另外，Mysql的存储引擎接口定义良好。有兴趣的开发者通过阅读文档编写自己的存储引擎。&nbsp;<br><a href=\"http://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E\" target=\"_blank\">http://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E</a></p><p><b><br></b></p><p><b>3、高并发下，如何做到安全的修改同一行数据。</b></p><p style=\"text-align: justify;\">使用悲观锁 悲观锁本质是当前只有一个线程执行操作，结束了唤醒其他线程进行处理。&nbsp;<br>也可以缓存队列中锁定主键。</p><p><b><br></b></p><p><b>4、乐观锁和悲观锁是什么，INNODB 的行级锁有哪 2 种，解释其含义。</b></p><p style=\"text-align: justify;\">乐观锁是设定每次修改都不会冲突，只在提交的时候去检查，悲观锁设定每次修改都会冲突，持有排他锁。&nbsp;<br>行级锁分为共享锁和排他锁两种 共享锁又称读锁 排他锁又称写锁&nbsp;<br><a href=\"http://www.jianshu.com/p/f40ec03fd0e8\" target=\"_blank\">http://www.jianshu.com/p/f40ec03fd0e8</a></p><p><b><br></b></p><p><b>5、SQL 优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。</b></p><p style=\"text-align: justify;\">查看慢日志（show [session|gobal] status ），定位慢查询，查看慢查询执行计划 根据执行计划确认优化方案&nbsp;<br>Explain sql&nbsp;<br>select_type:表示select类型。常见的取值有SIMPLE（简单表，即不使用连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（union中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个SELECT）等。&nbsp;<br>talbe：输出结果集的表。&nbsp;<br>type:表的连接类型。性能由高到底：system（表中仅有一行）、const（表中最多有一个匹配行）、eq_ref、ref、ref_null、index_merge、unique_subquery、index_subquery、range、idnex等&nbsp;<br>possible_keys:查询时，可能使用的索引&nbsp;<br>key:实际使用的索引&nbsp;<br>key_len:索引字段的长度&nbsp;<br>rows：扫描行的数量&nbsp;<br>Extra：执行情况的说明和描述&nbsp;<br><a href=\"http://blog.csdn.net/hsd2012/article/details/51106285\" target=\"_blank\">http://blog.csdn.net/hsd2012/article/details/51106285</a></p><p><b><br></b></p><p><b>6、数据库会死锁吗，举一个死锁的例子，mysql 怎么解决死锁。</b></p><p style=\"text-align: justify;\">产生死锁的原因主要是：</p><p style=\"text-align: justify;\">（1）系统资源不足。&nbsp;<br>（2） 进程运行推进的顺序不合适。&nbsp;<br>（3）资源分配不当等。</p><p style=\"text-align: justify;\">如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。</p><p style=\"text-align: justify;\">产生死锁的四个必要条件：</p><p style=\"text-align: justify;\">（1） 互斥条件：一个资源每次只能被一个进程使用。&nbsp;<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。&nbsp;<br>（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。&nbsp;<br>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p><p style=\"text-align: justify;\">这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。&nbsp;<br>这里提供两个解决数据库死锁的方法：</p><p style=\"text-align: justify;\">1）重启数据库（谁用谁知道）&nbsp;<br>2）杀掉抢资源的进程：&nbsp;<br>先查哪些进程在抢资源：SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;&nbsp;<br>杀掉它们：Kill trx_mysql_thread_id；</p><p><b><br></b></p><p><b>7、MYsql 的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。</b></p><p style=\"text-align: justify;\">索引是通过复杂的算法，提高数据查询性能的手段。从磁盘io到内存io的转变&nbsp;<br>普通索引，主键，唯一，单列/多列索引建索引的几大原则&nbsp;<br>1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。&nbsp;<br>2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式&nbsp;<br>3.尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录&nbsp;<br>4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);&nbsp;<br>5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</p><p style=\"text-align: justify;\"><a href=\"http://tech.meituan.com/mysql-index.html\" target=\"_blank\">http://tech.meituan.com/mysql-index.html</a>&nbsp;<br><a href=\"http://www.cnblogs.com/cq-home/p/3482101.html\" target=\"_blank\">http://www.cnblogs.com/cq-home/p/3482101.html</a></p><p><b><br></b></p><p><b>8、聚集索引和非聚集索引的区别。</b></p><p style=\"text-align: justify;\">“聚簇”就是索引和记录紧密在一起。&nbsp;<br>非聚簇索引 索引文件和数据文件分开存放，索引文件的叶子页只保存了主键值，要定位记录还要去查找相应的数据块。</p><p><b><br></b></p><p><b>9、数据库中 BTREE 和 B+tree 区别。</b></p><p style=\"text-align: justify;\">B+是btree的变种，本质都是btree，btree+与B-Tree相比，B+Tree有以下不同点：&nbsp;<br>每个节点的指针上限为2d而不是2d+1。&nbsp;<br>内节点不存储data，只存储key；叶子节点不存储指针。</p><p style=\"text-align: justify;\"><a href=\"http://lcbk.net/9602.html\" target=\"_blank\">http://lcbk.net/9602.html</a>&nbsp;<br>Btree 怎么分裂的，什么时候分裂，为什么是平衡的。&nbsp;<br>Key 超过1024才分裂B树为甚会分裂？ 因为随着数据的增多，一个结点的key满了，为了保持B树的特性，就会产生分裂，就向红黑树和AVL树为了保持树的性质需要进行旋转一样！</p><p><b><br></b></p><p><b>10、ACID 是什么。</b></p><p style=\"text-align: justify;\">A，atomic，原子性，要么都提交，要么都失败，不能一部分成功，一部分失败。&nbsp;<br>C，consistent，一致性，事物开始及结束后，数据的一致性约束没有被破坏&nbsp;<br>I，isolation，隔离性，并发事物间相互不影响，互不干扰。&nbsp;<br>D，durability,持久性，已经提交的事物对数据库所做的更新必须永久保存。即便发生崩溃，也不能被回滚或数据丢失。</p><p><b><br></b></p><p><b>11、Mysql 怎么优化 table scan 的。</b></p><p style=\"text-align: justify;\">避免在where子句中对字段进行is null判断&nbsp;<br>应尽量避免在where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。&nbsp;<br>避免在where 子句中使用or 来连接条件&nbsp;<br>in 和not in 也要慎用&nbsp;<br>Like查询（非左开头）&nbsp;<br>使用NUM=@num参数这种&nbsp;<br>where 子句中对字段进行表达式操作num/2=XX&nbsp;<br>在where子句中对字段进行函数操作</p><p><b><br></b></p><p><b>12、如何写 sql 能够有效的使用到复合索引。</b></p><p style=\"text-align: justify;\">由于复合索引的组合索引，类似多个木板拼接在一起，如果中间断了就无法用了，所以要能用到复合索引，首先开头(第一列)要用上，比如index(a,b) 这种，我们可以select table tname where a=XX 用到第一列索引 如果想用第二列 可以 and b=XX 或者and b like‘TTT%’</p><p><b><br></b></p><p><b>13、mysql 中 in 和 exists 区别。</b></p><p style=\"text-align: justify;\">mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p><p style=\"text-align: justify;\">如果查询的两个表大小相当，那么用in和exists差别不大。&nbsp;<br>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in：&nbsp;<br>not in 和not exists如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。&nbsp;<br>1.EXISTS只返回TRUE或FALSE，不会返回UNKNOWN。</p><p style=\"text-align: justify;\">2.IN当遇到包含NULL的情况，那么就会返回UNKNOWN。</p><p><b><br></b></p><p><b>14、数据库自增主键可能的问题。</b></p><p style=\"text-align: justify;\">在分库分表时可能会生成重复主键 利用自增比例达到唯一 自增1 2,3 等&nbsp;<br><a href=\"https://yq.aliyun.com/articles/38438\" target=\"_blank\">https://yq.aliyun.com/articles/38438</a></p><h1><br></h1><h1><b style=\"color: rgb(227, 55, 55);\">十、消息队列</b></h1><p><b>1、用过哪些 MQ，和其他 mq 比较有什么优缺点，MQ 的连接是线程安全的吗，你们公司的MQ 服务架构怎样的。</b></p><p style=\"text-align: justify;\">根据实际情况说明&nbsp;<br>我们公司用activeMQ 因为业务比较简单 只有转码功能，而amq比较简单&nbsp;<br>如果是分布式的建议用kafka&nbsp;<br><a href=\"http://blog.csdn.net/sunxinhere/article/details/7968886\" target=\"_blank\">http://blog.csdn.net/sunxinhere/article/details/7968886</a></p><p><b><br></b></p><p><b>2、MQ 系统的数据如何保证不丢失。</b></p><p style=\"text-align: justify;\">基本都是对数据进行持久化，多盘存储</p><p><b><br></b></p><p><b>3、rabbitmq 如何实现集群高可用。</b></p><p style=\"text-align: justify;\">集群是保证服务可靠性的一种方式，同时可以通过水平扩展以提升消息吞吐能力。RabbitMQ是用分布式程序设计语言erlang开发的，所以天生就支持集群。接下来，将介绍RabbitMQ分布式消息处理方式、集群模式、节点类型，并动手搭建一个高可用集群环境，最后通过java程序来验证集群的高可用性。</p><p style=\"text-align: justify;\">　　1. 三种分布式消息处理方式</p><p style=\"text-align: justify;\">　　RabbitMQ分布式的消息处理方式有以下三种：</p><p style=\"text-align: justify;\">　　1、Clustering：不支持跨网段，各节点需运行同版本的Erlang和RabbitMQ, 应用于同网段局域网。</p><p style=\"text-align: justify;\">　　2、Federation：允许单台服务器上的Exchange或Queue接收发布到另一台服务器上Exchange或Queue的消息, 应用于广域网，。</p><p style=\"text-align: justify;\">　　3、Shovel：与Federation类似，但工作在更低层次。</p><p style=\"text-align: justify;\">　　RabbitMQ对网络延迟很敏感，在LAN环境建议使用clustering方式;在WAN环境中，则使用Federation或Shovel。我们平时说的RabbitMQ集群，说的就是clustering方式，它是RabbitMQ内嵌的一种消息处理方式，而Federation或Shovel则是以plugin形式存在。&nbsp;<br><a href=\"https://my.oschina.net/jiaoyanli/blog/822011\" target=\"_blank\">https://my.oschina.net/jiaoyanli/blog/822011</a>&nbsp;<br><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-RabbitMQ/\" target=\"_blank\">https://www.ibm.com/developerworks/cn/opensource/os-cn-RabbitMQ/</a></p><p><b><br></b></p><h1><b><span style=\"color: rgb(227, 55, 55);\">十一、Redis，Memcached</span></b></h1><p><b>1、redis 的 list 结构相关的操作。</b></p><p style=\"text-align: justify;\">LPUSH LPUSHX RPUSH RPUSHX LPOP RPOP BLPOP BRPOP LLEN LRANGE&nbsp;<br><a href=\"https://redis.readthedocs.io/en/2.4/list.html\" target=\"_blank\">https://redis.readthedocs.io/en/2.4/list.html</a></p><p><b><br></b></p><p><b>2、Redis 的数据结构都有哪些。</b></p><p style=\"text-align: justify;\">字符串(strings)：存储整数（比如计数器）和字符串（废话。。），有些公司也用来存储json/pb等序列化数据，并不推荐，浪费内存&nbsp;<br>哈希表(hashes)：存储配置，对象（比如用户、商品），优点是可以存取部分key，对于经常变化的或者部分key要求atom操作的适合&nbsp;<br>列表(lists)：可以用来存最新用户动态，时间轴，优点是有序，确定是元素可重复，不去重&nbsp;<br>集合(sets)：无序，唯一，对于要求严格唯一性的可以使用&nbsp;<br>有序集合(sorted sets)：集合的有序版，很好用，对于排名之类的复杂场景可以考虑<a href=\"https://redis.readthedocs.io/en/2.4/list.html\" target=\"_blank\">https://redis.readthedocs.io/en/2.4/list.html</a></p><p><b><br></b></p><p><b>3、Redis 的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。</b></p><p style=\"text-align: justify;\">持久化方式：RDB时间点快照 AOF记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。&nbsp;<br>内存设置 maxmemory used_memory&nbsp;<br>虚拟内存： vm-enabled yes&nbsp;<br>3.0采用Cluster方式，&nbsp;<br>Redis集群相对单机在功能上存在一些限制， 需要开发人员提前了解，&nbsp;<br>在使用时做好规避。 限制如下：&nbsp;<br>1） key批量操作支持有限。 如mset、 mget， 目前只支持具有相同slot值的&nbsp;<br>ke&nbsp;<br>y执&nbsp;<br>行批量操作。 对于映射为不同slot值的key由于执行mget、 mget等操作可&nbsp;<br>能存在于多个节点上因此不被支持。&nbsp;<br>2） key事务操作支持有限。 同理只支持多key在同一节点上的事务操&nbsp;<br>作， 当多个key分布在不同的节点上时无法使用事务功能。&nbsp;<br>3） key作为数据分区的最小粒度， 因此不能将一个大的键值对象如&nbsp;<br>ha&nbsp;<br>sh、 list等映射到不同的节点。&nbsp;<br>4） 不支持多数据库空间。 单机下的Redis可以支持16个数据库， 集群模&nbsp;<br>式下只能使用一个数据库空间， 即db0。&nbsp;<br>5） 复制结构只支持一层， 从节点只能复制主节点， 不支持嵌套树状复&nbsp;<br>制结构。&nbsp;<br>Redis Cluster是Redis的分布式解决方案， 在3.0版本正式推出， 有效地解&nbsp;<br>决了Redis分布式方面的需求。 当遇到单机内存、 并发、 流量等瓶颈时， 可&nbsp;<br>以采用Cluster架构方案达到负载均衡的目的。 之前， Redis分布式方案一般&nbsp;<br>有两种：&nbsp;<br>·客户端分区方案， 优点是分区逻辑可控， 缺点是需要自己处理数据路&nbsp;<br>由、 高可用、 故障转移等问题。&nbsp;<br>·代理方案， 优点是简化客户端分布式逻辑和升级维护便利， 缺点是加&nbsp;<br>重架构部署复杂度和性能损耗。&nbsp;<br>现在官方为我们提供了专有的集群方案： Redis Cluster， 它非常优雅地&nbsp;<br>解决了Redis集群方面的问题， 因此理解应用好Redis Cluster将极大地解放我&nbsp;<br>们使用分布式Redis的工作量， 同时它也是学习分布式存储的绝佳案例。</p><p style=\"text-align: justify;\">LRU(近期最少使用算法)TTL（超时算法） 去除ttl最大的键值&nbsp;<br><a href=\"http://wiki.jikexueyuan.com/project/redis/data-elimination-mechanism.html\" target=\"_blank\">http://wiki.jikexueyuan.com/project/redis/data-elimination-mechanism.html</a>&nbsp;<br><a href=\"http://www.infoq.com/cn/articles/tq-redis-memory-usage-optimization-storage\" target=\"_blank\">http://www.infoq.com/cn/articles/tq-redis-memory-usage-optimization-storage</a>&nbsp;<br><a href=\"http://www.redis.cn/topics/cluster-tutorial.html\" target=\"_blank\">http://www.redis.cn/topics/cluster-tutorial.html</a></p><p><b><br></b></p><p><b>4、redis2 和 redis3 的区别，redis3 内部通讯机制。</b></p><p style=\"text-align: justify;\">集群方式的区别，3采用Cluster，2采用客户端分区方案和代理方案&nbsp;<br>通信过程说明：&nbsp;<br>1） 集群中的每个节点都会单独开辟一个TCP通道， 用于节点之间彼此&nbsp;<br>通信， 通信端口号在基础端口上加10000。&nbsp;<br>2） 每个节点在固定周期内通过特定规则选择几个节点发送ping消息。&nbsp;<br>3） 接收到ping消息的节点用pong消息作为响应。</p><p><b><br></b></p><p><b>5、当前 redis 集群有哪些玩法，各自优缺点，场景。</b></p><p style=\"text-align: justify;\">当缓存使用 持久化使用</p><p><b><br></b></p><p><b>6、Memcache 的原理，哪些数据适合放在缓存中。</b></p><p style=\"text-align: justify;\">基于libevent的事件处理&nbsp;<br>内置内存存储方式SLab Allocation机制&nbsp;<br>并不单一的数据删除机制&nbsp;<br>基于客户端的分布式系统</p><p style=\"text-align: justify;\">变化频繁，具有不稳定性的数据,不需要实时入库, (比如用户在线&nbsp;<br>状态、在线人数..)&nbsp;<br>门户网站的新闻等，觉得页面静态化仍不能满足要求，可以放入&nbsp;<br>到memcache中.(配合jquey的ajax请求)</p><p><b><br></b></p><p><b>7、redis 和 memcached 的内存管理的区别。</b></p><p style=\"text-align: justify;\">Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。&nbsp;<br>Redis的内存管理主要通过源码中zmalloc.h和zmalloc.c两个文件来实现的。&nbsp;<br>在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别。&nbsp;<br><a href=\"http://lib.csdn.net/article/redis/55323\" target=\"_blank\">http://lib.csdn.net/article/redis/55323</a></p><p><b><br></b></p><p><b>8、Redis 的并发竞争问题如何解决，了解 Redis 事务的 CAS 操作吗。</b></p><p style=\"text-align: justify;\">Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：</p><p style=\"text-align: justify;\">1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</p><p style=\"text-align: justify;\">2.服务器角度，利用setnx实现锁。</p><p style=\"text-align: justify;\">MULTI，EXEC，DISCARD，WATCH 四个命令是 Redis 事务的四个基础命令。其中：</p><p style=\"text-align: justify;\">MULTI，告诉 Redis 服务器开启一个事务。注意，只是开启，而不是执行&nbsp;<br>EXEC，告诉 Redis 开始执行事务&nbsp;<br>DISCARD，告诉 Redis 取消事务&nbsp;<br>WATCH，监视某一个键值对，它的作用是在事务执行之前如果监视的键值被修改，事务会被取消。&nbsp;<br>可以利用watch实现cas乐观锁&nbsp;<br><a href=\"http://wiki.jikexueyuan.com/project/redis/transaction-mechanism.html\" target=\"_blank\">http://wiki.jikexueyuan.com/project/redis/transaction-mechanism.html</a>&nbsp;<br><a href=\"http://www.jianshu.com/p/d777eb9f27df\" target=\"_blank\">http://www.jianshu.com/p/d777eb9f27df</a></p><p><b><br></b></p><p><b>9、Redis 的选举算法和流程是怎样的</b></p><p style=\"text-align: justify;\">Raft采用心跳机制触发Leader选举。系统启动后，全部节点初始化为Follower，term为0.节点如果收到了RequestVote或者AppendEntries，就会保持自己的Follower身份。如果一段时间内没收到AppendEntries消息直到选举超时，说明在该节点的超时时间内还没发现Leader，Follower就会转换成Candidate，自己开始竞选Leader。一旦转化为Candidate，该节点立即开始下面几件事情：</p><p style=\"text-align: justify;\">1、增加自己的term。&nbsp;<br>2、启动一个新的定时器。&nbsp;<br>3、给自己投一票。&nbsp;<br>4、向所有其他节点发送RequestVote，并等待其他节点的回复。&nbsp;<br>如果在这过程中收到了其他节点发送的AppendEntries，就说明已经有Leader产生，自己就转换成Follower，选举结束。</p><p style=\"text-align: justify;\">如果在计时器超时前，节点收到多数节点的同意投票，就转换成Leader。同时向所有其他节点发送AppendEntries，告知自己成为了Leader。</p><p style=\"text-align: justify;\">每个节点在一个term内只能投一票，采取先到先得的策略，Candidate前面说到已经投给了自己，Follower会投给第一个收到RequestVote的节点。每个Follower有一个计时器，在计时器超时时仍然没有接受到来自Leader的心跳RPC, 则自己转换为Candidate, 开始请求投票，就是上面的的竞选Leader步骤。</p><p style=\"text-align: justify;\">如果多个Candidate发起投票，每个Candidate都没拿到多数的投票（Split Vote），那么就会等到计时器超时后重新成为Candidate，重复前面竞选Leader步骤。</p><p style=\"text-align: justify;\">Raft协议的定时器采取随机超时时间，这是选举Leader的关键。每个节点定时器的超时时间随机设置，随机选取配置时间的1倍到2倍之间。由于随机配置，所以各个Follower同时转成Candidate的时间一般不一样，在同一个term内，先转为Candidate的节点会先发起投票，从而获得多数票。多个节点同时转换为Candidate的可能性很小。即使几个Candidate同时发起投票，在该term内有几个节点获得一样高的票数，只是这个term无法选出Leader。由于各个节点定时器的超时时间随机生成，那么最先进入下一个term的节点，将更有机会成为Leader。连续多次发生在一个term内节点获得一样高票数在理论上几率很小，实际上可以认为完全不可能发生。一般1-2个term类，Leader就会被选出来。</p><p style=\"text-align: justify;\">Sentinel的选举流程</p><p style=\"text-align: justify;\">Sentinel集群正常运行的时候每个节点epoch相同，当需要故障转移的时候会在集群中选出Leader执行故障转移操作。Sentinel采用了Raft协议实现了Sentinel间选举Leader的算法，不过也不完全跟论文描述的步骤一致。Sentinel集群运行过程中故障转移完成，所有Sentinel又会恢复平等。Leader仅仅是故障转移操作出现的角色。</p><p style=\"text-align: justify;\">选举流程</p><p style=\"text-align: justify;\">1、某个Sentinel认定master客观下线的节点后，该Sentinel会先看看自己有没有投过票，如果自己已经投过票给其他Sentinel了，在2倍故障转移的超时时间自己就不会成为Leader。相当于它是一个Follower。&nbsp;<br>2、如果该Sentinel还没投过票，那么它就成为Candidate。&nbsp;<br>3、和Raft协议描述的一样，成为Candidate，Sentinel需要完成几件事情&nbsp;<br>1）更新故障转移状态为start&nbsp;<br>2）当前epoch加1，相当于进入一个新term，在Sentinel中epoch就是Raft协议中的term。&nbsp;<br>3）更新自己的超时时间为当前时间随机加上一段时间，随机时间为1s内的随机毫秒数。&nbsp;<br>4）向其他节点发送is-master-down-by-addr命令请求投票。命令会带上自己的epoch。&nbsp;<br>5）给自己投一票，在Sentinel中，投票的方式是把自己master结构体里的leader和leader_epoch改成投给的Sentinel和它的epoch。&nbsp;<br>4、其他Sentinel会收到Candidate的is-master-down-by-addr命令。如果Sentinel当前epoch和Candidate传给他的epoch一样，说明他已经把自己master结构体里的leader和leader_epoch改成其他Candidate，相当于把票投给了其他Candidate。投过票给别的Sentinel后，在当前epoch内自己就只能成为Follower。&nbsp;<br>5、Candidate会不断的统计自己的票数，直到他发现认同他成为Leader的票数超过一半而且超过它配置的quorum（quorum可以参考《redis sentinel设计与实现》）。Sentinel比Raft协议增加了quorum，这样一个Sentinel能否当选Leader还取决于它配置的quorum。&nbsp;<br>6、如果在一个选举时间内，Candidate没有获得超过一半且超过它配置的quorum的票数，自己的这次选举就失败了。&nbsp;<br>7、如果在一个epoch内，没有一个Candidate获得更多的票数。那么等待超过2倍故障转移的超时时间后，Candidate增加epoch重新投票。&nbsp;<br>8、如果某个Candidate获得超过一半且超过它配置的quorum的票数，那么它就成为了Leader。&nbsp;<br>9、与Raft协议不同，Leader并不会把自己成为Leader的消息发给其他Sentinel。其他Sentinel等待Leader从slave选出master后，检测到新的master正常工作后，就会去掉客观下线的标识，从而不需要进入故障转移流程。&nbsp;<br><a href=\"http://weizijun.cn/2015/04/30/Raft%E5%8D%8F%E8%AE%AE%E5%AE%9E%E6%88%98%E4%B9%8BRedis%20Sentinel%E7%9A%84%E9%80%89%E4%B8%BELeader%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/\" target=\"_blank\">http://weizijun.cn/2015/04/30/Raft%E5%8D%8F%E8%AE%AE%E5%AE%9E%E6%88%98%E4%B9%8BRedis%20Sentinel%E7%9A%84%E9%80%89%E4%B8%BELeader%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></p><p><b><br></b></p><p><b>10、redis 的持久化的机制，aof 和 rdb 的区别。</b></p><p style=\"text-align: justify;\">RDB 定时快照方式(snapshot)： 定时备份，可能会丢失数据&nbsp;<br>AOF 基于语句追加方式 只追加写操作&nbsp;<br>AOF 持久化和 RDB 持久化的最主要区别在于，前者记录了数据的变更，而后者是保存了数据本身</p><p><b><br></b></p><p><b>11、redis 的集群怎么同步的数据的。</b></p><p style=\"text-align: justify;\">redis replication redis-migrate-tool等方式</p><h1><b style=\"color: rgb(227, 55, 55);\"><br></b></h1><h1><b style=\"color: rgb(227, 55, 55);\">十二、搜索</b></h1><h2>1、elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段。elasticsearch 的倒排索引是什么。</h2><p style=\"text-align: justify;\">ElasticSearch（简称ES）是一个分布式、Restful的搜索及分析服务器，设计用于分布式计算；能够达到实时搜索，稳定，可靠，快速。和Apache Solr一样，它也是基于Lucence的索引服务器，而ElasticSearch对比Solr的优点在于：</p><pre><code>轻量级：安装启动方便，下载文件之后一条命令就可以启动。\nSchema free：可以向服务器提交任意结构的JSON对象，Solr中使用schema.xml指定了索引结构。\n多索引文件支持：使用不同的index参数就能创建另一个索引文件，Solr中需要另行配置。\n分布式：Solr Cloud的配置比较复杂。\n</code></pre><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li></ul><p style=\"text-align: justify;\">倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。</p><p><b><br></b></p><p><b>2、elasticsearch 索引数据多了怎么办，如何调优，部署。</b></p><p style=\"text-align: justify;\">使用bulk API&nbsp;<br>初次索引的时候，把 replica 设置为 0&nbsp;<br>增大 threadpool.index.queue_size&nbsp;<br>增大 indices.memory.index_buffer_size&nbsp;<br>增大 index.translog.flush_threshold_ops&nbsp;<br>增大 index.translog.sync_interval&nbsp;<br>增大 index.engine.robin.refresh_interval&nbsp;<br><a href=\"http://www.jianshu.com/p/5eeeeb4375d4\" target=\"_blank\">http://www.jianshu.com/p/5eeeeb4375d4</a></p><p><b><br></b></p><p><b>3、lucence 内部结构是什么</b></p><p style=\"text-align: justify;\">索引(Index)：&nbsp;<br>在Lucene中一个索引是放在一个文件夹中的。&nbsp;<br>如上图，同一文件夹中的所有的文件构成一个Lucene索引。&nbsp;<br>段(Segment)：&nbsp;<br>一个索引可以包含多个段，段与段之间是独立的，添加新文档可以生成新的段，不同的段可以合并。&nbsp;<br>如上图，具有相同前缀文件的属同一个段，图中共三个段 “_0” 和 “_1”和“_2”。&nbsp;<br>segments.gen和segments_X是段的元数据文件，也即它们保存了段的属性信息。&nbsp;<br>文档(Document)：&nbsp;<br>文档是我们建索引的基本单位，不同的文档是保存在不同的段中的，一个段可以包含多篇文档。&nbsp;<br>新添加的文档是单独保存在一个新生成的段中，随着段的合并，不同的文档合并到同一个段中。&nbsp;<br>域(Field)：&nbsp;<br>一篇文档包含不同类型的信息，可以分开索引，比如标题，时间，正文，作者等，都可以保存在不同的域里。&nbsp;<br>不同域的索引方式可以不同，在真正解析域的存储的时候，我们会详细解读。&nbsp;<br>词(Term)：&nbsp;<br>词是索引的最小单位，是经过词法分析和语言处理后的字符串。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\">原文地址：<a href=\"https://blog.csdn.net/weixin_38399962/article/details/80358168\" target=\"_blank\">https://blog.csdn.net/weixin_38399962/article/details/80358168</a></p>', '2018-06-18 22:21:18', '/articles/10010', '0', '1', 'publish', '一、JAVA基础1、 JAVA中的几种基本类型，各占用多少字节？<img alt=\"', 'Java,面试', '2018JAVA面试题复习附答案汇总', '2019-04-08 21:53:09', '63', '1', '10001', '1');
INSERT INTO `article` VALUES ('10011', '0', '0', '<p style=\"margin-left: auto;\">相信String这个类是Java中使用得最频繁的类之一，并且又是各大公司面试喜欢问到的地方，今天就来和大家一起学习一下String、StringBuilder和StringBuffer这几个类，分析它们的异同点以及了解各个类适用的场景。下面是本文的目录大纲：</p><p style=\"margin-left: auto;\"><b>　　一.你了解String类吗？</b></p><p style=\"margin-left: auto;\"><b>　　二.深入理解String、StringBuffer、StringBuilder</b></p><p style=\"margin-left: auto;\"><b>　　三.不同场景下三个类的性能测试</b></p><p style=\"margin-left: auto;\"><b>　　四.常见的关于String、StringBuffer的面试题（辟谣网上流传的一些曲解String类的说法）</b></p><p style=\"margin-left: auto;\">　　若有不正之处，请多多谅解和指正，不胜感激。</p><p style=\"margin-left: auto;\">　　请尊重作者劳动成果，转载请标明转载地址：</p><p style=\"margin-left: auto;\">&nbsp;　　<a href=\"http://www.cnblogs.com/dolphin0520/p/3778589.html\">http://www.cnblogs.com/dolphin0520/p/3778589.html</a></p><p style=\"margin-left: auto;\"><br></p><h2><b style=\"color: rgb(227, 55, 55);\">一、你了解String类吗？</b></h2><p style=\"margin-left: auto;\">　想要了解一个类，最好的办法就是看这个类的实现源代码，String类的实现在</p><p style=\"margin-left: auto;\">　　\\jdk1.6.0_14\\src\\java\\lang\\String.java&nbsp;&nbsp; 文件中。</p><p style=\"margin-left: auto;\">　　打开这个类文件就会发现String类是被final修饰的：</p><pre><code class=\"lang-java\">public&nbsp;final&nbsp;class&nbsp;String\n&nbsp;&nbsp;&nbsp;&nbsp;implements&nbsp;java.io.Serializable, Comparable&lt;String&gt;, CharSequence\n{\n&nbsp;&nbsp;&nbsp;&nbsp;/** The value is used for character storage. */\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;char&nbsp;value[];\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;/** The offset is the first index of the storage that is used. */\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;offset;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;/** The count is the number of characters in the String. */\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;count;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;/** Cache the hash code for the string */\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;hash;&nbsp;// Default to 0\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;/** use serialVersionUID from JDK 1.0.2 for interoperability */\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;long&nbsp;serialVersionUID = -6849794470754667710L;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;......\n&nbsp;\n}<br></code></pre><p><br></p><p style=\"margin-left: auto;\">从上面可以看出几点：</p><p style=\"margin-left: auto;\">　　1）<i><b style=\"color: rgb(227, 55, 55);\">String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法</b></i>。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。<u style=\"color: rgb(226, 139, 65);\">在早期的JVM实现版本中，被final修饰的方法会被转为内嵌调用以提升执行效率。而从Java SE5/6开始，就渐渐摈弃这种方式了。</u>因此在现在的Java SE版本中，不需要考虑用final去提升方法调用效率。只有在确定不想让该方法被覆盖时，才将方法设置为final。</p><p style=\"margin-left: auto;\">　　2）上面列举出了String类中所有的成员属性，从上面可以看出String类其实是通过char数组来保存字符串的。</p><p style=\"margin-left: auto;\">　　下面再继续看String类的一些方法实现：</p><pre><code class=\"lang-java\">public&nbsp;String substring(int&nbsp;beginIndex,&nbsp;int&nbsp;endIndex) {\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(beginIndex &lt;&nbsp;0) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;StringIndexOutOfBoundsException(beginIndex);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(endIndex &gt; count) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;StringIndexOutOfBoundsException(endIndex);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(beginIndex &gt; endIndex) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;StringIndexOutOfBoundsException(endIndex - beginIndex);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;((beginIndex ==&nbsp;0) &amp;&amp; (endIndex == count)) ?&nbsp;this&nbsp;:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;String(offset + beginIndex, endIndex - beginIndex, value);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;\n&nbsp;public&nbsp;String concat(String str) {\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;otherLen = str.length();\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(otherLen ==&nbsp;0) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf[] =&nbsp;new&nbsp;char[count + otherLen];\n&nbsp;&nbsp;&nbsp;&nbsp;getChars(0, count, buf,&nbsp;0);\n&nbsp;&nbsp;&nbsp;&nbsp;str.getChars(0, otherLen, buf, count);\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;String(0, count + otherLen, buf);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;\n&nbsp;public&nbsp;String replace(char&nbsp;oldChar,&nbsp;char&nbsp;newChar) {\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(oldChar != newChar) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;len = count;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i = -1;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char[] val = value;&nbsp;/* avoid getfield opcode */\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;off = offset;&nbsp;&nbsp;&nbsp;/* avoid getfield opcode */\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(++i &lt; len) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(val[off + i] == oldChar) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i &lt; len) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf[] =&nbsp;new&nbsp;char[len];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j =&nbsp;0&nbsp;; j &lt; i ; j++) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf[j] = val[off+j];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(i &lt; len) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;c = val[off + i];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf[i] = (c == oldChar) ? newChar : c;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;String(0, len, buf);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this;<br></code></pre><p style=\"margin-left: auto;\">　&nbsp; &nbsp;从上面的三个方法可以看出，无论是sub操、concat还是replace操作都不是在原有的字符串上进行的，而是<i><b style=\"color: rgb(227, 55, 55);\">重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。</b></i></p><p style=\"margin-left: auto;\">　　在这里要永远记住一点：</p><p style=\"margin-left: auto;\">　<span style=\"color: rgb(255, 0, 0);\">　“对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。</span></p><p style=\"margin-left: auto;\">　　在了解了于String类基础的知识后，下面来看一些在平常使用中容易忽略和混淆的地方。</p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\"><br></p><h2><b style=\"color: rgb(227, 55, 55);\">二、深入理解String、StringBuffer、StringBuilder</b></h2><p style=\"margin-left: auto;\"><b>1.String str=\"hello world\"和String str=new String(\"hello world\")的区别</b></p><p style=\"margin-left: auto;\">　　想必大家对上面2个语句都不陌生，在平时写代码的过程中也经常遇到，那么它们到底有什么区别和联系呢？下面先看几个例子：</p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Main {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String str1 =&nbsp;\"hello world\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String str2 =&nbsp;new&nbsp;String(\"hello world\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String str3 =&nbsp;\"hello world\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String str4 =&nbsp;new&nbsp;String(\"hello world\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(str1==str2);//false\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(str1==str3);//true\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(str2==str4);//false\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</code></pre><p style=\"margin-left: auto;\">这段代码的输出结果为</p><p style=\"margin-left: auto;\">　　<img src=\"https://images0.cnblogs.com/i/288799/201406/091030134366487.jpg\" alt=\"\"><img alt=\"091030134366487.jpg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529393934943\" width=\"413\" height=\"147\"></p><p style=\"margin-left: auto;\">　　为什么会出现这样的结果？下面解释一下原因：</p><p style=\"margin-left: auto;\">　　在前面一篇讲解关于JVM内存机制的一篇博文中提到 ，在class文件中有一部分 来存储编译期间生成的 字面常量以及符号引用，这部分叫做class文件常量池，在运行期间对应着方法区的运行时常量池。</p><p style=\"margin-left: auto;\">　　因此在上述代码中，String str1 = \"hello world\";和String str3 = \"hello world\"; 都在编译期间生成了 字面常量和符号引用，运行期间字面常量\"hello world\"被存储在运行时常量池（当然只保存了一份）。通过这种方式来将String对象跟引用绑定的话，<b><i style=\"color: rgb(227, 55, 55);\">JVM执行引擎会先在运行时常量池查找是否存在相同的字面常量，如果存在，则直接将引用指向已经存在的字面常量；否则在运行时常量池开辟一个空间来存储该字面常量，并将引用指向该字面常量</i></b>。</p><p style=\"margin-left: auto;\">　　总所周知，通过new关键字来生成对象是在堆区进行的，而在堆区进行对象生成的过程是不会去检测该对象是否已经存在的。<span style=\"color: rgb(226, 139, 65);\">因此通过new来创建对象，创建出的一定是不同的对象，即使字符串的内容是相同的</span>。</p><p><br></p><p style=\"margin-left: auto;\"><b>2.String、StringBuffer以及StringBuilder的区别</b></p><p style=\"margin-left: auto;\">　　既然在Java中已经存在了String类，那为什么还需要StringBuilder和StringBuffer类呢？</p><p style=\"margin-left: auto;\">　　那么看下面这段代码：</p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Main {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String string =&nbsp;\"\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;10000;i++){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string +=&nbsp;\"hello\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">　　这句 string += \"hello\";的过程相当于将原有的string变量指向的对象内容取出与\"hello\"作字符串相加操作再存进另一个新的String对象当中，再让string变量指向新生成的对象。如果大家还有疑问可以反编译其字节码文件便清楚了：</span><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\"><img alt=\"11.jpg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529394152436\" width=\"641\" height=\"620\"><br></span></p><p style=\"margin-left: auto;\">从这段反编译出的字节码文件可以很清楚地看出：从第8行开始到第35行是整个循环的执行过程，并且每次循环会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象。也就是说这个循环执行完毕new出了10000个对象，试想一下，如果这些对象没有被回收，会造成多大的内存资源浪费。</p><p style=\"margin-left: auto;\">&nbsp; &nbsp; &nbsp; &nbsp; 从上面还可以看出：string+=\"hello\"的操作事实上会自动被JVM优化成：</p><pre><code class=\"lang-java\">　　StringBuilder str = new StringBuilder(string);\n　　str.append(\"hello\");\n　　str.toString();<br></code></pre><p style=\"margin-left: auto;\">　　</p><p style=\"margin-left: auto;\">再看下面这段代码：</p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Main {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuilder stringBuilder =&nbsp;new&nbsp;StringBuilder();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;10000;i++){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringBuilder.append(\"hello\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">反编译字节码文件得到：</span><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\"><img alt=\"12.jpg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529394258465\" width=\"641\" height=\"620\"><br></span></p><p style=\"margin-left: auto;\">　从这里可以明显看出，这段代码的for循环式从13行开始到27行结束，并且new操作只进行了一次，也就是说只生成了一个对象，append操作是在原有对象的基础上进行的。<span style=\"color: rgb(226, 139, 65);\">因此在循环了10000次之后，这段代码所占的资源要比上面小得多</span>。</p><p style=\"margin-left: auto;\">　　那么有人会问既然有了StringBuilder类，为什么还需要StringBuffer类？查看源代码便一目了然，事实上，StringBuilder和StringBuffer类拥有的成员属性以及成员方法基本相同，<span style=\"color: rgb(227, 55, 55);\"><b><i>区别是StringBuffer类的成员方法前面多了一个关键字：synchronized</i></b></span>，不用多说，这个关键字是在多线程访问时起到安全保护作用的,也就是说<span style=\"color: rgb(227, 55, 55);\"><i><b>StringBuffer是线程安全的</b></i></span>。</p><p style=\"margin-left: auto;\">　　下面摘了2段代码分别来自StringBuffer和StringBuilder，insert方法的具体实现：</p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\">&nbsp; &nbsp; &nbsp; StringBuilder的insert方法</p><pre><code class=\"lang-java\">public&nbsp;StringBuilder insert(int&nbsp;index,&nbsp;char&nbsp;str[],&nbsp;int&nbsp;offset, int&nbsp;len)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.insert(index, str, offset, len);\n&nbsp;&nbsp;   return&nbsp;this;\n}<br></code></pre><p><span style=\"color: rgb(0, 0, 0);\">&nbsp; &nbsp; &nbsp; StringBuffer的insert方法：</span><br></p><pre><code class=\"lang-java\">public&nbsp;synchronized&nbsp;StringBuffer insert(int&nbsp;index,&nbsp;char&nbsp;str[],&nbsp;int&nbsp;offset, int&nbsp;len)\n{\n&nbsp;&nbsp;&nbsp;&nbsp; super.insert(index, str, offset, len);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this;\n}<br></code></pre><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\"><br></span></p><h2><b style=\"color: rgb(227, 55, 55);\">三、不同场景下三个类的性能测试</b></h2><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">从第二节我们已经看出了三个类的区别，这一小节我们来做个小测试，来测试一下三个类的性能区别：</span><br></p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Main {\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;int&nbsp;time =&nbsp;50000;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testString();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testStringBuffer();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testStringBuilder();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test1String();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test2String();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;testString () {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s=\"\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;begin = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0; i&lt;time; i++){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s +=&nbsp;\"java\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;over = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"操作\"+s.getClass().getName()+\"类型使用的时间为：\"+(over-begin)+\"毫秒\");\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;testStringBuffer () {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer sb =&nbsp;new&nbsp;StringBuffer();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;begin = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0; i&lt;time; i++){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.append(\"java\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;over = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"操作\"+sb.getClass().getName()+\"类型使用的时间为：\"+(over-begin)+\"毫秒\");\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;testStringBuilder () {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuilder sb =&nbsp;new&nbsp;StringBuilder();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;begin = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0; i&lt;time; i++){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.append(\"java\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;over = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"操作\"+sb.getClass().getName()+\"类型使用的时间为：\"+(over-begin)+\"毫秒\");\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;test1String () {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;begin = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0; i&lt;time; i++){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s =&nbsp;\"I\"+\"love\"+\"java\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;over = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"字符串直接相加操作：\"+(over-begin)+\"毫秒\");\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;test2String () {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s1 =\"I\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s2 =&nbsp;\"love\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s3 =&nbsp;\"java\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;begin = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0; i&lt;time; i++){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s = s1+s2+s3;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;over = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"字符串间接相加操作：\"+(over-begin)+\"毫秒\");\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n}<br></code></pre><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">测试结果1（win7，Eclipse，JDK6)：</span><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\"><img alt=\"13.jpg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529394627752\" width=\"535\" height=\"165\"><br></span></p><p>测试结果2 (macOX, IDEA, JDK1.8 )</p><p><img alt=\"QQ20180619-155205@2x.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529394794049\" width=\"600\" height=\"129.42857142857142\"><br></p><p><br></p><p><span style=\"color: rgb(0, 0, 0);\">上面提到string+=\"hello\"的操作事实上会自动被JVM优化，看下面这段代码：</span><br></p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Main {\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;int&nbsp;time =&nbsp;50000;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testString();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testOptimalString();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;testString () {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s=\"\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;begin = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0; i&lt;time; i++){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s +=&nbsp;\"java\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;over = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"操作\"+s.getClass().getName()+\"类型使用的时间为：\"+(over-begin)+\"毫秒\");\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;testOptimalString () {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s=\"\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;begin = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0; i&lt;time; i++){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuilder sb =&nbsp;new&nbsp;StringBuilder(s);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.append(\"java\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s=sb.toString();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;over = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"模拟JVM优化操作的时间为：\"+(over-begin)+\"毫秒\");\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n}<br></code></pre><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">　执行结果：</span><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\"><img alt=\"091151335303258.jpg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529395004156\" width=\"540\" height=\"117\"><br></span></p><p style=\"margin-left: auto;\">得到验证。</p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\">　　下面对上面的执行结果进行一般性的解释：</p><p style=\"margin-left: auto;\">　　1）对于<span style=\"color: rgb(227, 55, 55);\">直接相加字符串，效率很高</span>，因为在编译器便确定了它的值，也就是说形如\"I\"+\"love\"+\"java\"; 的字符串相加，<span style=\"color: rgb(227, 55, 55);\">在编译期间便被优化成了\"Ilovejava\"</span>。这个可以用javap -c命令反编译生成的class文件进行验证。</p><p style=\"margin-left: auto;\">　　对于间接相加（即包含字符串引用），形如s1+s2+s3; 效率要比直接相加低，<span style=\"color: rgb(226, 139, 65);\"><b>因为在编译器不会对引用变量进行优化</b></span>。</p><p style=\"margin-left: auto;\">　　2）String、StringBuilder、StringBuffer三者的执行效率：</p><p style=\"margin-left: auto;\">　　StringBuilder &gt; StringBuffer &gt; String</p><p style=\"margin-left: auto;\">　　当然这个是相对的，不一定在所有情况下都是这样。</p><p style=\"margin-left: auto;\">　　比如String str = \"hello\"+ \"world\"的效率就比 StringBuilder st&nbsp; = new StringBuilder().append(\"hello\").append(\"world\")要高。</p><p style=\"margin-left: auto;\">　　因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用：</p><p style=\"margin-left: auto;\">　　<span style=\"color: rgb(65, 140, 175);\"><b style=\"\">当字符串相加操作或者改动较少的情况下，建议使用 String str=\"hello\"这种形式</b></span>；</p><p style=\"margin-left: auto;\">　　<span style=\"color: rgb(227, 55, 55);\"><b>当字符串相加操作较多的情况下，建议使用StringBuilder</b></span>，<span style=\"color: rgb(32, 147, 97);\"><b>如果采用了多线程，则使用StringBuffer</b></span>。</p><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\"><br></span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\"><br></span></p><h2><b style=\"color: rgb(227, 55, 55);\">四、常见的关于String、StringBuffer的面试题</b></h2><p style=\"margin-left: auto;\">　　下面是一些常见的关于String、StringBuffer的一些面试笔试题，若有不正之处，请谅解和批评指正。</p><p style=\"margin-left: auto;\"><b>1. 下面这段代码的输出结果是什么？</b></p><pre><code class=\"lang-java\">String a = \"hello2\";\nString b = \"hello\" + 2;\nSystem.out.println((a == b));<br></code></pre><p style=\"margin-left: auto;\">　　输出结果为：true。原因很简单，<span style=\"color: rgb(227, 55, 55);\">\"hello\"+2在编译期间就已经被优化成\"hello2\"，因此在运行期间，变量a和变量b指向的是同一个对象</span>。</p><p style=\"margin-left: auto;\"><b><br></b></p><p style=\"margin-left: auto;\"><b>2.下面这段代码的输出结果是什么？</b></p><pre><code class=\"lang-java\">String a = \"hello2\";\nString b = \"hello\";\nString c = b + 2;\nSystem.out.println((a == c));<br></code></pre><p style=\"margin-left: auto;\">　　输出结果为:false。由于有符号引用的存在，所以&nbsp; String c = b + 2;不会在编译期间被优化，不会把b+2当做字面常量来处理的，<span style=\"color: rgb(227, 55, 55);\">因此这种方式生成的对象事实上是保存在堆上的。因此a和c指向的并不是同一个对象</span>。</p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\"><b>3.下面这段代码的输出结果是什么？</b></p><pre><code class=\"lang-java\">String a = \"hello2\"; &nbsp; 　 \nfinal String b = \"hello\"; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \nString c = b + 2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \nSystem.out.println((a == c));</code></pre><p style=\"margin-left: auto;\">　　输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，<span style=\"color: rgb(227, 55, 55);\"><b><i>对final变量的访问在编译期间都会直接被替代为真实的值。那么String c = b + 2;在编译期间就会被优化成：String c = \"hello\" + 2<b><i><font color=\"#000000\">。</font></i></b></i></b></span></p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\"><span style=\"color: rgb(0, 0, 0);\"><b>4.下面这段代码输出结果为：</b></span><br></p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Main {\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String a =&nbsp;\"hello2\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;String b = getHello();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String c = b +&nbsp;2;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println((a == c));\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;String getHello() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;\"hello\";\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p><span style=\"color: rgb(0, 0, 0);\">输出结果为false。这里面虽然将b用final修饰了，</span><b style=\"\"><i style=\"\"><font color=\"#e33737\">但是由于其赋值是通过方法调用返回的，那么它的值只能在运行期间确定，因此a和c指向的不是同一个对象</font><font color=\"#000000\">。</font></i></b><br></p><p><b style=\"\"><i style=\"\"><font color=\"#000000\"><br></font></i></b></p><p><b style=\"\"><font color=\"#000000\" style=\"\"><span style=\"color: rgb(0, 0, 0);\">5.下面这段代码的输出结果是什么？</span><br></font></b></p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Main {\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String a =&nbsp;\"hello\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String b =&nbsp;&nbsp;new&nbsp;String(\"hello\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String c =&nbsp;&nbsp;new&nbsp;String(\"hello\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String d = b.intern();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(a==b);//false\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(b==c);//false\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(b==d);//false\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(a==d);//true\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">这里面涉及到的是String.intern方法的使用。在String类中，intern方法是一个本地方法，在JAVA SE6之前，</span><span style=\"font-size: 14px; color: rgb(227, 55, 55);\"><b>intern方法会在运行时常量池中查找是否存在内容相同的字符串，如果存在则返回指向该字符串的引用 ,&nbsp;</b></span><span style=\"font-size: 14px; color: rgb(32, 147, 97);\"><b>如果不存在，则会将该字符串入池，并返回一个指向该字符串的引用</b></span><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">。因此，a和d指向的是同一个对象。</span><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\"><br></span></p><p><span style=\"color: rgb(0, 0, 0);\"><span style=\"color: rgb(0, 0, 0);\"><b style=\"\">6.String str = new String(\"abc\")创建了多少个对象？</b></span><br></span></p><p style=\"margin-left: auto;\">这个问题在很多书籍上都有说到比如《Java程序员面试宝典》，包括很多国内大公司笔试面试题都会遇到，大部分网上流传的以及一些面试书籍上都说是2个对象，这种说法是片面的。</p><p style=\"margin-left: auto;\"><span style=\"color: rgb(255, 0, 0);\">　　如果有不懂得地方可以参考这篇帖子：</span></p><p style=\"margin-left: auto;\"><span style=\"color: rgb(255, 0, 0);\">　　<a href=\"http://rednaxelafx.iteye.com/blog/774673/\">http://rednaxelafx.iteye.com/blog/774673/</a></span></p><p style=\"margin-left: auto;\">　　首先必须弄清楚创建对象的含义，创建是什么时候创建的？这段代码在运行期间会创建2个对象么？毫无疑问不可能，用javap -c反编译即可得到JVM执行的字节码内容：</p><p style=\"margin-left: auto;\"><img alt=\"112.jpg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529396285198\" width=\"646\" height=\"341\"><br></p><p style=\"margin-left: auto;\">很显然，new只调用了一次，也就是说只创建了一个对象。<br></p><p style=\"margin-left: auto;\">　　而这道题目让人混淆的地方就是这里，这段代码在运行期间确实只创建了一个对象，即在堆上创建了\"abc\"对象。而为什么大家都在说是2个对象呢，这里面要澄清一个概念&nbsp; 该段代码执行过程和类的加载过程是有区别的。<span style=\"color: rgb(227, 55, 55);\">在类加载的过程中，确实在运行时常量池中创建了一个\"abc\"对象，</span><span style=\"color: rgb(32, 147, 97);\">而在代码执行过程中确实只创建了一个String对象</span>。</p><p style=\"margin-left: auto;\">　　因此，这个问题如果换成 String str = new String(\"abc\")<span style=\"color: rgb(226, 139, 65);\">涉及到几个String对象？合理的解释是2个</span>。</p><p style=\"margin-left: auto;\">　　个人觉得在面试的时候如果遇到这个问题，可以向面试官询问清楚”是这段代码执行过程中创建了多少个对象还是涉及到多少个对象“再根据具体的来进行回答。</p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\"><b>7.下面这段代码1）和2）的区别是什么？</b></p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Main {\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String str1 =&nbsp;\"I\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//str1 += \"love\"+\"java\";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str1 = str1+\"love\"+\"java\";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n<br></code></pre><p><span style=\"color: rgb(0, 0, 0);\">1）的效率比2）的效率要高，1）中的\"love\"+\"java\"在编译期间会被优化成\"lovejava\"，而2）中的不会被优化。</span></p><p><span style=\"color: rgb(0, 0, 0);\">下面是两种方式的字节码：</span><br></p><p><span style=\"color: rgb(0, 0, 0);\"><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">1）的字节码：</span><br></span></p><p><span style=\"color: rgb(0, 0, 0);\"><span style=\"color: rgb(0, 0, 0); font-size: 14px;\"><img alt=\"14.jpg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529396599016\" width=\"656\" height=\"486\"><br></span></span></p><p><span style=\"color: rgb(0, 0, 0);\"><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">　　2）的字节码：</span><br></span></p><p><span style=\"color: rgb(0, 0, 0);\"><span style=\"color: rgb(0, 0, 0); font-size: 14px;\"><img alt=\"15.jpg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529396627280\" width=\"644\" height=\"546\"><br></span></span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0);\"><span style=\"color: rgb(0, 0, 0);\">可以看出，在1）中只进行了一次append操作，而在2）中进行了两次append操作。</span><br></span></p><p><br></p><p style=\"margin-left: auto;\">　参考文章：<a href=\"http://rednaxelafx.iteye.com/blog/774673/\" target=\"_blank\">http://rednaxelafx.iteye.com/blog/774673/</a></p><p style=\"margin-left: auto;\">　　　　　　　<a href=\"http://www.blogjava.net/Jack2007/archive/2008/06/17/208602.html\" target=\"_blank\">http://www.blogjava.net/Jack2007/archive/2008/06/17/208602.html</a></p><p style=\"margin-left: auto;\">　　　　　　&nbsp;&nbsp;&nbsp;<a href=\"http://www.jb51.net/article/36041.htm\" target=\"_blank\">http://www.jb51.net/article/36041.htm</a></p><p style=\"margin-left: auto;\">　　　　　　　<a href=\"http://blog.csdn.net/yirentianran/article/details/2871417\" target=\"_blank\">http://blog.csdn.net/yirentianran/article/details/2871417</a></p><p style=\"margin-left: auto;\">　　　　　　&nbsp;&nbsp;&nbsp;<a href=\"http://www.jb51.net/article/33398.htm\" target=\"_blank\">http://www.jb51.net/article/33398.htm</a></p><p><br></p><p><br></p><p>作者：<a href=\"http://www.cnblogs.com/dolphin0520/\" target=\"_blank\">海子</a></p><p>出处：<a href=\"http://www.cnblogs.com/dolphin0520/\" target=\"_blank\">http://www.cnblogs.com/dolphin0520/</a></p>', '2018-06-19 15:31:12', '/articles/10011', '0', '0', 'publish', '相信String这个类是Java中使用得最频繁的类之一，并且又是各大公司面试喜欢问到的地方，今天就来和大家一起学习一下String、StringBuilder和StringBuffer这几个类，分析它们的异同点以及了解各个类适用的场景。下面', 'Java,String,StringBuilder,StringBuffer', '探秘Java中的String、StringBuilder以及StringBuffer', '2018-08-01 13:32:06', '9', '1', '10006', '1'), ('10012', '0', '0', '<p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp;&nbsp; Java集合工具包位于Java.util包下，包含了很多常用的数据结构，如数组、链表、栈、队列、集合、哈希表等。学习Java集合框架下大致可以分为如下五个部分：List列表、Set集合、Map映射、迭代器（Iterator、Enumeration）、工具类（Arrays、Collections）。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp; &nbsp; Java集合类的整体框架如下：</span></p><p style=\"text-align: center;\"><span style=\"font-size: 14px;\"><img alt=\"20140628144205625.jpg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529397932603\" width=\"1108\" height=\"393\">&nbsp;</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; 从上图中可以看出，集合类主要分为两大类：Collection和Map。</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; Collection是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List和Set。</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; List接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为ArrayList和LinkedList，另外还有不常用的Vector。另外，LinkedList还是实现了Queue接口，因此也可以作为队列使用。</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; Set接口通常表示一个集合，其中的元素不允许重复（通过hashcode和equals函数保证），常用实现类有HashSet和TreeSet，HashSet是通过Map中的HashMap实现的，而TreeSet是通过Map中的TreeMap实现的。另外，TreeSet还实现了SortedSet接口，因此是有序的集合（集合中的元素要实现Comparable接口，并覆写Compartor函数才行）。</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; 我们看到，抽象类AbstractCollection、AbstractList和AbstractSet分别实现了Collection、List和Set接口，这就是在Java集合框架中用的很多的适配器设计模式，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; Map是一个映射接口，其中的每个元素都是一个key-value键值对，同样抽象类AbstractMap通过适配器模式实现了Map接口中的大部分函数，TreeMap、HashMap、WeakHashMap等实现类都通过继承AbstractMap来实现，另外，不常用的HashTable直接实现了Map接口，它和Vector都是JDK1.0就引入的集合类。</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; Iterator是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），Collection的实现类都实现了i</span><span style=\"font-size: 14px;\">terator()函数，它返回一个Iterator对象，用来遍历集合，ListIterator则专门用来遍历List。而</span><span style=\"font-size: 14px;\">Enumeration则是JDK1.0时引入的，作用与Iterator相同，但它的功能比Iterator要少，它只能再Hashtable、Vector和Stack中使用。</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; <b style=\"color: rgb(227, 55, 55);\">Arrays和Collections是用来操作数组、集合的两个工具类</b>，例如在ArrayList和Vector中大量调用了Arrays.Copyof()方法，而Collections中有很多静态方法可以返回各集合类的synchronized版本，即线程安全的版本，当然了，<span style=\"color: rgb(32, 147, 97);\"><b>如果要用线程安全的集合类，首选Concurrent并发包下的对应的集合类</b></span>。</span></p><p><span style=\"font-size: 14px;\"><br></span><br></p><p>原文地址：<a href=\"https://blog.csdn.net/ns_code/article/details/35564663\" target=\"_blank\">https://blog.csdn.net/ns_code/article/details/35564663</a></p>', '2018-06-19 17:01:16', '/articles/10012', '0', '0', 'publish', '   Java集合工具包位于Java.util包下，包含了很多常用的数据结构，如数组、链表、栈、队列、集合、哈希表等。学习Java集合框架下大致可以分为如', 'Java,集合,', '【Java集合源码剖析】Java集合框架', '2018-08-05 15:57:30', '15', '0', '10006', '1'), ('10013', '1', '0', '<h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b style=\"\">一、HashMap简介</b></span></h1><p style=\"text-align: justify;\">&nbsp; &nbsp; HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阈值）时，同样会自动增长。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; HashMap是非线程安全的，只是用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; HashMap&nbsp;实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。</p><p style=\"text-align: justify;\"></p><h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b style=\"\">二、HashMap源码剖析</b></span></h1><p style=\"text-align: justify;\">&nbsp; &nbsp; HashMap的源码如下(加入了比较详细的注释)：</p><pre><code class=\"lang-java\">package java.util;&nbsp;&nbsp;\nimport java.io.*;&nbsp;&nbsp;\n&nbsp;\npublic class HashMap&lt;K,V&gt;&nbsp;&nbsp;\n&nbsp; &nbsp; extends AbstractMap&lt;K,V&gt;&nbsp;&nbsp;\n&nbsp; &nbsp; implements Map&lt;K,V&gt;, Cloneable, Serializable&nbsp;&nbsp;\n{&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 默认的初始容量（容量为HashMap中槽的数目）是16，且实际容量必须是2的整数次幂。&nbsp;&nbsp;\n&nbsp; &nbsp; static final int DEFAULT_INITIAL_CAPACITY = 16;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）&nbsp;&nbsp;\n&nbsp; &nbsp; static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 默认加载因子为0.75&nbsp;\n&nbsp; &nbsp; static final float DEFAULT_LOAD_FACTOR = 0.75f;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 存储数据的Entry数组，长度是2的幂。&nbsp;&nbsp;\n&nbsp; &nbsp; // HashMap采用链表法解决冲突，每一个Entry本质上是一个单向链表&nbsp;&nbsp;\n&nbsp; &nbsp; transient Entry[] table;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // HashMap的底层数组中已用槽的数量&nbsp;&nbsp;\n&nbsp; &nbsp; transient int size;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）&nbsp;&nbsp;\n&nbsp; &nbsp; int threshold;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 加载因子实际大小&nbsp;&nbsp;\n&nbsp; &nbsp; final float loadFactor;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // HashMap被改变的次数&nbsp;&nbsp;\n&nbsp; &nbsp; transient volatile int modCount;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 指定“容量大小”和“加载因子”的构造函数&nbsp;&nbsp;\n&nbsp; &nbsp; public HashMap(int initialCapacity, float loadFactor) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (initialCapacity &lt; 0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalArgumentException(\"Illegal initial capacity: \" +&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;initialCapacity);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // HashMap的最大容量只能是MAXIMUM_CAPACITY&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (initialCapacity &gt; MAXIMUM_CAPACITY)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initialCapacity = MAXIMUM_CAPACITY;&nbsp;&nbsp;\n		//加载因此不能小于0\n&nbsp; &nbsp; &nbsp; &nbsp; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalArgumentException(\"Illegal load factor: \" +&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loadFactor);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 找出“大于initialCapacity”的最小的2的幂&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int capacity = 1;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; while (capacity &lt; initialCapacity)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; capacity &lt;&lt;= 1;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置“加载因子”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this.loadFactor = loadFactor;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; threshold = (int)(capacity * loadFactor);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 创建Entry数组，用来保存数据&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; table = new Entry[capacity];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; init();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 指定“容量大小”的构造函数&nbsp;&nbsp;\n&nbsp; &nbsp; public HashMap(int initialCapacity) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this(initialCapacity, DEFAULT_LOAD_FACTOR);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 默认构造函数。&nbsp;&nbsp;\n&nbsp; &nbsp; public HashMap() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置“加载因子”为默认加载因子0.75&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this.loadFactor = DEFAULT_LOAD_FACTOR;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 创建Entry数组，用来保存数据&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; table = new Entry[DEFAULT_INITIAL_CAPACITY];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; init();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 包含“子Map”的构造函数&nbsp;&nbsp;\n&nbsp; &nbsp; public HashMap(Map&lt;? extends K, ? extends V&gt; m) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 将m中的全部元素逐个添加到HashMap中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; putAllForCreate(m);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; //求hash值的方法，重新计算hash值\n&nbsp; &nbsp; static int hash(int h) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回h在数组中的索引值，这里用&amp;代替取模，旨在提升效率&nbsp;\n&nbsp; &nbsp; // h &amp; (length-1)保证返回值的小于length&nbsp;&nbsp;\n&nbsp; &nbsp; static int indexFor(int h, int length) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return h &amp; (length-1);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; public int size() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return size;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; public boolean isEmpty() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return size == 0;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 获取key对应的value&nbsp;&nbsp;\n&nbsp; &nbsp; public V get(Object key) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (key == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return getForNullKey();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 获取key的hash值&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int hash = hash(key.hashCode());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 在“该hash值对应的链表”上查找“键值等于key”的元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;e != null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object k;&nbsp;&nbsp;\n			//判断key是否相同\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return e.value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n		//没找到则返回null\n&nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 获取“key为null”的元素的值&nbsp;&nbsp;\n&nbsp; &nbsp; // HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！&nbsp;&nbsp;\n&nbsp; &nbsp; private V getForNullKey() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.key == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return e.value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // HashMap是否包含key&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean containsKey(Object key) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return getEntry(key) != null;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回“键为key”的键值对&nbsp;&nbsp;\n&nbsp; &nbsp; final Entry&lt;K,V&gt; getEntry(Object key) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 获取哈希值&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int hash = (key == null) ? 0 : hash(key.hashCode());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 在“该hash值对应的链表”上查找“键值等于key”的元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;e != null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object k;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.hash == hash &amp;&amp;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将“key-value”添加到HashMap中&nbsp;&nbsp;\n&nbsp; &nbsp; public V put(K key, V value) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若“key为null”，则将该键值对添加到table[0]中。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (key == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return putForNullKey(value);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int hash = hash(key.hashCode());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int i = indexFor(hash, table.length);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object k;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; V oldValue = e.value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.value = value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.recordAccess(this);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return oldValue;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;\n		//将key-value添加到table[i]处\n&nbsp; &nbsp; &nbsp; &nbsp; addEntry(hash, key, value, i);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置&nbsp;&nbsp;\n&nbsp; &nbsp; private V putForNullKey(V value) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.key == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; V oldValue = e.value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.value = value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.recordAccess(this);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return oldValue;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 如果没有存在key为null的键值对，则直接题阿见到table[0]处!&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; addEntry(0, null, value, 0);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 创建HashMap对应的“添加方法”，&nbsp;&nbsp;\n&nbsp; &nbsp; // 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap&nbsp;&nbsp;\n&nbsp; &nbsp; // 而put()是对外提供的往HashMap中添加元素的方法。&nbsp;&nbsp;\n&nbsp; &nbsp; private void putForCreate(K key, V value) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int hash = (key == null) ? 0 : hash(key.hashCode());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int i = indexFor(hash, table.length);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object k;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.hash == hash &amp;&amp;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.value = value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; createEntry(hash, key, value, i);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将“m”中的全部元素都添加到HashMap中。&nbsp;&nbsp;\n&nbsp; &nbsp; // 该方法被内部的构造HashMap的方法所调用。&nbsp;&nbsp;\n&nbsp; &nbsp; private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 利用迭代器将元素逐个添加到HashMap中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; putForCreate(e.getKey(), e.getValue());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 重新调整HashMap的大小，newCapacity是调整后的容量&nbsp;&nbsp;\n&nbsp; &nbsp; void resize(int newCapacity) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry[] oldTable = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int oldCapacity = oldTable.length;&nbsp;\n		//如果就容量已经达到了最大值，则不能再扩容，直接返回\n&nbsp; &nbsp; &nbsp; &nbsp; if (oldCapacity == MAXIMUM_CAPACITY) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; threshold = Integer.MAX_VALUE;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中，&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 然后，将“新HashMap”赋值给“旧HashMap”。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry[] newTable = new Entry[newCapacity];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; transfer(newTable);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; table = newTable;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; threshold = (int)(newCapacity * loadFactor);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将HashMap中的全部元素都添加到newTable中&nbsp;&nbsp;\n&nbsp; &nbsp; void transfer(Entry[] newTable) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry[] src = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int newCapacity = newTable.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int j = 0; j &lt; src.length; j++) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; e = src[j];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e != null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src[j] = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; next = e.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int i = indexFor(e.hash, newCapacity);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.next = newTable[i];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newTable[i] = e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e = next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } while (e != null);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将\"m\"的全部元素都添加到HashMap中&nbsp;&nbsp;\n&nbsp; &nbsp; public void putAll(Map&lt;? extends K, ? extends V&gt; m) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 有效性判断&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int numKeysToBeAdded = m.size();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (numKeysToBeAdded == 0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 计算容量是否足够，&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若“当前阈值容量 &lt; 需要的容量”，则将容量x2。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (numKeysToBeAdded &gt; threshold) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (targetCapacity &gt; MAXIMUM_CAPACITY)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetCapacity = MAXIMUM_CAPACITY;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int newCapacity = table.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (newCapacity &lt; targetCapacity)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newCapacity &lt;&lt;= 1;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (newCapacity &gt; table.length)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resize(newCapacity);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 通过迭代器，将“m”中的元素逐个添加到HashMap中。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(e.getKey(), e.getValue());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除“键为key”元素&nbsp;&nbsp;\n&nbsp; &nbsp; public V remove(Object key) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; e = removeEntryForKey(key);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return (e == null ? null : e.value);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除“键为key”的元素&nbsp;&nbsp;\n&nbsp; &nbsp; final Entry&lt;K,V&gt; removeEntryForKey(Object key) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int hash = (key == null) ? 0 : hash(key.hashCode());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int i = indexFor(hash, table.length);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; prev = table[i];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; e = prev;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 删除链表中“键为key”的元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 本质是“删除单向链表中的节点”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; while (e != null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; next = e.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object k;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.hash == hash &amp;&amp;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size--;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (prev == e)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table[i] = next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev.next = next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.recordRemoval(this);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev = e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e = next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return e;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除“键值对”&nbsp;&nbsp;\n&nbsp; &nbsp; final Entry&lt;K,V&gt; removeMapping(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (!(o instanceof Map.Entry))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Object key = entry.getKey();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int hash = (key == null) ? 0 : hash(key.hashCode());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int i = indexFor(hash, table.length);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; prev = table[i];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; e = prev;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 删除链表中的“键值对e”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 本质是“删除单向链表中的节点”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; while (e != null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; next = e.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.hash == hash &amp;&amp; e.equals(entry)) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size--;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (prev == e)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table[i] = next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev.next = next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.recordRemoval(this);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev = e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e = next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return e;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 清空HashMap，将所有的元素设为null&nbsp;&nbsp;\n&nbsp; &nbsp; public void clear() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry[] tab = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; tab.length; i++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab[i] = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; size = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 是否包含“值为value”的元素&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean containsValue(Object value) {&nbsp;&nbsp;\n&nbsp; &nbsp; // 若“value为null”，则调用containsNullValue()查找&nbsp;&nbsp;\n&nbsp; &nbsp; if (value == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return containsNullValue();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 若“value不为null”，则查找HashMap中是否有值为value的节点。&nbsp;&nbsp;\n&nbsp; &nbsp; Entry[] tab = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; tab.length ; i++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry e = tab[i] ; e != null ; e = e.next)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (value.equals(e.value))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 是否包含null值&nbsp;&nbsp;\n&nbsp; &nbsp; private boolean containsNullValue() {&nbsp;&nbsp;\n&nbsp; &nbsp; Entry[] tab = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; tab.length ; i++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry e = tab[i] ; e != null ; e = e.next)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.value == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 克隆一个HashMap，并返回Object对象&nbsp;&nbsp;\n&nbsp; &nbsp; public Object clone() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; HashMap&lt;K,V&gt; result = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; try {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (HashMap&lt;K,V&gt;)super.clone();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } catch (CloneNotSupportedException e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // assert false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; result.table = new Entry[table.length];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; result.entrySet = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; result.modCount = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; result.size = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; result.init();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 调用putAllForCreate()将全部元素添加到HashMap中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; result.putAllForCreate(this);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return result;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // Entry是单向链表。&nbsp;&nbsp;\n&nbsp; &nbsp; // 它是 “HashMap链式存储法”对应的链表。&nbsp;&nbsp;\n&nbsp; &nbsp; // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数&nbsp;&nbsp;\n&nbsp; &nbsp; static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; final K key;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; V value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 指向下一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; final int hash;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 构造函数。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 输入参数包括\"哈希值(h)\", \"键(k)\", \"值(v)\", \"下一节点(n)\"&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = v;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next = n;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key = k;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash = h;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public final K getKey() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return key;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public final V getValue() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public final V setValue(V newValue) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; V oldValue = value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = newValue;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return oldValue;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 判断两个Entry是否相等&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若两个Entry的“key”和“value”都相等，则返回true。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 否则，返回false&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public final boolean equals(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(o instanceof Map.Entry))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Map.Entry e = (Map.Entry)o;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object k1 = getKey();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object k2 = e.getKey();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object v1 = getValue();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object v2 = e.getValue();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 实现hashCode()&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public final int hashCode() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return (key==null&nbsp; &nbsp;? 0 : key.hashCode()) ^&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(value==null ? 0 : value.hashCode());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public final String toString() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return getKey() + \"=\" + getValue();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 当向HashMap中添加元素时，绘调用recordAccess()。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 这里不做任何处理&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; void recordAccess(HashMap&lt;K,V&gt; m) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 当从HashMap中删除元素时，绘调用recordRemoval()。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 这里不做任何处理&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; void recordRemoval(HashMap&lt;K,V&gt; m) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。&nbsp;&nbsp;\n&nbsp; &nbsp; void addEntry(int hash, K key, V value, int bucketIndex) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 保存“bucketIndex”位置的值到“e”中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; e = table[bucketIndex];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置“bucketIndex”位置的元素为“新Entry”，&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置“e”为“新Entry的下一个节点”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (size++ &gt;= threshold)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resize(2 * table.length);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 创建Entry。将“key-value”插入指定位置。&nbsp;&nbsp;\n&nbsp; &nbsp; void createEntry(int hash, K key, V value, int bucketIndex) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 保存“bucketIndex”位置的值到“e”中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; e = table[bucketIndex];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置“bucketIndex”位置的元素为“新Entry”，&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置“e”为“新Entry的下一个节点”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; size++;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。&nbsp;&nbsp;\n&nbsp; &nbsp; // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。&nbsp;&nbsp;\n&nbsp; &nbsp; private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 下一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // expectedModCount用于实现fast-fail机制。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int expectedModCount;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 当前索引&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int index;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 当前元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; current;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; HashIterator() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expectedModCount = modCount;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (size &gt; 0) { // advance to first entry&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry[] t = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 将next指向table中第一个不为null的元素。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public final boolean hasNext() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return next != null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 获取下一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; final Entry&lt;K,V&gt; nextEntry() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (modCount != expectedModCount)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ConcurrentModificationException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; e = next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NoSuchElementException();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 注意！！！&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 一个Entry就是一个单向链表&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 若该Entry的下一个节点不为空，就将next指向下一个节点;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((next = e.next) == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry[] t = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current = e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 删除当前元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public void remove() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (current == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalStateException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (modCount != expectedModCount)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ConcurrentModificationException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object k = current.key;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HashMap.this.removeEntryForKey(k);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expectedModCount = modCount;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // value的迭代器&nbsp;&nbsp;\n&nbsp; &nbsp; private final class ValueIterator extends HashIterator&lt;V&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public V next() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nextEntry().value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // key的迭代器&nbsp;&nbsp;\n&nbsp; &nbsp; private final class KeyIterator extends HashIterator&lt;K&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public K next() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nextEntry().getKey();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // Entry的迭代器&nbsp;&nbsp;\n&nbsp; &nbsp; private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public Map.Entry&lt;K,V&gt; next() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nextEntry();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回一个“key迭代器”&nbsp;&nbsp;\n&nbsp; &nbsp; Iterator&lt;K&gt; newKeyIterator()&nbsp; &nbsp;{&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return new KeyIterator();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; // 返回一个“value迭代器”&nbsp;&nbsp;\n&nbsp; &nbsp; Iterator&lt;V&gt; newValueIterator()&nbsp; &nbsp;{&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return new ValueIterator();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; // 返回一个“entry迭代器”&nbsp;&nbsp;\n&nbsp; &nbsp; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()&nbsp; &nbsp;{&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return new EntryIterator();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // HashMap的Entry对应的集合&nbsp;&nbsp;\n&nbsp; &nbsp; private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回“key的集合”，实际上返回一个“KeySet对象”&nbsp;&nbsp;\n&nbsp; &nbsp; public Set&lt;K&gt; keySet() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Set&lt;K&gt; ks = keySet;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return (ks != null ? ks : (keySet = new KeySet()));&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // Key对应的集合&nbsp;&nbsp;\n&nbsp; &nbsp; // KeySet继承于AbstractSet，说明该集合中没有重复的Key。&nbsp;&nbsp;\n&nbsp; &nbsp; private final class KeySet extends AbstractSet&lt;K&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public Iterator&lt;K&gt; iterator() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return newKeyIterator();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public int size() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return size;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean contains(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return containsKey(o);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean remove(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return HashMap.this.removeEntryForKey(o) != null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public void clear() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HashMap.this.clear();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回“value集合”，实际上返回的是一个Values对象&nbsp;&nbsp;\n&nbsp; &nbsp; public Collection&lt;V&gt; values() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Collection&lt;V&gt; vs = values;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return (vs != null ? vs : (values = new Values()));&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // “value集合”&nbsp;&nbsp;\n&nbsp; &nbsp; // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”，&nbsp;&nbsp;\n&nbsp; &nbsp; // Values中的元素能够重复。因为不同的key可以指向相同的value。&nbsp;&nbsp;\n&nbsp; &nbsp; private final class Values extends AbstractCollection&lt;V&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public Iterator&lt;V&gt; iterator() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return newValueIterator();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public int size() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return size;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean contains(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return containsValue(o);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public void clear() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HashMap.this.clear();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回“HashMap的Entry集合”&nbsp;&nbsp;\n&nbsp; &nbsp; public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return entrySet0();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象&nbsp;&nbsp;\n&nbsp; &nbsp; private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return es != null ? es : (entrySet = new EntrySet());&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // EntrySet对应的集合&nbsp;&nbsp;\n&nbsp; &nbsp; // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。&nbsp;&nbsp;\n&nbsp; &nbsp; private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return newEntryIterator();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean contains(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(o instanceof Map.Entry))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; candidate = getEntry(e.getKey());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return candidate != null &amp;&amp; candidate.equals(e);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean remove(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return removeMapping(o) != null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public int size() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return size;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public void clear() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HashMap.this.clear();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // java.io.Serializable的写入函数&nbsp;&nbsp;\n&nbsp; &nbsp; // 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中&nbsp;&nbsp;\n&nbsp; &nbsp; private void writeObject(java.io.ObjectOutputStream s)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; throws IOException&nbsp;&nbsp;\n&nbsp; &nbsp; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i =&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (size &gt; 0) ? entrySet0().iterator() : null;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Write out the threshold, loadfactor, and any hidden stuff&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; s.defaultWriteObject();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Write out number of buckets&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; s.writeInt(table.length);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Write out size (number of Mappings)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; s.writeInt(size);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Write out keys and values (alternating)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (i != null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (i.hasNext()) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Map.Entry&lt;K,V&gt; e = i.next();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.writeObject(e.getKey());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.writeObject(e.getValue());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp;\n&nbsp; &nbsp; private static final long serialVersionUID = 362498820763181265L;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // java.io.Serializable的读取函数：根据写入方式读出&nbsp;&nbsp;\n&nbsp; &nbsp; // 将HashMap的“总的容量，实际容量，所有的Entry”依次读出&nbsp;&nbsp;\n&nbsp; &nbsp; private void readObject(java.io.ObjectInputStream s)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;throws IOException, ClassNotFoundException&nbsp;&nbsp;\n&nbsp; &nbsp; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Read in the threshold, loadfactor, and any hidden stuff&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; s.defaultReadObject();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Read in number of buckets and allocate the bucket array;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int numBuckets = s.readInt();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; table = new Entry[numBuckets];&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; init();&nbsp; // Give subclass a chance to do its thing.&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Read in size (number of Mappings)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int size = s.readInt();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Read the keys and values, and put the mappings in the HashMap&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i=0; i&lt;size; i++) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K key = (K) s.readObject();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; V value = (V) s.readObject();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; putForCreate(key, value);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回“HashMap总的容量”&nbsp;&nbsp;\n&nbsp; &nbsp; int&nbsp; &nbsp;capacity()&nbsp; &nbsp; &nbsp;{ return table.length; }&nbsp;&nbsp;\n&nbsp; &nbsp; // 返回“HashMap的加载因子”&nbsp;&nbsp;\n&nbsp; &nbsp; float loadFactor()&nbsp; &nbsp;{ return loadFactor;&nbsp; &nbsp;}&nbsp;&nbsp;\n}&nbsp;<br></code></pre><p><br></p><h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b style=\"\">三、几点总结</b></span></h1><p style=\"text-align: justify;\">&nbsp; &nbsp; 1、首先要清楚HashMap的存储结构，如下图所示：</p><p><img alt=\"20140701191403764.jpeg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/19/saysky/1529412953565\" width=\"419\" height=\"371\"><br></p><p>图中，紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。</p><p><span style=\"font-size: 14px;\"><br></span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; 2、首先看链表中节点的数据结构：</span></p><pre><code class=\"lang-java\">&nbsp; &nbsp; // Entry是单向链表。&nbsp;&nbsp;\n&nbsp; &nbsp; // 它是 “HashMap链式存储法”对应的链表。&nbsp;&nbsp;\n&nbsp; &nbsp; // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数&nbsp;&nbsp;\n&nbsp; &nbsp; static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; final K key;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; V value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 指向下一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; final int hash;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 构造函数。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 输入参数包括\"哈希值(h)\", \"键(k)\", \"值(v)\", \"下一节点(n)\"&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = v;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next = n;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key = k;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash = h;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public final K getKey() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return key;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public final V getValue() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public final V setValue(V newValue) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; V oldValue = value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = newValue;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return oldValue;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 判断两个Entry是否相等&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若两个Entry的“key”和“value”都相等，则返回true。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 否则，返回false&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public final boolean equals(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(o instanceof Map.Entry))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Map.Entry e = (Map.Entry)o;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object k1 = getKey();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object k2 = e.getKey();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object v1 = getValue();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object v2 = e.getValue();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 实现hashCode()&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public final int hashCode() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return (key==null&nbsp; &nbsp;? 0 : key.hashCode()) ^&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(value==null ? 0 : value.hashCode());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public final String toString() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return getKey() + \"=\" + getValue();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 当向HashMap中添加元素时，绘调用recordAccess()。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 这里不做任何处理&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; void recordAccess(HashMap&lt;K,V&gt; m) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 当从HashMap中删除元素时，绘调用recordRemoval()。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 这里不做任何处理&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; void recordRemoval(HashMap&lt;K,V&gt; m) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;<br></code></pre><p>&nbsp;它的结构元素除了key、value、hash外，还有next，next指向下一个节点。另外，这里覆写了equals和hashCode方法来保证键值对的独一无二。</p><p><br></p><p>&nbsp; &nbsp; 3、HashMap共有四个构造方法。构造方法中提到了两个很重要的参数：初始容量和加载因子。这两个参数是影响HashMap性能的重要参数，<span style=\"color: rgb(255, 0, 0);\">其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（从构造函数中可以看出，如果不指明，则默认为16），加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 resize 操作（即扩容）。</span></p><p><span style=\"color: rgb(255, 0, 0);\">&nbsp; &nbsp; 下面说下加载因子，如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），对空间造成严重浪费。如果我们在构造方法中不指定，则系统默认加载因子为0.75，这是一个比较理想的值，一般情况下我们是无需修改的。</span></p><p><span style=\"color: rgb(255, 0, 0);\">&nbsp; &nbsp; 另外，无论我们指定的容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，且最大值不能超过2的30次方</span></p><p>&nbsp; &nbsp;</p><p>&nbsp;4、HashMap中key和value都允许为null。</p><p><br></p><p>5、要重点分析下HashMap中用的最多的两个方法put和get。</p><p>先从比较简单的get方法着手，源码如下：</p><pre><code class=\"lang-java\">&nbsp; &nbsp; // 获取key对应的value&nbsp;&nbsp;\n&nbsp; &nbsp; public V get(Object key) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (key == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return getForNullKey();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 获取key的hash值&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int hash = hash(key.hashCode());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 在“该hash值对应的链表”上查找“键值等于key”的元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;e != null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object k;&nbsp;&nbsp;\n			//判断key是否相同\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return e.value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n		//没找到则返回null\n&nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 获取“key为null”的元素的值&nbsp;&nbsp;\n&nbsp; &nbsp; // HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！&nbsp;&nbsp;\n&nbsp; &nbsp; private V getForNullKey() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.key == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return e.value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n<br></code></pre><p>&nbsp; 首先，如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。<span style=\"color: rgb(255, 0, 0);\">记住，key为null的键值对永远都放在以table[0]为头结点的链表中，当然不一定是存放在头结点table[0]中。</span></p><p>&nbsp; &nbsp; 如果key不为null，则先求的key的hash值，根据hash值找到在table中的索引，在该索引对应的单链表中查找是否有键值对的key与目标key相等，有就返回对应的value，没有则返回null。</p><p>&nbsp; &nbsp;</p><p>&nbsp;put方法稍微复杂些，代码如下：</p><pre><code class=\"lang-java\">&nbsp; &nbsp; // 将“key-value”添加到HashMap中&nbsp;&nbsp;\n&nbsp; &nbsp; public V put(K key, V value) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若“key为null”，则将该键值对添加到table[0]中。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (key == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return putForNullKey(value);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int hash = hash(key.hashCode());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int i = indexFor(hash, table.length);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object k;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; V oldValue = e.value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.value = value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.recordAccess(this);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return oldValue;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;\n	//将key-value添加到table[i]处\n&nbsp; &nbsp; &nbsp; &nbsp; addEntry(hash, key, value, i);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;<br></code></pre><p>如果key为null，则将其添加到table[0]对应的链表中，putForNullKey的源码如下：<br></p><pre><code class=\"lang-java\">&nbsp; &nbsp; // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置&nbsp;&nbsp;\n&nbsp; &nbsp; private V putForNullKey(V value) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.key == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; V oldValue = e.value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.value = value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.recordAccess(this);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return oldValue;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 如果没有存在key为null的键值对，则直接题阿见到table[0]处!&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; addEntry(0, null, value, 0);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;<br></code></pre><p>如果key不为null，则同样先求出key的hash值，根据hash值得出在table中的索引，而后遍历对应的单链表，如果单链表中存在与目标key相等的键值对，则将新的value覆盖旧的value，比将旧的value返回，<span style=\"color: rgb(255, 0, 0);\">如果找不到与目标key相等的键值对，或者该单链表为空，则将该键值对插入到改单链表的头结点位置（每次新插入的节点都是放在头结点的位置）</span>，该操作是有addEntry方法实现的，它的源码如下：<br></p><pre><code class=\"lang-java\">&nbsp; &nbsp; // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。&nbsp;&nbsp;\n&nbsp; &nbsp; void addEntry(int hash, K key, V value, int bucketIndex) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 保存“bucketIndex”位置的值到“e”中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; e = table[bucketIndex];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置“bucketIndex”位置的元素为“新Entry”，&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置“e”为“新Entry的下一个节点”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (size++ &gt;= threshold)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resize(2 * table.length);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;<br></code></pre><p><span style=\"font-size: 14px;\">&nbsp;</span>注意这里倒数第三行的构造方法，将key-value键值对赋给table[bucketIndex]，并将其next指向元素e，这便将key-value放到了头结点中，并将之前的头结点接在了它的后面。<span style=\"color: rgb(255, 0, 0);\">该方法也说明，每次put键值对的时候，总是将新的该键值对放在table[bucketIndex]处（即头结点处）。</span></p><p><span style=\"color: rgb(255, 0, 0);\">&nbsp; &nbsp; 两外注意最后两行代码，每次加入键值对时，都要判断当前已用的槽的数目是否大于等于阈值（容量*加载因子），如果大于等于，则进行扩容，将容量扩为原来容量的2倍。</span></p><p><br></p><p>&nbsp; &nbsp; 6、关于扩容。上面我们看到了扩容的方法，resize方法，它的源码如下：</p><pre><code class=\"lang-java\">&nbsp; &nbsp; // 重新调整HashMap的大小，newCapacity是调整后的单位&nbsp;&nbsp;\n&nbsp; &nbsp; void resize(int newCapacity) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry[] oldTable = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int oldCapacity = oldTable.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (oldCapacity == MAXIMUM_CAPACITY) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; threshold = Integer.MAX_VALUE;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中，&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 然后，将“新HashMap”赋值给“旧HashMap”。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry[] newTable = new Entry[newCapacity];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; transfer(newTable);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; table = newTable;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; threshold = (int)(newCapacity * loadFactor);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;<br></code></pre><p>&nbsp;很明显，是新建了一个HashMap的底层数组，而后调用transfer方法，将就HashMap的全部元素添加到新的HashMap中（要重新计算元素在新的数组中的索引位置）。transfer方法的源码如下：<br></p><pre><code class=\"lang-java\">&nbsp; &nbsp; // 将HashMap中的全部元素都添加到newTable中&nbsp;&nbsp;\n&nbsp; &nbsp; void transfer(Entry[] newTable) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry[] src = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int newCapacity = newTable.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int j = 0; j &lt; src.length; j++) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; e = src[j];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e != null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src[j] = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; next = e.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int i = indexFor(e.hash, newCapacity);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.next = newTable[i];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newTable[i] = e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e = next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } while (e != null);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;<br></code></pre><p><span style=\"color: rgb(255, 0, 0);\">很明显，扩容是一个相当耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用HashMap的时，最好能提前预估下HashMap中元素的个数，这样有助于提高HashMap的性能。</span></p><p><span style=\"font-size: 14px;\"><br></span></p><p>&nbsp; &nbsp; 7、注意containsKey方法和containsValue方法。前者直接可以通过key的哈希值将搜索范围定位到指定索引对应的链表，而后者要对哈希数组的每个链表进行搜索。</p><p>&nbsp;&nbsp;</p><p>&nbsp; 8、我们重点来分析下求hash值和索引值的方法，这两个方法便是HashMap设计的最为核心的部分，二者结合能保证哈希表中的元素尽可能均匀地散列。</p><p>&nbsp; &nbsp; 计算哈希值的方法如下：</p><p></p><pre><code class=\"lang-java\">static int hash(int h) {\n&nbsp; &nbsp; &nbsp; &nbsp; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);\n&nbsp; &nbsp; &nbsp; &nbsp; return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);\n&nbsp; &nbsp; }<br></code></pre><p>&nbsp;它只是一个数学公式，IDK这样设计对hash值的计算，自然有它的好处，至于为什么这样设计，我们这里不去追究，只要明白一点，用的位的操作使hash值的计算效率很高。</p><p>&nbsp; &nbsp; 由hash值找到对应索引的方法如下：</p><pre><code class=\"lang-java\">static int indexFor(int h, int length) {\n&nbsp; &nbsp; &nbsp; &nbsp; return h &amp; (length-1);\n&nbsp; &nbsp; }<br></code></pre><p>这个我们要重点说下，我们一般对哈希表的散列很自然地会想到用hash值对length取模（即除法散列法），Hashtable中也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，<span style=\"color: rgb(255, 0, 0);\">HashMap中则通过h&amp;(length-1)的方法来代替取模，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。</span></p><p>&nbsp; &nbsp;<span style=\"color: rgb(255, 0, 0);\">&nbsp;接下来，我们分析下为什么哈希表的容量一定要是2的整数次幂。</span>首先，<span style=\"color: rgb(255, 0, 0);\">length为2的整数次幂的话，</span><span style=\"color: rgb(255, 0, 0);\">h&amp;(length-1)就相当于对length取模，这样便保证了散列的均匀，同时也提升了效率</span>；其次，length为2的整数次幂的话，为偶数，这样length-1为奇数，奇数的最后一位是1，这样便保证了h&amp;(length-1)的最后一位可能为0，也可能为1（这取决于h的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性，而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&amp;(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间，<span style=\"color: rgb(255, 0, 0);\">因此，length取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。</span></p><p><span style=\"color: rgb(255, 0, 0);\"><br></span></p><p>原文地址：<a href=\"https://blog.csdn.net/ns_code/article/details/36034955\" target=\"_blank\" style=\"\">https://blog.csdn.net/ns_code/article/details/36034955</a></p>', '2018-06-19 21:03:52', '/articles/10013', '0', '0', 'publish', '一、HashMap简介    HashM', 'Java,HashMap,源码', '【Java集合源码剖析】HashMap源码剖析', '2019-01-11 16:11:16', '23', '1', '10006', '1');
INSERT INTO `article` VALUES ('10014', '0', '0', '<h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b style=\"\">一、LinkedList简介</b></span></h1><p style=\"text-align: justify;\">&nbsp; &nbsp; LinkedList是基于双向循环链表（从源码中可以很容易看出）实现的，除了可以当做链表来操作外，它还可以当做栈、队列和双端队列来使用。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; LinkedList同样是非线程安全的，只在单线程下适合使用。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; LinkedList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆。</p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"></span></p><h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b style=\"\">二、LinkedList源码剖析</b></span></h1><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp; &nbsp; LinkedList的源码如下（加入了比较详细的注释）：</span></p><pre><code class=\"lang-java\">package java.util;&nbsp;&nbsp;\n&nbsp;\npublic class LinkedList&lt;E&gt;&nbsp;&nbsp;\n&nbsp; &nbsp; extends AbstractSequentialList&lt;E&gt;&nbsp;&nbsp;\n&nbsp; &nbsp; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&nbsp;&nbsp;\n{&nbsp;&nbsp;\n&nbsp; &nbsp; // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。&nbsp;&nbsp;\n&nbsp; &nbsp; private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // LinkedList中元素个数&nbsp;&nbsp;\n&nbsp; &nbsp; private transient int size = 0;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 默认构造函数：创建一个空的链表&nbsp;&nbsp;\n&nbsp; &nbsp; public LinkedList() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; header.next = header.previous = header;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList&nbsp;&nbsp;\n&nbsp; &nbsp; public LinkedList(Collection&lt;? extends E&gt; c) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; addAll(c);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 获取LinkedList的第一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; public E getFirst() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (size==0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NoSuchElementException();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 链表的表头header中不包含数据。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 这里返回header所指下一个节点所包含的数据。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return header.next.element;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 获取LinkedList的最后一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; public E getLast()&nbsp; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (size==0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NoSuchElementException();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 由于LinkedList是双向链表；而表头header不包含数据。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 因而，这里返回表头header的前一个节点所包含的数据。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return header.previous.element;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除LinkedList的第一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; public E removeFirst() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return remove(header.next);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除LinkedList的最后一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; public E removeLast() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return remove(header.previous);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将元素添加到LinkedList的起始位置&nbsp;&nbsp;\n&nbsp; &nbsp; public void addFirst(E e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; addBefore(e, header.next);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将元素添加到LinkedList的结束位置&nbsp;&nbsp;\n&nbsp; &nbsp; public void addLast(E e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; addBefore(e, header);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 判断LinkedList是否包含元素(o)&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean contains(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return indexOf(o) != -1;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回LinkedList的大小&nbsp;&nbsp;\n&nbsp; &nbsp; public int size() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return size;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将元素(E)添加到LinkedList中&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean add(E e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 将节点(节点数据是e)添加到表头(header)之前。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 即，将节点添加到双向链表的末端。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; addBefore(e, header);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 从LinkedList中删除元素(o)&nbsp;&nbsp;\n&nbsp; &nbsp; // 从链表开始查找，如存在元素(o)则删除该元素并返回true；&nbsp;&nbsp;\n&nbsp; &nbsp; // 否则，返回false。&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean remove(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (o==null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 若o为null的删除情况&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.element==null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove(e);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 若o不为null的删除情况&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (o.equals(e.element)) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove(e);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将“集合(c)”添加到LinkedList中。&nbsp;&nbsp;\n&nbsp; &nbsp; // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean addAll(Collection&lt;? extends E&gt; c) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return addAll(size, c);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 从双向链表的index开始，将“集合(c)”添加到双向链表中。&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean addAll(int index, Collection&lt;? extends E&gt; c) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (index &lt; 0 || index &gt; size)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IndexOutOfBoundsException(\"Index: \"+index+&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \", Size: \"+size);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Object[] a = c.toArray();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 获取集合的长度&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int numNew = a.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (numNew==0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置“当前要插入节点的后一个节点”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;E&gt; successor = (index==size ? header : entry(index));&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置“当前要插入节点的前一个节点”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;E&gt; predecessor = successor.previous;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 将集合(c)全部插入双向链表中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i=0; i&lt;numNew; i++) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;E&gt; e = new Entry&lt;E&gt;((E)a[i], successor, predecessor);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; predecessor.next = e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; predecessor = e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; successor.previous = predecessor;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 调整LinkedList的实际大小&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; size += numNew;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 清空双向链表&nbsp;&nbsp;\n&nbsp; &nbsp; public void clear() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;E&gt; e = header.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作：&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // (01) 设置前一个节点为null&nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // (02) 设置当前节点的内容为null&nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // (03) 设置后一个节点为“新的当前节点”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; while (e != header) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;E&gt; next = e.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.next = e.previous = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.element = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e = next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; header.next = header.previous = header;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置大小为0&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; size = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回LinkedList指定位置的元素&nbsp;&nbsp;\n&nbsp; &nbsp; public E get(int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return entry(index).element;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 设置index位置对应的节点的值为element&nbsp;&nbsp;\n&nbsp; &nbsp; public E set(int index, E element) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;E&gt; e = entry(index);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; E oldVal = e.element;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; e.element = element;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return oldVal;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp;\n&nbsp; &nbsp; // 在index前添加节点，且节点的值为element&nbsp;&nbsp;\n&nbsp; &nbsp; public void add(int index, E element) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; addBefore(element, (index==size ? header : entry(index)));&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除index位置的节点&nbsp;&nbsp;\n&nbsp; &nbsp; public E remove(int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return remove(entry(index));&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 获取双向链表中指定位置的节点&nbsp;&nbsp;\n&nbsp; &nbsp; private Entry&lt;E&gt; entry(int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (index &lt; 0 || index &gt;= size)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IndexOutOfBoundsException(\"Index: \"+index+&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \", Size: \"+size);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;E&gt; e = header;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 获取index处的节点。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若index &lt; 双向链表长度的1/2,则从前先后查找;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 否则，从后向前查找。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (index &lt; (size &gt;&gt; 1)) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt;= index; i++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e = e.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = size; i &gt; index; i--)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e = e.previous;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return e;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 从前向后查找，返回“值为对象(o)的节点对应的索引”&nbsp;&nbsp;\n&nbsp; &nbsp; // 不存在就返回-1&nbsp;&nbsp;\n&nbsp; &nbsp; public int indexOf(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int index = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (o==null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry e = header.next; e != header; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.element==null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return index;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry e = header.next; e != header; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (o.equals(e.element))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return index;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return -1;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 从后向前查找，返回“值为对象(o)的节点对应的索引”&nbsp;&nbsp;\n&nbsp; &nbsp; // 不存在就返回-1&nbsp;&nbsp;\n&nbsp; &nbsp; public int lastIndexOf(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int index = size;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (o==null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry e = header.previous; e != header; e = e.previous) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index--;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.element==null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return index;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry e = header.previous; e != header; e = e.previous) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index--;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (o.equals(e.element))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return index;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return -1;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回第一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; // 若LinkedList的大小为0,则返回null&nbsp;&nbsp;\n&nbsp; &nbsp; public E peek() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (size==0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return getFirst();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回第一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; // 若LinkedList的大小为0,则抛出异常&nbsp;&nbsp;\n&nbsp; &nbsp; public E element() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return getFirst();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除并返回第一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; // 若LinkedList的大小为0,则返回null&nbsp;&nbsp;\n&nbsp; &nbsp; public E poll() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (size==0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return removeFirst();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将e添加双向链表末尾&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean offer(E e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return add(e);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将e添加双向链表开头&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean offerFirst(E e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; addFirst(e);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将e添加双向链表末尾&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean offerLast(E e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; addLast(e);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回第一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; // 若LinkedList的大小为0,则返回null&nbsp;&nbsp;\n&nbsp; &nbsp; public E peekFirst() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (size==0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return getFirst();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回最后一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; // 若LinkedList的大小为0,则返回null&nbsp;&nbsp;\n&nbsp; &nbsp; public E peekLast() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (size==0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return getLast();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除并返回第一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; // 若LinkedList的大小为0,则返回null&nbsp;&nbsp;\n&nbsp; &nbsp; public E pollFirst() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (size==0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return removeFirst();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除并返回最后一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; // 若LinkedList的大小为0,则返回null&nbsp;&nbsp;\n&nbsp; &nbsp; public E pollLast() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (size==0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return removeLast();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将e插入到双向链表开头&nbsp;&nbsp;\n&nbsp; &nbsp; public void push(E e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; addFirst(e);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除并返回第一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; public E pop() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return removeFirst();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点&nbsp;&nbsp;\n&nbsp; &nbsp; // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean removeFirstOccurrence(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return remove(o);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点&nbsp;&nbsp;\n&nbsp; &nbsp; // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean removeLastOccurrence(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (o==null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.element==null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove(e);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (o.equals(e.element)) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove(e);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器)&nbsp;&nbsp;\n&nbsp; &nbsp; public ListIterator&lt;E&gt; listIterator(int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return new ListItr(index);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // List迭代器&nbsp;&nbsp;\n&nbsp; &nbsp; private class ListItr implements ListIterator&lt;E&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 上一次返回的节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; private Entry&lt;E&gt; lastReturned = header;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 下一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; private Entry&lt;E&gt; next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 下一个节点对应的索引值&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; private int nextIndex;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 期望的改变计数。用来实现fail-fast机制。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; private int expectedModCount = modCount;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 构造函数。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 从index位置开始进行迭代&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; ListItr(int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // index的有效性处理&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (index &lt; 0 || index &gt; size)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+size);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找；&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 否则，从最后一个元素往前查找。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (index &lt; (size &gt;&gt; 1)) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next = header.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (nextIndex=0; nextIndex&lt;index; nextIndex++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next = next.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next = header;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (nextIndex=size; nextIndex&gt;index; nextIndex--)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next = next.previous;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 是否存在下一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean hasNext() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nextIndex != size;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 获取下一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public E next() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkForComodification();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nextIndex == size)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NoSuchElementException();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastReturned = next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // next指向链表的下一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next = next.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextIndex++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return lastReturned.element;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 是否存在上一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean hasPrevious() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 通过元素索引是否等于0，来判断是否达到开头。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nextIndex != 0;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 获取上一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public E previous() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nextIndex == 0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NoSuchElementException();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // next指向链表的上一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastReturned = next = next.previous;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextIndex--;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkForComodification();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return lastReturned.element;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 获取下一个元素的索引&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public int nextIndex() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nextIndex;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 获取上一个元素的索引&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public int previousIndex() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nextIndex-1;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 删除当前元素。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 删除双向链表中的当前节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public void remove() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkForComodification();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;E&gt; lastNext = lastReturned.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LinkedList.this.remove(lastReturned);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (NoSuchElementException e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalStateException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (next==lastReturned)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next = lastNext;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextIndex--;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastReturned = header;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expectedModCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置当前节点为e&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public void set(E e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (lastReturned == header)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalStateException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkForComodification();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastReturned.element = e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 将e添加到当前节点的前面&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public void add(E e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkForComodification();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastReturned = header;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addBefore(e, next);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextIndex++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expectedModCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; final void checkForComodification() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (modCount != expectedModCount)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ConcurrentModificationException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 双向链表的节点所对应的数据结构。&nbsp;&nbsp;\n&nbsp; &nbsp; // 包含3部分：上一节点，下一节点，当前节点值。&nbsp;&nbsp;\n&nbsp; &nbsp; private static class Entry&lt;E&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 当前节点所包含的值&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; E element;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 下一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;E&gt; next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 上一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;E&gt; previous;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 链表节点的构造函数。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 参数说明：&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*&nbsp; &nbsp;element&nbsp; —— 节点所包含的数据&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*&nbsp; &nbsp;next&nbsp; &nbsp; &nbsp; —— 下一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*&nbsp; &nbsp;previous —— 上一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.element = element;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.next = next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.previous = previous;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将节点(节点数据是e)添加到entry节点之前。&nbsp;&nbsp;\n&nbsp; &nbsp; private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; newEntry.previous.next = newEntry;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; newEntry.next.previous = newEntry;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 修改LinkedList大小&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; size++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 修改LinkedList的修改统计数：用来实现fail-fast机制。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return newEntry;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将节点从链表中删除&nbsp;&nbsp;\n&nbsp; &nbsp; private E remove(Entry&lt;E&gt; e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (e == header)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NoSuchElementException();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; E result = e.element;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; e.previous.next = e.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; e.next.previous = e.previous;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; e.next = e.previous = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; e.element = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; size--;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return result;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 反向迭代器&nbsp;&nbsp;\n&nbsp; &nbsp; public Iterator&lt;E&gt; descendingIterator() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return new DescendingIterator();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 反向迭代器实现类。&nbsp;&nbsp;\n&nbsp; &nbsp; private class DescendingIterator implements Iterator {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; final ListItr itr = new ListItr(size());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 反向迭代器是否下一个元素。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 实际上是判断双向链表的当前节点是否达到开头&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean hasNext() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return itr.hasPrevious();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 反向迭代器获取下一个元素。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 实际上是获取双向链表的前一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public E next() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return itr.previous();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 删除当前节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public void remove() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itr.remove();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回LinkedList的Object[]数组&nbsp;&nbsp;\n&nbsp; &nbsp; public Object[] toArray() {&nbsp;&nbsp;\n&nbsp; &nbsp; // 新建Object[]数组&nbsp;&nbsp;\n&nbsp; &nbsp; Object[] result = new Object[size];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int i = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 将链表中所有节点的数据都添加到Object[]数组中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[i++] = e.element;&nbsp;&nbsp;\n&nbsp; &nbsp; return result;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型&nbsp;&nbsp;\n&nbsp; &nbsp; public &lt;T&gt; T[] toArray(T[] a) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (a.length &lt; size)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = (T[])java.lang.reflect.Array.newInstance(&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a.getClass().getComponentType(), size);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 将链表中所有节点的数据都添加到数组a中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int i = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Object[] result = a;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[i++] = e.element;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (a.length &gt; size)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a[size] = null;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return a;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 克隆函数。返回LinkedList的克隆对象。&nbsp;&nbsp;\n&nbsp; &nbsp; public Object clone() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; LinkedList&lt;E&gt; clone = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 克隆一个LinkedList克隆对象&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; try {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clone = (LinkedList&lt;E&gt;) super.clone();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } catch (CloneNotSupportedException e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new InternalError();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 新建LinkedList表头节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; clone.header = new Entry&lt;E&gt;(null, null, null);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; clone.header.next = clone.header.previous = clone.header;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; clone.size = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; clone.modCount = 0;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 将链表中所有节点的数据都添加到克隆对象中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clone.add(e.element);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return clone;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // java.io.Serializable的写入函数&nbsp;&nbsp;\n&nbsp; &nbsp; // 将LinkedList的“容量，所有的元素值”都写入到输出流中&nbsp;&nbsp;\n&nbsp; &nbsp; private void writeObject(java.io.ObjectOutputStream s)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; throws java.io.IOException {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Write out any hidden serialization magic&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; s.defaultWriteObject();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 写入“容量”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; s.writeInt(size);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 将链表中所有节点的数据都写入到输出流中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry e = header.next; e != header; e = e.next)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.writeObject(e.element);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // java.io.Serializable的读取函数：根据写入方式反向读出&nbsp;&nbsp;\n&nbsp; &nbsp; // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出&nbsp;&nbsp;\n&nbsp; &nbsp; private void readObject(java.io.ObjectInputStream s)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; throws java.io.IOException, ClassNotFoundException {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Read in any hidden serialization magic&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; s.defaultReadObject();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 从输入流中读取“容量”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int size = s.readInt();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 新建链表表头节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; header = new Entry&lt;E&gt;(null, null, null);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; header.next = header.previous = header;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 从输入流中将“所有的元素值”并逐个添加到链表中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i=0; i&lt;size; i++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addBefore((E)s.readObject(), header);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n}&nbsp;<br></code></pre><p><br></p><h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b style=\"\">三、几点总结</b></span></h1><p style=\"text-align: justify;\">&nbsp; &nbsp;&nbsp;关于LinkedList的源码，给出几点比较重要的总结：</p><p style=\"text-align: justify;\">&nbsp; &nbsp; 1、从源码中很明显可以看出，LinkedList的实现是基于<span style=\"color: rgb(255, 0, 0);\">双向循环链表</span>的，且头结点中不存放数据，如下图;</p><p style=\"text-align: center;\"><img alt=\"1.jpg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/20/saysky/1529457274546\" width=\"570\" height=\"230\"><img src=\"https://img-blog.csdn.net/20140629153056171\" alt=\"\"><br></p><p>&nbsp; &nbsp; 2、注意两个不同的构造方法。无参构造方法直接建立一个仅包含head节点的空链表，包含Collection的构造方法，先调用无参构造方法建立一个空链表，而后将Collection中的数据加入到链表的尾部后面。</p><p>&nbsp; &nbsp; 3、在查找和删除某元素时，源码中都划分为该元素为null和不为null两种情况来处理，LinkedList中允许元素为null。</p><p>&nbsp; &nbsp; 4、LinkedList是基于链表实现的，因此不存在容量不足的问题，所以这里没有扩容的方法。</p><p></p><p style=\"text-align: justify;\">&nbsp; &nbsp; 5、注意源码中的Entry&lt;E&gt;&nbsp;entry(<span style=\"color: rgb(0, 102, 153);\">int</span>&nbsp;index)方法。该方法返回双向链表中指定位置处的节点，而链表中是没有下标索引的，要指定位置出的元素，就要遍历该链表，从源码的实现中，我们看到这里有一个<span style=\"color: rgb(255, 0, 0);\">加速动作</span>。<span style=\"color: rgb(255, 0, 0);\">源码中先将index与长度size的一半比较，如果index&lt;size/2，就只从位置0往后遍历到位置index处，而如果index&gt;size/2，就只从位置size往前遍历到位置index处。这样可以减少一部分不必要的遍历，从而提高一定的效率（实际上效率还是很低）。</span></p><p>&nbsp; &nbsp; 6、注意链表类对应的数据结构Entry。如下:</p><pre><code class=\"lang-java\">&nbsp; &nbsp; // 双向链表的节点所对应的数据结构。&nbsp;&nbsp;\n&nbsp; &nbsp; // 包含3部分：上一节点，下一节点，当前节点值。&nbsp;&nbsp;\n&nbsp; &nbsp; private static class Entry&lt;E&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 当前节点所包含的值&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; E element;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 下一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;E&gt; next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 上一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;E&gt; previous;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; /**&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 链表节点的构造函数。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 参数说明：&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*&nbsp; &nbsp;element&nbsp; —— 节点所包含的数据&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*&nbsp; &nbsp;next&nbsp; &nbsp; &nbsp; —— 下一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*&nbsp; &nbsp;previous —— 上一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.element = element;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.next = next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.previous = previous;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;<br></code></pre><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; 7、</span><span style=\"font-size: 14px; color: rgb(255, 0, 0);\">LinkedList是基于链表实现的，因此插入删除效率高，查找效率低（虽然有一个加速动作）</span><span style=\"font-size: 14px;\">。</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; 8、要注意源码中还实现了栈和队列的操作方法，因此也可以作为栈、队列和双端队列来使用。</span></p><p><span style=\"font-size: 14px;\"><br></span></p><p><span style=\"font-size: 14px;\"><br></span></p><p><span style=\"font-size: 14px;\">原文地址：<a href=\"https://blog.csdn.net/ns_code/article/details/35787253\" target=\"_blank\">https://blog.csdn.net/ns_code/article/details/35787253</a></span></p>', '2018-06-20 09:17:10', '/articles/10014', '0', '0', 'publish', '一、LinkedList简介    Li', 'Java,LinkedList,源码', '【Java集合源码剖析】LinkedList源码剖析', '2018-09-06 10:48:57', '10', '0', '10006', '1'), ('10015', '0', '0', '<h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b style=\"\">一、ArrayList简介</b></span></h1><p style=\"text-align: justify;\">&nbsp; &nbsp; ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; ArrayList不是线程安全的，只能用在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。</p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"><br></span></p><h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b style=\"\">二、ArrayList源码剖析</b></span></h1><p style=\"text-align: justify;\">&nbsp; &nbsp; ArrayList的源码如下（加入了比较详细的注释）：</p><pre><code class=\"lang-java\">package java.util;&nbsp;&nbsp;\n&nbsp;\npublic class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&nbsp;&nbsp;\n{&nbsp;&nbsp;\n&nbsp; &nbsp; // 序列版本号&nbsp;&nbsp;\n&nbsp; &nbsp; private static final long serialVersionUID = 8683452581122892189L;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // ArrayList基于该数组实现，用该数组保存数据&nbsp;\n&nbsp; &nbsp; private transient Object[] elementData;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // ArrayList中实际数据的数量&nbsp;&nbsp;\n&nbsp; &nbsp; private int size;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // ArrayList带容量大小的构造函数。&nbsp;&nbsp;\n&nbsp; &nbsp; public ArrayList(int initialCapacity) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; super();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (initialCapacity &lt; 0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalArgumentException(\"Illegal Capacity: \"+&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;initialCapacity);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 新建一个数组&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this.elementData = new Object[initialCapacity];&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // ArrayList无参构造函数。默认容量是10。&nbsp;&nbsp;\n&nbsp; &nbsp; public ArrayList() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this(10);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 创建一个包含collection的ArrayList&nbsp;&nbsp;\n&nbsp; &nbsp; public ArrayList(Collection&lt;? extends E&gt; c) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData = c.toArray();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; size = elementData.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (elementData.getClass() != Object[].class)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elementData = Arrays.copyOf(elementData, size, Object[].class);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将当前容量值设为实际元素个数&nbsp;&nbsp;\n&nbsp; &nbsp; public void trimToSize() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int oldCapacity = elementData.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (size &lt; oldCapacity) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elementData = Arrays.copyOf(elementData, size);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 确定ArrarList的容量。&nbsp;&nbsp;\n&nbsp; &nbsp; // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2 + 1”&nbsp;&nbsp;\n&nbsp; &nbsp; public void ensureCapacity(int minCapacity) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 将“修改统计数”+1，该变量主要是用来实现fail-fast机制的&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int oldCapacity = elementData.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (minCapacity &gt; oldCapacity) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object oldData[] = elementData;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int newCapacity = (oldCapacity * 3)/2 + 1;&nbsp;&nbsp;\n			//如果还不够，则直接将minCapacity设置为当前容量\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (newCapacity &lt; minCapacity)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newCapacity = minCapacity;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elementData = Arrays.copyOf(elementData, newCapacity);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 添加元素e&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean add(E e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 确定ArrayList的容量大小&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; ensureCapacity(size + 1);&nbsp; // Increments modCount!!&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 添加e到ArrayList中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData[size++] = e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回ArrayList的实际大小&nbsp;&nbsp;\n&nbsp; &nbsp; public int size() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return size;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // ArrayList是否包含Object(o)&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean contains(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return indexOf(o) &gt;= 0;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; //返回ArrayList是否为空&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean isEmpty() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return size == 0;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 正向查找，返回元素的索引值&nbsp;&nbsp;\n&nbsp; &nbsp; public int indexOf(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (o == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; size; i++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (elementData[i]==null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return i;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; size; i++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (o.equals(elementData[i]))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return i;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -1;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 反向查找，返回元素的索引值&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public int lastIndexOf(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (o == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = size-1; i &gt;= 0; i--)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (elementData[i]==null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return i;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = size-1; i &gt;= 0; i--)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (o.equals(elementData[i]))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return i;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return -1;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 反向查找(从数组末尾向开始查找)，返回元素(o)的索引值&nbsp;&nbsp;\n&nbsp; &nbsp; public int lastIndexOf(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (o == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = size-1; i &gt;= 0; i--)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (elementData[i]==null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return i;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = size-1; i &gt;= 0; i--)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (o.equals(elementData[i]))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return i;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return -1;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回ArrayList的Object数组&nbsp;&nbsp;\n&nbsp; &nbsp; public Object[] toArray() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return Arrays.copyOf(elementData, size);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回ArrayList元素组成的数组\n&nbsp; &nbsp; public &lt;T&gt; T[] toArray(T[] a) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若数组a的大小 &lt; ArrayList的元素个数；&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (a.length &lt; size)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return (T[]) Arrays.copyOf(elementData, size, a.getClass());&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若数组a的大小 &gt;= ArrayList的元素个数；&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 则将ArrayList的全部元素都拷贝到数组a中。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(elementData, 0, a, 0, size);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (a.length &gt; size)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a[size] = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return a;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 获取index位置的元素值&nbsp;&nbsp;\n&nbsp; &nbsp; public E get(int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; RangeCheck(index);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return (E) elementData[index];&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 设置index位置的值为element&nbsp;&nbsp;\n&nbsp; &nbsp; public E set(int index, E element) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; RangeCheck(index);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; E oldValue = (E) elementData[index];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData[index] = element;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return oldValue;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将e添加到ArrayList中&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean add(E e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; ensureCapacity(size + 1);&nbsp; // Increments modCount!!&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData[size++] = e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将e添加到ArrayList的指定位置&nbsp;&nbsp;\n&nbsp; &nbsp; public void add(int index, E element) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (index &gt; size || index &lt; 0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IndexOutOfBoundsException(&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"Index: \"+index+\", Size: \"+size);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; ensureCapacity(size+1);&nbsp; // Increments modCount!!&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(elementData, index, elementData, index + 1,&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;size - index);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData[index] = element;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; size++;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除ArrayList指定位置的元素&nbsp;&nbsp;\n&nbsp; &nbsp; public E remove(int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; RangeCheck(index);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; E oldValue = (E) elementData[index];&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int numMoved = size - index - 1;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (numMoved &gt; 0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(elementData, index+1, elementData, index,&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;numMoved);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData[--size] = null; // Let gc do its work&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return oldValue;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除ArrayList的指定元素&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean remove(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (o == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int index = 0; index &lt; size; index++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (elementData[index] == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fastRemove(index);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int index = 0; index &lt; size; index++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (o.equals(elementData[index])) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fastRemove(index);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 快速删除第index个元素&nbsp;&nbsp;\n&nbsp; &nbsp; private void fastRemove(int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int numMoved = size - index - 1;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 从\"index+1\"开始，用后面的元素替换前面的元素。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (numMoved &gt; 0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(elementData, index+1, elementData, index,&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;numMoved);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 将最后一个元素设为null&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData[--size] = null; // Let gc do its work&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除元素&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean remove(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (o == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int index = 0; index &lt; size; index++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (elementData[index] == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fastRemove(index);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 便利ArrayList，找到“元素o”，则删除，并返回true。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int index = 0; index &lt; size; index++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (o.equals(elementData[index])) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fastRemove(index);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 清空ArrayList，将全部的元素设为null&nbsp;&nbsp;\n&nbsp; &nbsp; public void clear() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; size; i++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elementData[i] = null;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; size = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将集合c追加到ArrayList中&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean addAll(Collection&lt;? extends E&gt; c) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Object[] a = c.toArray();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int numNew = a.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; ensureCapacity(size + numNew);&nbsp; // Increments modCount&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(a, 0, elementData, size, numNew);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; size += numNew;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return numNew != 0;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 从index位置开始，将集合c添加到ArrayList&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean addAll(int index, Collection&lt;? extends E&gt; c) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (index &gt; size || index &lt; 0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IndexOutOfBoundsException(&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"Index: \" + index + \", Size: \" + size);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Object[] a = c.toArray();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int numNew = a.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; ensureCapacity(size + numNew);&nbsp; // Increments modCount&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int numMoved = size - index;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (numMoved &gt; 0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(elementData, index, elementData, index + numNew,&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;numMoved);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(a, 0, elementData, index, numNew);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; size += numNew;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return numNew != 0;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除fromIndex到toIndex之间的全部元素。&nbsp;&nbsp;\n&nbsp; &nbsp; protected void removeRange(int fromIndex, int toIndex) {&nbsp;&nbsp;\n&nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; int numMoved = size - toIndex;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(elementData, toIndex, elementData, fromIndex,&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;numMoved);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // Let gc do its work&nbsp;&nbsp;\n&nbsp; &nbsp; int newSize = size - (toIndex-fromIndex);&nbsp;&nbsp;\n&nbsp; &nbsp; while (size != newSize)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData[--size] = null;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; private void RangeCheck(int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; if (index &gt;= size)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; throw new IndexOutOfBoundsException(&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; \"Index: \"+index+\", Size: \"+size);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 克隆函数&nbsp;&nbsp;\n&nbsp; &nbsp; public Object clone() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; try {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 将当前ArrayList的全部元素拷贝到v中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v.elementData = Arrays.copyOf(elementData, size);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v.modCount = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return v;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } catch (CloneNotSupportedException e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // this shouldn\'t happen, since we are Cloneable&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new InternalError();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp;\n&nbsp; &nbsp; // java.io.Serializable的写入函数&nbsp;&nbsp;\n&nbsp; &nbsp; // 将ArrayList的“容量，所有的元素值”都写入到输出流中&nbsp;&nbsp;\n&nbsp; &nbsp; private void writeObject(java.io.ObjectOutputStream s)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; throws java.io.IOException{&nbsp;&nbsp;\n&nbsp; &nbsp; // Write out element count, and any hidden stuff&nbsp;&nbsp;\n&nbsp; &nbsp; int expectedModCount = modCount;&nbsp;&nbsp;\n&nbsp; &nbsp; s.defaultWriteObject();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 写入“数组的容量”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; s.writeInt(elementData.length);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 写入“数组的每一个元素”&nbsp;&nbsp;\n&nbsp; &nbsp; for (int i=0; i&lt;size; i++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.writeObject(elementData[i]);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; if (modCount != expectedModCount) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ConcurrentModificationException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp;\n&nbsp; &nbsp; // java.io.Serializable的读取函数：根据写入方式读出&nbsp;&nbsp;\n&nbsp; &nbsp; // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出&nbsp;&nbsp;\n&nbsp; &nbsp; private void readObject(java.io.ObjectInputStream s)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; throws java.io.IOException, ClassNotFoundException {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Read in size, and any hidden stuff&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; s.defaultReadObject();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 从输入流中读取ArrayList的“容量”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int arrayLength = s.readInt();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Object[] a = elementData = new Object[arrayLength];&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 从输入流中将“所有的元素值”读出&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i=0; i&lt;size; i++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a[i] = s.readObject();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n}<br></code></pre><p><br></p><h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b style=\"\">三、几点总结</b></span></h1><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp; &nbsp;</span>&nbsp;关于ArrayList的源码，给出几点比较重要的总结：</p><p style=\"text-align: justify;\">&nbsp; &nbsp; 1、注意其三个不同的构造方法。<span style=\"color: rgb(255, 0, 0);\">无参构造方法构造的ArrayList的容量默认为10</span>，带有Collection参数的构造方法，将Collection转化为数组赋给ArrayList的实现数组elementData。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; 2、注意扩充容量的方法ensureCapacity。<span style=\"color: rgb(255, 0, 0);\">ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，</span><span style=\"color: rgb(227, 55, 55);\"><b>就设置新的容量为旧的容量的1.5倍加1</b></span><span style=\"color: rgb(255, 0, 0);\">，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用Arrays.copyof()方法将元素拷贝到新的数组（详见下面的第3点）。从中可以看出，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，</span><span style=\"color: rgb(65, 140, 175);\"><b>也因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList</b></span><span style=\"color: rgb(255, 0, 0);\">。</span></p><p style=\"text-align: justify;\">&nbsp; &nbsp; 3、ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法。我们有必要对这两个方法的实现做下深入的了解。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; 首先来看Arrays.copyof()方法。它有很多个重载的方法，但实现思路都是一样的，我们来看泛型版本的源码：</p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"></span></p><pre><code class=\"lang-java\">public&nbsp;static&nbsp;&lt;T&gt;&nbsp;T[]&nbsp;copyOf(T[]&nbsp;original,&nbsp;int&nbsp;newLength)&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(T[])&nbsp;copyOf(original,&nbsp;newLength,&nbsp;original.getClass());&nbsp;&nbsp;\n}&nbsp;&nbsp;<br></code></pre><p><span style=\"color: rgb(79, 79, 79);\">&nbsp;很明显调用了另一个copyof方法，该方法有三个参数，最后一个参数指明要转换的数据的类型，其源码如下：</span><br></p><pre><code class=\"lang-java\">public&nbsp;static&nbsp;&lt;T,U&gt;&nbsp;T[]&nbsp;copyOf(U[]&nbsp;original,&nbsp;int&nbsp;newLength,&nbsp;Class&lt;?&nbsp;extends&nbsp;T[]&gt;&nbsp;newType)&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;T[]&nbsp;copy&nbsp;=&nbsp;((Object)newType&nbsp;==&nbsp;(Object)Object[].class)&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;(T[])&nbsp;new&nbsp;Object[newLength]&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(T[])&nbsp;Array.newInstance(newType.getComponentType(),&nbsp;newLength);&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;System.arraycopy(original,&nbsp;0,&nbsp;copy,&nbsp;0,&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Math.min(original.length,&nbsp;newLength));&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;copy;&nbsp;&nbsp;\n}&nbsp;&nbsp;<br></code></pre><p style=\"text-align: justify;\"><span style=\"color: rgb(255, 0, 0);\"><span style=\"font-size: 14px;\">&nbsp; </span>&nbsp;&nbsp;</span><span style=\"color: rgb(255, 0, 0);\">这里可以很明显地看出，</span><span style=\"color: rgb(255, 0, 0);\">该方法实际上是在其内部又创建了一个长度为newlength的数组，调用System.arraycopy()方法，将原来数组中的元素复制到了新的数组中。</span></p><p style=\"text-align: justify;\">&nbsp; &nbsp; 下面来看System.arraycopy()方法。该方法被标记了native，调用了系统的C/C++代码，在JDK中是看不到的，但在openJDK中可以看到其源码。<span style=\"color: rgb(255, 0, 0);\">该函数实际上最终调用了</span><span style=\"color: rgb(255, 0, 0);\">C语言的memmove()函数，因此它可以保证同一个数组内元素的正确复制和移动，比一般的复制方法的实现效率要高很多，很适合用来批量处理数组。</span><span style=\"color: rgb(32, 147, 97);\"><b>Java强烈推荐在复制大量数组元素时用该方法，以取得更高的效率</b></span><span style=\"color: rgb(255, 0, 0);\">。</span></p><p style=\"text-align: justify;\">&nbsp; &nbsp; 4、注意ArrayList的两个转化为静态数组的toArray方法。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; 第一个，Object[]&nbsp;toArray()方法。该方法有可能会抛出java.lang.ClassCastException异常，如果直接用向下转型的方法，将整个ArrayList集合转变为指定类型的Array数组，便会抛出该异常，而如果转化为Array数组时不向下转型，而是将每个元素向下转型，则不会抛出该异常，显然对数组中的元素一个个进行向下转型，效率不高，且不太方便。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; 第二个，&lt;T&gt;&nbsp;T[]&nbsp;toArray(T[]&nbsp;a)方法。该方法可以直接将ArrayList转换得到的Array进行整体向下转型（转型其实是在该方法的源码中实现的），且从该方法的源码中可以看出，参数a的大小不足时，内部会调用Arrays.copyOf方法，该方法内部创建一个新的数组返回，因此对该方法的常用形式如下：</p><pre><code class=\"lang-java\">public&nbsp;static&nbsp;Integer[]&nbsp;vectorToArray2(ArrayList&lt;Integer&gt;&nbsp;v)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;Integer[]&nbsp;newText&nbsp;=&nbsp;(Integer[])v.toArray(new&nbsp;Integer[0]);&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;newText;&nbsp;&nbsp;&nbsp;&nbsp;\n<br></code></pre><p><br></p><p><br></p><p>原文地址：<a href=\"https://blog.csdn.net/ns_code/article/details/35568011\" target=\"_blank\">https://blog.csdn.net/ns_code/article/details/35568011</a></p>', '2018-06-20 10:23:09', '/articles/10015', '0', '0', 'publish', '一、ArrayList简介    Arr', 'Java,ArrayList,源码', '【Java集合源码剖析】ArrayList源码剖析', '2019-01-11 16:11:28', '14', '0', '10006', '1');
INSERT INTO `article` VALUES ('10016', '1', '0', '<h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b style=\"\">一、Vector简介</b></span></h1><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp; &nbsp;</span>&nbsp;Vector也是基于数组实现的，是一个动态数组，其容量能自动增长。</p><p style=\"text-align: justify;\">&nbsp; &nbsp;&nbsp;Vector是JDK1.0引入了，它的很多实现方法都加入了同步语句，因此是线程安全的（其实也只是相对安全，有些时候还是要加入同步语句来保证线程的安全），可以用于多线程环境。</p><p style=\"text-align: justify;\">&nbsp; &nbsp;&nbsp;Vector没有实现Serializable接口，因此它不支持序列化，实现了Cloneable接口，能被克隆，实现了RandomAccess接口，支持快速随机访问。</p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"><br></span></p><h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b>二、Vector源码剖析</b></span></h1><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp; &nbsp;&nbsp;Vector的源码如下（加入了比较详细的注释）：</span></p><pre><code class=\"lang-java\">package java.util;&nbsp;&nbsp;\n&nbsp;\npublic class Vector&lt;E&gt;&nbsp;&nbsp;\n&nbsp; &nbsp; extends AbstractList&lt;E&gt;&nbsp;&nbsp;\n&nbsp; &nbsp; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&nbsp;&nbsp;\n{&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; // 保存Vector中数据的数组&nbsp;&nbsp;\n&nbsp; &nbsp; protected Object[] elementData;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 实际数据的数量&nbsp;&nbsp;\n&nbsp; &nbsp; protected int elementCount;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 容量增长系数&nbsp;&nbsp;\n&nbsp; &nbsp; protected int capacityIncrement;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // Vector的序列版本号&nbsp;&nbsp;\n&nbsp; &nbsp; private static final long serialVersionUID = -2767605614048989439L;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // Vector构造函数。默认容量是10。&nbsp;&nbsp;\n&nbsp; &nbsp; public Vector() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this(10);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 指定Vector容量大小的构造函数&nbsp;&nbsp;\n&nbsp; &nbsp; public Vector(int initialCapacity) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this(initialCapacity, 0);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 指定Vector\"容量大小\"和\"增长系数\"的构造函数&nbsp;&nbsp;\n&nbsp; &nbsp; public Vector(int initialCapacity, int capacityIncrement) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; super();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (initialCapacity &lt; 0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalArgumentException(\"Illegal Capacity: \"+&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;initialCapacity);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 新建一个数组，数组容量是initialCapacity&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this.elementData = new Object[initialCapacity];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置容量增长系数&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this.capacityIncrement = capacityIncrement;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 指定集合的Vector构造函数。&nbsp;&nbsp;\n&nbsp; &nbsp; public Vector(Collection&lt;? extends E&gt; c) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 获取“集合(c)”的数组，并将其赋值给elementData&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData = c.toArray();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置数组长度&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementCount = elementData.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // c.toArray might (incorrectly) not return Object[] (see 6260652)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (elementData.getClass() != Object[].class)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elementData = Arrays.copyOf(elementData, elementCount, Object[].class);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将数组Vector的全部元素都拷贝到数组anArray中&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized void copyInto(Object[] anArray) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(elementData, 0, anArray, 0, elementCount);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将当前容量值设为 =实际元素个数&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized void trimToSize() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int oldCapacity = elementData.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (elementCount &lt; oldCapacity) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elementData = Arrays.copyOf(elementData, elementCount);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 确认“Vector容量”的帮助函数&nbsp;&nbsp;\n&nbsp; &nbsp; private void ensureCapacityHelper(int minCapacity) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int oldCapacity = elementData.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 当Vector的容量不足以容纳当前的全部元素，增加容量大小。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若 容量增量系数&gt;0(即capacityIncrement&gt;0)，则将容量增大当capacityIncrement&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 否则，将容量增大一倍。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (minCapacity &gt; oldCapacity) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object[] oldData = elementData;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int newCapacity = (capacityIncrement &gt; 0) ?&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (oldCapacity + capacityIncrement) : (oldCapacity * 2);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (newCapacity &lt; minCapacity) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newCapacity = minCapacity;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elementData = Arrays.copyOf(elementData, newCapacity);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 确定Vector的容量。&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized void ensureCapacity(int minCapacity) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 将Vector的改变统计数+1&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; ensureCapacityHelper(minCapacity);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 设置容量值为 newSize&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized void setSize(int newSize) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (newSize &gt; elementCount) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 若 \"newSize 大于 Vector容量\"，则调整Vector的大小。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ensureCapacityHelper(newSize);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 若 \"newSize 小于/等于 Vector容量\"，则将newSize位置开始的元素都设置为null&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = newSize ; i &lt; elementCount ; i++) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elementData[i] = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementCount = newSize;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回“Vector的总的容量”&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized int capacity() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return elementData.length;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回“Vector的实际大小”，即Vector中元素个数&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized int size() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return elementCount;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 判断Vector是否为空&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized boolean isEmpty() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return elementCount == 0;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回“Vector中全部元素对应的Enumeration”&nbsp;&nbsp;\n&nbsp; &nbsp; public Enumeration&lt;E&gt; elements() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 通过匿名类实现Enumeration&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return new Enumeration&lt;E&gt;() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int count = 0;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 是否存在下一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public boolean hasMoreElements() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return count &lt; elementCount;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 获取下一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public E nextElement() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; synchronized (Vector.this) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (count &lt; elementCount) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return (E)elementData[count++];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NoSuchElementException(\"Vector Enumeration\");&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; };&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回Vector中是否包含对象(o)&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean contains(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return indexOf(o, 0) &gt;= 0;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 从index位置开始向后查找元素(o)。&nbsp;&nbsp;\n&nbsp; &nbsp; // 若找到，则返回元素的索引值；否则，返回-1&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized int indexOf(Object o, int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (o == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 若查找元素为null，则正向找出null元素，并返回它对应的序号&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = index ; i &lt; elementCount ; i++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (elementData[i]==null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return i;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 若查找元素不为null，则正向找出该元素，并返回它对应的序号&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = index ; i &lt; elementCount ; i++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (o.equals(elementData[i]))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return i;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return -1;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 查找并返回元素(o)在Vector中的索引值&nbsp;&nbsp;\n&nbsp; &nbsp; public int indexOf(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return indexOf(o, 0);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 从后向前查找元素(o)。并返回元素的索引&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized int lastIndexOf(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return lastIndexOf(o, elementCount-1);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 从后向前查找元素(o)。开始位置是从前向后的第index个数；&nbsp;&nbsp;\n&nbsp; &nbsp; // 若找到，则返回元素的“索引值”；否则，返回-1。&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized int lastIndexOf(Object o, int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (index &gt;= elementCount)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IndexOutOfBoundsException(index + \" &gt;= \"+ elementCount);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (o == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 若查找元素为null，则反向找出null元素，并返回它对应的序号&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = index; i &gt;= 0; i--)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (elementData[i]==null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return i;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 若查找元素不为null，则反向找出该元素，并返回它对应的序号&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = index; i &gt;= 0; i--)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (o.equals(elementData[i]))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return i;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return -1;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回Vector中index位置的元素。&nbsp;&nbsp;\n&nbsp; &nbsp; // 若index月结，则抛出异常&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized E elementAt(int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (index &gt;= elementCount) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return (E)elementData[index];&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 获取Vector中的第一个元素。&nbsp;&nbsp;\n&nbsp; &nbsp; // 若失败，则抛出异常！&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized E firstElement() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (elementCount == 0) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NoSuchElementException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return (E)elementData[0];&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 获取Vector中的最后一个元素。&nbsp;&nbsp;\n&nbsp; &nbsp; // 若失败，则抛出异常！&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized E lastElement() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (elementCount == 0) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NoSuchElementException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return (E)elementData[elementCount - 1];&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 设置index位置的元素值为obj&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized void setElementAt(E obj, int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (index &gt;= elementCount) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" +&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;elementCount);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData[index] = obj;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除index位置的元素&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized void removeElementAt(int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (index &gt;= elementCount) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" +&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;elementCount);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } else if (index &lt; 0) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ArrayIndexOutOfBoundsException(index);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int j = elementCount - index - 1;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (j &gt; 0) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(elementData, index + 1, elementData, index, j);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementCount--;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData[elementCount] = null; /* to let gc do its work */&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 在index位置处插入元素(obj)&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized void insertElementAt(E obj, int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (index &gt; elementCount) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ArrayIndexOutOfBoundsException(index&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+ \" &gt; \" + elementCount);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; ensureCapacityHelper(elementCount + 1);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData[index] = obj;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将“元素obj”添加到Vector末尾&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized void addElement(E obj) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; ensureCapacityHelper(elementCount + 1);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData[elementCount++] = obj;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 在Vector中查找并删除元素obj。&nbsp;&nbsp;\n&nbsp; &nbsp; // 成功的话，返回true；否则，返回false。&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized boolean removeElement(Object obj) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int i = indexOf(obj);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (i &gt;= 0) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; removeElementAt(i);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除Vector中的全部元素&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized void removeAllElements() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 将Vector中的全部元素设为null&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; elementCount; i++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elementData[i] = null;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementCount = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 克隆函数&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized Object clone() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; try {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vector&lt;E&gt; v = (Vector&lt;E&gt;) super.clone();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 将当前Vector的全部元素拷贝到v中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v.elementData = Arrays.copyOf(elementData, elementCount);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v.modCount = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return v;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } catch (CloneNotSupportedException e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // this shouldn\'t happen, since we are Cloneable&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new InternalError();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回Object数组&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized Object[] toArray() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return Arrays.copyOf(elementData, elementCount);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回Vector的模板数组。所谓模板数组，即可以将T设为任意的数据类型&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized &lt;T&gt; T[] toArray(T[] a) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若数组a的大小 &lt; Vector的元素个数；&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 则新建一个T[]数组，数组大小是“Vector的元素个数”，并将“Vector”全部拷贝到新数组中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (a.length &lt; elementCount)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass());&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若数组a的大小 &gt;= Vector的元素个数；&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 则将Vector的全部元素都拷贝到数组a中。&nbsp;&nbsp;\n&nbsp; &nbsp; System.arraycopy(elementData, 0, a, 0, elementCount);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (a.length &gt; elementCount)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a[elementCount] = null;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return a;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 获取index位置的元素&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized E get(int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (index &gt;= elementCount)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ArrayIndexOutOfBoundsException(index);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return (E)elementData[index];&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 设置index位置的值为element。并返回index位置的原始值&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized E set(int index, E element) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (index &gt;= elementCount)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ArrayIndexOutOfBoundsException(index);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Object oldValue = elementData[index];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData[index] = element;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return (E)oldValue;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将“元素e”添加到Vector最后。&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized boolean add(E e) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; ensureCapacityHelper(elementCount + 1);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData[elementCount++] = e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除Vector中的元素o&nbsp;&nbsp;\n&nbsp; &nbsp; public boolean remove(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return removeElement(o);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 在index位置添加元素element&nbsp;&nbsp;\n&nbsp; &nbsp; public void add(int index, E element) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; insertElementAt(element, index);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除index位置的元素，并返回index位置的原始值&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized E remove(int index) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (index &gt;= elementCount)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ArrayIndexOutOfBoundsException(index);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Object oldValue = elementData[index];&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int numMoved = elementCount - index - 1;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (numMoved &gt; 0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(elementData, index+1, elementData, index,&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;numMoved);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementData[--elementCount] = null; // Let gc do its work&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return (E)oldValue;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 清空Vector&nbsp;&nbsp;\n&nbsp; &nbsp; public void clear() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; removeAllElements();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回Vector是否包含集合c&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized boolean containsAll(Collection&lt;?&gt; c) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return super.containsAll(c);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将集合c添加到Vector中&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized boolean addAll(Collection&lt;? extends E&gt; c) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Object[] a = c.toArray();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int numNew = a.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; ensureCapacityHelper(elementCount + numNew);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 将集合c的全部元素拷贝到数组elementData中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(a, 0, elementData, elementCount, numNew);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementCount += numNew;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return numNew != 0;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除集合c的全部元素&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized boolean removeAll(Collection&lt;?&gt; c) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return super.removeAll(c);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除“非集合c中的元素”&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized boolean retainAll(Collection&lt;?&gt; c)&nbsp; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return super.retainAll(c);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 从index位置开始，将集合c添加到Vector中&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (index &lt; 0 || index &gt; elementCount)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ArrayIndexOutOfBoundsException(index);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Object[] a = c.toArray();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int numNew = a.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; ensureCapacityHelper(elementCount + numNew);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int numMoved = elementCount - index;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (numMoved &gt; 0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(elementData, index, elementData, index + numNew, numMoved);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(a, 0, elementData, index, numNew);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; elementCount += numNew;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return numNew != 0;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回两个对象是否相等&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized boolean equals(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return super.equals(o);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 计算哈希值&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized int hashCode() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return super.hashCode();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 调用父类的toString()&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized String toString() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return super.toString();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 获取Vector中fromIndex(包括)到toIndex(不包括)的子集&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized List&lt;E&gt; subList(int fromIndex, int toIndex) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return Collections.synchronizedList(super.subList(fromIndex, toIndex), this);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除Vector中fromIndex到toIndex的元素&nbsp;&nbsp;\n&nbsp; &nbsp; protected synchronized void removeRange(int fromIndex, int toIndex) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int numMoved = elementCount - toIndex;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; System.arraycopy(elementData, toIndex, elementData, fromIndex,&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;numMoved);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Let gc do its work&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int newElementCount = elementCount - (toIndex-fromIndex);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; while (elementCount != newElementCount)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elementData[--elementCount] = null;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // java.io.Serializable的写入函数&nbsp;&nbsp;\n&nbsp; &nbsp; private synchronized void writeObject(java.io.ObjectOutputStream s)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; throws java.io.IOException {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; s.defaultWriteObject();&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n}&nbsp;\n<br></code></pre><p><br></p><h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b style=\"\">三、几点总结</b></span></h1><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp; </span>&nbsp;&nbsp;Vector的源码实现总体与ArrayList类似，关于Vector的源码，给出如下几点总结：</p><p style=\"text-align: justify;\">&nbsp; &nbsp; 1、Vector有四个不同的构造方法。无参构造方法的容量为默认值10，仅包含容量的构造方法则将容量增长量（从源码中可以看出容量增长量的作用，第二点也会对容量增长量详细说）明置为0。</p><p style=\"text-align: justify;\"><span style=\"color: rgb(54, 46, 43);\">&nbsp; &nbsp; 2、注意扩充容量的方法</span><span style=\"color: rgb(54, 46, 43);\">ensureCapacityHelper。</span><span style=\"color: rgb(255, 0, 0);\">与ArrayList相同，Vector在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就先看构造方法中传入的容量增长量参数CapacityIncrement是否为0，如果不为0，就设置新的容量为就容量加上容量增长量，如果为0，就</span><span style=\"color: rgb(255, 0, 0);\">设置新的容量为旧的容量的2倍，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后同样用Arrays.copyof()方法将元素拷贝到新的数组。</span></p><p style=\"text-align: justify;\">&nbsp; &nbsp; 3、<span style=\"color: rgb(65, 140, 175);\"><b>很多方法都加入了synchronized同步语句，来保证线程安全</b></span>。</p><p>&nbsp; &nbsp; 4、同样<span style=\"color: rgb(54, 46, 43);\">在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，Vector中也允许元素为null。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(54, 46, 43);\">&nbsp; &nbsp; 5、其他很多地方都与ArrayList实现大同小异，Vector现在已经基本不再使用。</span><span style=\"color: rgb(0, 0, 153);\">&nbsp;</span></p><p><span style=\"font-size: 14px;\"><span style=\"color: rgb(0, 0, 153);\"><br></span></span><br></p><p>原文地址：<a href=\"https://blog.csdn.net/ns_code/article/details/35793865\" target=\"_blank\">https://blog.csdn.net/ns_code/article/details/35793865</a></p>', '2018-06-20 10:30:31', '/articles/10016', '0', '0', 'publish', '一、Vector简介<span style=\"font-si', 'Java,Vector,源码', '【Java集合源码剖析】Vector源码剖析', '2018-12-26 16:49:38', '7', '0', '10006', '1'), ('10017', '0', '1', '<h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b style=\"\">一、Hashtable简介</b></span></h1><p style=\"text-align: justify;\">&nbsp; &nbsp; Hashtable同样是基于哈希表实现的，同样每个元素是一个key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; Hashtable也是JDK1.0引入的类，是线程安全的，能用于多线程环境中。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; Hashtable同样实现了Serializable接口，它支持序列化，实现了Cloneable接口，能被克隆。</p><h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b>二、HashTable源码剖析</b></span></h1><p style=\"text-align: justify;\">&nbsp; &nbsp; Hashtable的源码的很多实现都与HashMap差不多，源码如下（加入了比较详细的注释）：</p><pre><code>package java.util;&nbsp;&nbsp;\nimport java.io.*;&nbsp;&nbsp;\n&nbsp;\npublic class Hashtable&lt;K,V&gt;&nbsp;&nbsp;\n&nbsp; &nbsp; extends Dictionary&lt;K,V&gt;&nbsp;&nbsp;\n&nbsp; &nbsp; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable {&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 保存key-value的数组。&nbsp;&nbsp;\n&nbsp; &nbsp; // Hashtable同样采用单链表解决冲突，每一个Entry本质上是一个单向链表&nbsp;&nbsp;\n&nbsp; &nbsp; private transient Entry[] table;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // Hashtable中键值对的数量&nbsp;&nbsp;\n&nbsp; &nbsp; private transient int count;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子）&nbsp;&nbsp;\n&nbsp; &nbsp; private int threshold;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 加载因子&nbsp;&nbsp;\n&nbsp; &nbsp; private float loadFactor;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // Hashtable被改变的次数，用于fail-fast机制的实现&nbsp;&nbsp;\n&nbsp; &nbsp; private transient int modCount = 0;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 序列版本号&nbsp;&nbsp;\n&nbsp; &nbsp; private static final long serialVersionUID = 1421746759512286392L;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 指定“容量大小”和“加载因子”的构造函数&nbsp;&nbsp;\n&nbsp; &nbsp; public Hashtable(int initialCapacity, float loadFactor) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (initialCapacity &lt; 0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalArgumentException(\"Illegal Capacity: \"+&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;initialCapacity);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalArgumentException(\"Illegal Load: \"+loadFactor);&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (initialCapacity==0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initialCapacity = 1;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this.loadFactor = loadFactor;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; table = new Entry[initialCapacity];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; threshold = (int)(initialCapacity * loadFactor);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 指定“容量大小”的构造函数&nbsp;&nbsp;\n&nbsp; &nbsp; public Hashtable(int initialCapacity) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this(initialCapacity, 0.75f);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 默认构造函数。&nbsp;&nbsp;\n&nbsp; &nbsp; public Hashtable() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 默认构造函数，指定的容量大小是11；加载因子是0.75&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this(11, 0.75f);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 包含“子Map”的构造函数&nbsp;&nbsp;\n&nbsp; &nbsp; public Hashtable(Map&lt;? extends K, ? extends V&gt; t) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this(Math.max(2*t.size(), 11), 0.75f);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 将“子Map”的全部元素都添加到Hashtable中&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; putAll(t);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; public synchronized int size() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return count;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; public synchronized boolean isEmpty() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return count == 0;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回“所有key”的枚举对象&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized Enumeration&lt;K&gt; keys() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return this.&lt;K&gt;getEnumeration(KEYS);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回“所有value”的枚举对象&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized Enumeration&lt;V&gt; elements() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return this.&lt;V&gt;getEnumeration(VALUES);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 判断Hashtable是否包含“值(value)”&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized boolean contains(Object value) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; //注意，Hashtable中的value不能是null，&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若是null的话，抛出异常!&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (value == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NullPointerException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 从后向前遍历table数组中的元素(Entry)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry tab[] = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i = tab.length ; i-- &gt; 0 ;) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = tab[i] ; e != null ; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.value.equals(value)) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; public boolean containsValue(Object value) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return contains(value);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 判断Hashtable是否包含key&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized boolean containsKey(Object key) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry tab[] = table;&nbsp;&nbsp;\n		//计算hash值，直接用key的hashCode代替\n&nbsp; &nbsp; &nbsp; &nbsp; int hash = key.hashCode();&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 计算在数组中的索引值&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int index = (hash &amp; 0x7FFFFFFF) % tab.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回key对应的value，没有的话返回null&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized V get(Object key) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry tab[] = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int hash = key.hashCode();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 计算索引值，&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int index = (hash &amp; 0x7FFFFFFF) % tab.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return e.value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 调整Hashtable的长度，将长度变成原来的2倍+1&nbsp;\n&nbsp; &nbsp; protected void rehash() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int oldCapacity = table.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry[] oldMap = table;&nbsp;&nbsp;\n&nbsp;\n		//创建新容量大小的Entry数组\n&nbsp; &nbsp; &nbsp; &nbsp; int newCapacity = oldCapacity * 2 + 1;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry[] newMap = new Entry[newCapacity];&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; threshold = (int)(newCapacity * loadFactor);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; table = newMap;&nbsp;&nbsp;\n		\n		//将“旧的Hashtable”中的元素复制到“新的Hashtable”中\n		for (int i = oldCapacity ; i-- &gt; 0 ;) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; e = old;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old = old.next;&nbsp;&nbsp;\n				//重新计算index\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.next = newMap[index];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newMap[index] = e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将“key-value”添加到Hashtable中&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized V put(K key, V value) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Hashtable中不能插入value为null的元素！！！&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (value == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NullPointerException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若“Hashtable中已存在键为key的键值对”，&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 则用“新的value”替换“旧的value”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry tab[] = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int hash = key.hashCode();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int index = (hash &amp; 0x7FFFFFFF) % tab.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; V old = e.value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.value = value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return old;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若“Hashtable中不存在键为key的键值对”，\n&nbsp; &nbsp; &nbsp; &nbsp; // 将“修改统计数”+1&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; //&nbsp; 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; //&nbsp; 则调整Hashtable的大小&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (count &gt;= threshold) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rehash();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = (hash &amp; 0x7FFFFFFF) % tab.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; //将新的key-value对插入到tab[index]处（即链表的头结点）\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; e = tab[index];&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; count++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 删除Hashtable中键为key的元素&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized V remove(Object key) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry tab[] = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int hash = key.hashCode();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int index = (hash &amp; 0x7FFFFFFF) % tab.length;&nbsp;&nbsp;\n		\n&nbsp; &nbsp; &nbsp; &nbsp; //从table[index]链表中找出要删除的节点，并删除该节点。\n		//因为是单链表，因此要保留带删节点的前一个节点，才能有效地删除节点\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = tab[index], prev = null ; e != null ; prev = e, e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (prev != null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev.next = e.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab[index] = e.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count--;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; V oldValue = e.value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.value = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return oldValue;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return null;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 将“Map(t)”的中全部元素逐一添加到Hashtable中&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet())&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(e.getKey(), e.getValue());&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 清空Hashtable&nbsp;&nbsp;\n&nbsp; &nbsp; // 将Hashtable的table数组的值全部设为null&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized void clear() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry tab[] = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int index = tab.length; --index &gt;= 0; )&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab[index] = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; count = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 克隆一个Hashtable，并以Object的形式返回。&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized Object clone() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; try {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) super.clone();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t.table = new Entry[table.length];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = table.length ; i-- &gt; 0 ; ) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t.table[i] = (table[i] != null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? (Entry&lt;K,V&gt;) table[i].clone() : null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t.keySet = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t.entrySet = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t.values = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t.modCount = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return t;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } catch (CloneNotSupportedException e) {&nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new InternalError();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; public synchronized String toString() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int max = size() - 1;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (max == -1)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return \"{}\";&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; StringBuilder sb = new StringBuilder();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet().iterator();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; sb.append(\'{\');&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; ; i++) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Map.Entry&lt;K,V&gt; e = it.next();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K key = e.getKey();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; V value = e.getValue();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sb.append(key&nbsp; &nbsp;== this ? \"(this Map)\" : key.toString());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sb.append(\'=\');&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sb.append(value == this ? \"(this Map)\" : value.toString());&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i == max)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return sb.append(\'}\').toString();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sb.append(\", \");&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 获取Hashtable的枚举类对象&nbsp;&nbsp;\n&nbsp; &nbsp; // 若Hashtable的实际大小为0,则返回“空枚举类”对象；&nbsp;&nbsp;\n&nbsp; &nbsp; // 否则，返回正常的Enumerator的对象。&nbsp;\n&nbsp; &nbsp; private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type) {&nbsp;&nbsp;\n&nbsp; &nbsp; if (count == 0) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return (Enumeration&lt;T&gt;)emptyEnumerator;&nbsp;&nbsp;\n&nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return new Enumerator&lt;T&gt;(type, false);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 获取Hashtable的迭代器&nbsp;&nbsp;\n&nbsp; &nbsp; // 若Hashtable的实际大小为0,则返回“空迭代器”对象；&nbsp;&nbsp;\n&nbsp; &nbsp; // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口)&nbsp;&nbsp;\n&nbsp; &nbsp; private &lt;T&gt; Iterator&lt;T&gt; getIterator(int type) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (count == 0) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return (Iterator&lt;T&gt;) emptyIterator;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return new Enumerator&lt;T&gt;(type, true);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // Hashtable的“key的集合”。它是一个Set，没有重复元素&nbsp;&nbsp;\n&nbsp; &nbsp; private transient volatile Set&lt;K&gt; keySet = null;&nbsp;&nbsp;\n&nbsp; &nbsp; // Hashtable的“key-value的集合”。它是一个Set，没有重复元素&nbsp;&nbsp;\n&nbsp; &nbsp; private transient volatile Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;&nbsp;&nbsp;\n&nbsp; &nbsp; // Hashtable的“key-value的集合”。它是一个Collection，可以有重复元素&nbsp;&nbsp;\n&nbsp; &nbsp; private transient volatile Collection&lt;V&gt; values = null;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回一个被synchronizedSet封装后的KeySet对象&nbsp;&nbsp;\n&nbsp; &nbsp; // synchronizedSet封装的目的是对KeySet的所有方法都添加synchronized，实现多线程同步&nbsp;&nbsp;\n&nbsp; &nbsp; public Set&lt;K&gt; keySet() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (keySet == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keySet = Collections.synchronizedSet(new KeySet(), this);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return keySet;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // Hashtable的Key的Set集合。&nbsp;&nbsp;\n&nbsp; &nbsp; // KeySet继承于AbstractSet，所以，KeySet中的元素没有重复的。&nbsp;&nbsp;\n&nbsp; &nbsp; private class KeySet extends AbstractSet&lt;K&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public Iterator&lt;K&gt; iterator() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return getIterator(KEYS);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public int size() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return count;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean contains(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return containsKey(o);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean remove(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Hashtable.this.remove(o) != null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public void clear() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Hashtable.this.clear();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回一个被synchronizedSet封装后的EntrySet对象&nbsp;&nbsp;\n&nbsp; &nbsp; // synchronizedSet封装的目的是对EntrySet的所有方法都添加synchronized，实现多线程同步&nbsp;&nbsp;\n&nbsp; &nbsp; public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (entrySet==null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entrySet = Collections.synchronizedSet(new EntrySet(), this);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return entrySet;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // Hashtable的Entry的Set集合。&nbsp;&nbsp;\n&nbsp; &nbsp; // EntrySet继承于AbstractSet，所以，EntrySet中的元素没有重复的。&nbsp;&nbsp;\n&nbsp; &nbsp; private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return getIterator(ENTRIES);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean add(Map.Entry&lt;K,V&gt; o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return super.add(o);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 查找EntrySet中是否包含Object(0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 首先，在table中找到o对应的Entry链表&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 然后，查找Entry链表中是否存在Object&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean contains(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(o instanceof Map.Entry))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Map.Entry entry = (Map.Entry)o;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object key = entry.getKey();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry[] tab = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int hash = key.hashCode();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int index = (hash &amp; 0x7FFFFFFF) % tab.length;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry e = tab[index]; e != null; e = e.next)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.hash==hash &amp;&amp; e.equals(entry))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 删除元素Object(0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 首先，在table中找到o对应的Entry链表\n&nbsp; &nbsp; &nbsp; &nbsp; // 然后，删除链表中的元素Object&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean remove(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(o instanceof Map.Entry))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K key = entry.getKey();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry[] tab = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int hash = key.hashCode();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int index = (hash &amp; 0x7FFFFFFF) % tab.length;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;prev = e, e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.hash==hash &amp;&amp; e.equals(entry)) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (prev != null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev.next = e.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab[index] = e.next;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count--;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.value = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public int size() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return count;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public void clear() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Hashtable.this.clear();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 返回一个被synchronizedCollection封装后的ValueCollection对象&nbsp;&nbsp;\n&nbsp; &nbsp; // synchronizedCollection封装的目的是对ValueCollection的所有方法都添加synchronized，实现多线程同步&nbsp;&nbsp;\n&nbsp; &nbsp; public Collection&lt;V&gt; values() {&nbsp;&nbsp;\n&nbsp; &nbsp; if (values==null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; values = Collections.synchronizedCollection(new ValueCollection(),&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return values;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // Hashtable的value的Collection集合。&nbsp;&nbsp;\n&nbsp; &nbsp; // ValueCollection继承于AbstractCollection，所以，ValueCollection中的元素可以重复的。&nbsp;&nbsp;\n&nbsp; &nbsp; private class ValueCollection extends AbstractCollection&lt;V&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public Iterator&lt;V&gt; iterator() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return getIterator(VALUES);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public int size() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return count;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean contains(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return containsValue(o);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public void clear() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Hashtable.this.clear();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 重新equals()函数&nbsp;&nbsp;\n&nbsp; &nbsp; // 若两个Hashtable的所有key-value键值对都相等，则判断它们两个相等&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized boolean equals(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (o == this)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (!(o instanceof Map))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Map&lt;K,V&gt; t = (Map&lt;K,V&gt;) o;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (t.size() != size())&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; try {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 通过迭代器依次取出当前Hashtable的key-value键值对&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 并判断该键值对，存在于Hashtable中。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 若不存在，则立即返回false；否则，遍历完“当前Hashtable”并返回true。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (i.hasNext()) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Map.Entry&lt;K,V&gt; e = i.next();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K key = e.getKey();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; V value = e.getValue();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (value == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(t.get(key)==null &amp;&amp; t.containsKey(key)))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!value.equals(t.get(key)))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } catch (ClassCastException unused)&nbsp; &nbsp;{&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; } catch (NullPointerException unused) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 计算Entry的hashCode&nbsp;&nbsp;\n&nbsp; &nbsp; // 若 Hashtable的实际大小为0 或者 加载因子&lt;0，则返回0。&nbsp;&nbsp;\n&nbsp; &nbsp; // 否则，返回“Hashtable中的每个Entry的key和value的异或值 的总和”。&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized int hashCode() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int h = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (count == 0 || loadFactor &lt; 0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return h;&nbsp; // Returns zero&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; loadFactor = -loadFactor;&nbsp; // Mark hashCode computation in progress&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry[] tab = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; tab.length; i++)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry e = tab[i]; e != null; e = e.next)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; h += e.key.hashCode() ^ e.value.hashCode();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; loadFactor = -loadFactor;&nbsp; // Mark hashCode computation complete&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return h;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // java.io.Serializable的写入函数&nbsp;&nbsp;\n&nbsp; &nbsp; // 将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中&nbsp;&nbsp;\n&nbsp; &nbsp; private synchronized void writeObject(java.io.ObjectOutputStream s)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; throws IOException&nbsp;&nbsp;\n&nbsp; &nbsp; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Write out the length, threshold, loadfactor&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; s.defaultWriteObject();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Write out length, count of elements and then the key/value objects&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; s.writeInt(table.length);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; s.writeInt(count);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int index = table.length-1; index &gt;= 0; index--) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry entry = table[index];&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (entry != null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.writeObject(entry.key);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.writeObject(entry.value);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry = entry.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // java.io.Serializable的读取函数：根据写入方式读出&nbsp;&nbsp;\n&nbsp; &nbsp; // 将Hashtable的“总的容量，实际容量，所有的Entry”依次读出&nbsp;&nbsp;\n&nbsp; &nbsp; private void readObject(java.io.ObjectInputStream s)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;throws IOException, ClassNotFoundException&nbsp;&nbsp;\n&nbsp; &nbsp; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Read in the length, threshold, and loadfactor&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; s.defaultReadObject();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Read the original length of the array and number of elements&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int origlength = s.readInt();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int elements = s.readInt();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Compute new size with a bit of room 5% to grow but&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // no larger than the original size.&nbsp; Make the length&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // odd if it\'s large enough, this helps distribute the entries.&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Guard against the length ending up zero, that\'s not valid.&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int length = (int)(elements * loadFactor) + (elements / 20) + 3;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (length &gt; elements &amp;&amp; (length &amp; 1) == 0)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length--;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (origlength &gt; 0 &amp;&amp; length &gt; origlength)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length = origlength;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry[] table = new Entry[length];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; count = 0;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Read the number of elements and then all the key/value objects&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (; elements &gt; 0; elements--) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; K key = (K)s.readObject();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; V value = (V)s.readObject();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // synch could be eliminated for performance&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reconstitutionPut(table, key, value);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; this.table = table;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; private void reconstitutionPut(Entry[] tab, K key, V value)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; throws StreamCorruptedException&nbsp;&nbsp;\n&nbsp; &nbsp; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (value == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new java.io.StreamCorruptedException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Makes sure the key is not already in the hashtable.&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // This should not happen in deserialized version.&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int hash = key.hashCode();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int index = (hash &amp; 0x7FFFFFFF) % tab.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new java.io.StreamCorruptedException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Creates the new entry.&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; e = tab[index];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; count++;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // Hashtable的Entry节点，它本质上是一个单向链表。&nbsp;&nbsp;\n&nbsp; &nbsp; // 也因此，我们才能推断出Hashtable是由拉链法实现的散列表&nbsp;&nbsp;\n&nbsp; &nbsp; private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 哈希值&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int hash;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; K key;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; V value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 指向的下一个Entry，即链表的下一个节点&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; next;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 构造函数&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.hash = hash;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.key = key;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.value = value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.next = next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; protected Object clone() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return new Entry&lt;K,V&gt;(hash, key, value,&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (next==null ? null : (Entry&lt;K,V&gt;) next.clone()));&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public K getKey() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return key;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public V getValue() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 设置value。若value是null，则抛出异常。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public V setValue(V value) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (value == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NullPointerException();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; V oldValue = this.value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.value = value;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return oldValue;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 覆盖equals()方法，判断两个Entry是否相等。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若两个Entry的key和value都相等，则认为它们相等。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean equals(Object o) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(o instanceof Map.Entry))&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Map.Entry e = (Map.Entry)o;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(value==null ? e.getValue()==null : value.equals(e.getValue()));&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public int hashCode() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return hash ^ (value==null ? 0 : value.hashCode());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public String toString() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return key.toString()+\"=\"+value.toString();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; private static final int KEYS = 0;&nbsp;&nbsp;\n&nbsp; &nbsp; private static final int VALUES = 1;&nbsp;&nbsp;\n&nbsp; &nbsp; private static final int ENTRIES = 2;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。&nbsp;&nbsp;\n&nbsp; &nbsp; private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 指向Hashtable的table&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry[] table = Hashtable.this.table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Hashtable的总的大小&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int index = table.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; entry = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; lastReturned = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int type;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // iterator为true，表示它是迭代器；否则，是枚举类。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; boolean iterator;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; protected int expectedModCount = modCount;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Enumerator(int type, boolean iterator) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.type = type;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.iterator = iterator;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean hasMoreElements() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; e = entry;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int i = index;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry[] t = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Use locals for faster loop iteration */&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (e == null &amp;&amp; i &gt; 0) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e = t[--i];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry = e;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = i;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return e != null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 获取下一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式”&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 然后，依次向后遍历单向链表Entry。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public T nextElement() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; et = entry;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int i = index;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry[] t = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Use locals for faster loop iteration */&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (et == null &amp;&amp; i &gt; 0) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; et = t[--i];&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry = et;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = i;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (et != null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry&lt;K,V&gt; e = lastReturned = entry;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry = e.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e);&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NoSuchElementException(\"Hashtable Enumerator\");&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 迭代器Iterator的判断是否存在下一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 实际上，它是调用的hasMoreElements()&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean hasNext() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return hasMoreElements();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 迭代器获取下一个元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 实际上，它是调用的nextElement()&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public T next() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (modCount != expectedModCount)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ConcurrentModificationException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nextElement();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 迭代器的remove()接口。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 首先，它在table数组中找出要删除元素所在的Entry，&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 然后，删除单向链表Entry中的元素。&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public void remove() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!iterator)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new UnsupportedOperationException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (lastReturned == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalStateException(\"Hashtable Enumerator\");&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (modCount != expectedModCount)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ConcurrentModificationException();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; synchronized(Hashtable.this) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Entry[] tab = Hashtable.this.table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int index = (lastReturned.hash &amp; 0x7FFFFFFF) % tab.length;&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;prev = e, e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e == lastReturned) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expectedModCount++;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (prev == null)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab[index] = e.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev.next = e.next;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count--;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastReturned = null;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ConcurrentModificationException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp;\n&nbsp; &nbsp; private static Enumeration emptyEnumerator = new EmptyEnumerator();&nbsp;&nbsp;\n&nbsp; &nbsp; private static Iterator emptyIterator = new EmptyIterator();&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 空枚举类&nbsp;&nbsp;\n&nbsp; &nbsp; // 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。&nbsp;&nbsp;\n&nbsp; &nbsp; private static class EmptyEnumerator implements Enumeration&lt;Object&gt; {&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; EmptyEnumerator() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 空枚举类的hasMoreElements() 始终返回false&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean hasMoreElements() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 空枚举类的nextElement() 抛出异常&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public Object nextElement() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NoSuchElementException(\"Hashtable Enumerator\");&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 空迭代器&nbsp;&nbsp;\n&nbsp; &nbsp; // 当Hashtable的实际大小为0；此时，又要通过迭代器遍历Hashtable时，返回的是“空迭代器”的对象。&nbsp;&nbsp;\n&nbsp; &nbsp; private static class EmptyIterator implements Iterator&lt;Object&gt; {&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; EmptyIterator() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean hasNext() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public Object next() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NoSuchElementException(\"Hashtable Iterator\");&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; public void remove() {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalStateException(\"Hashtable Iterator\");&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n}&nbsp;<br></code></pre><h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b><br></b></span></h1><h1><span style=\"font-size: 18px; color: rgb(227, 55, 55);\"><b>三、几点总结</b></span></h1><p style=\"text-align: justify;\">&nbsp; &nbsp; 针对Hashtable，我们同样给出几点比较重要的总结，但要结合与HashMap的比较来总结。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; 1、二者的存储结构和解决冲突的方法都是相同的。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; 2、HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。</p><p style=\"text-align: justify;\"><span style=\"color: rgb(54, 46, 43);\">&nbsp; &nbsp; 3、</span><span style=\"color: rgb(255, 0, 0);\">Hashtable中key和value都不允许为null，而HashMap中key和value都允许为null（key只能有一个为null，而value则可以有多个为null）。但是如果在Hashtable中有类似put(null,null)的操作，编译同样可以通过，因为key和value都是Object类型，但运行时会抛出NullPointerException异常，这是JDK的规范规定的。</span><span style=\"color: rgb(54, 46, 43);\">我们来看下ContainsKey方法和ContainsValue的源码：</span></p><pre><code>&nbsp; &nbsp;// 判断Hashtable是否包含“值(value)”&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized boolean contains(Object value) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; //注意，Hashtable中的value不能是null，&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 若是null的话，抛出异常!&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; if (value == null) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NullPointerException();&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 从后向前遍历table数组中的元素(Entry)&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry tab[] = table;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i = tab.length ; i-- &gt; 0 ;) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = tab[i] ; e != null ; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.value.equals(value)) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; public boolean containsValue(Object value) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return contains(value);&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp;\n&nbsp; &nbsp; // 判断Hashtable是否包含key&nbsp;&nbsp;\n&nbsp; &nbsp; public synchronized boolean containsKey(Object key) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; Entry tab[] = table;&nbsp;&nbsp;\n	//计算hash值，直接用key的hashCode代替\n&nbsp; &nbsp; &nbsp; &nbsp; int hash = key.hashCode();&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 计算在数组中的索引值&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; int index = (hash &amp; 0x7FFFFFFF) % tab.length;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; return false;&nbsp;&nbsp;\n&nbsp; &nbsp; }&nbsp;&nbsp;<br></code></pre><p><span style=\"color: rgb(255, 0, 0);\">很明显，如果value为null，会直接抛出</span><span style=\"color: rgb(255, 0, 0);\">NullPointerException异常，但源码中并没有对key是否为null判断，有点小不解！不过NullPointerException</span><span style=\"color: rgb(255, 0, 0);\">属于</span><span style=\"color: rgb(255, 0, 0);\">RuntimeException异常，是可以由JVM自动抛出的，也许对key的值在JVM中有所限制吧</span><span style=\"color: rgb(54, 46, 43);\">。<br></span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(54, 46, 43);\">&nbsp; &nbsp; 4、Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。</span><br><span style=\"color: rgb(255, 0, 0);\">&nbsp; &nbsp; 5、Hashtable计算hash值，直接用key的hashCode()，而HashMap重新计算了key的hash值，Hashtable在求hash值对应的位置索引时，用取模运算，而HashMap在求位置索引时，则用与运算，且这里一般先用hash&amp;0x7FFFFFFF后，再对length取模，&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，只有符号外改变，而后面的位都不变。</span></p><p><span style=\"font-size: 14px;\"><span style=\"color: rgb(255, 0, 0);\"><br></span></span><br></p><p>原文地址：<a href=\"https://blog.csdn.net/ns_code/article/details/36191279\" target=\"_blank\">https://blog.csdn.net/ns_code/article/details/36191279</a></p>', '2018-06-20 10:39:51', '/articles/10017', '0', '0', 'publish', '一、Hashtable简介    Has', 'Java,HashTable,源码', '【Java集合源码剖析】Hashtable源码剖析', '2018-12-10 13:15:20', '16', '0', '10006', '1');
INSERT INTO `article` VALUES ('10018', '0', '1', '<p style=\"margin-left: auto;\">本文以Java TreeMap为例，从源代码层面，结合详细的图解，剥茧抽丝地讲解红黑树（Red-Black tree）的插入，删除以及由此产生的调整过程。</p><h1><b style=\"color: rgb(227, 55, 55);\">一、总体介绍</b></h1><p style=\"margin-left: auto;\">Java&nbsp;TreeMap实现了SortedMap接口，也就是说会按照<code>key</code>的大小顺序对Map中的元素进行排序，<code>key</code>大小的评判可以通过其本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator）。</p><p style=\"margin-left: auto;\"><strong>TreeMap底层通过红黑树（Red-Black tree）实现</strong>，也就意味着<code>containsKey()</code>,&nbsp;<code>get()</code>,&nbsp;<code>put()</code>,&nbsp;<code>remove()</code>都有着<code>log(n)</code>的时间复杂度。其具体算法实现参照了《算法导论》。</p><p style=\"margin-left: auto;\"><img alt=\"939998-20160517211933779-124491145.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/20/saysky/1529464851767\" width=\"800\" height=\"660\"><br></p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\">出于性能原因，TreeMap是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将TreeMap包装成（wrapped）同步的：</p><p style=\"margin-left: auto;\"><code>SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></p><p style=\"margin-left: auto;\"><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一陪</strong>。具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。</li><li>对于每个节点，从该点至<code>null</code>（树尾端）的任何路径，都含有相同个数的黑色节点。</li></ol><p style=\"margin-left: auto;\">在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的条件。</p><h1><span style=\"color: rgb(227, 55, 55);\"><b>二、预备知识</b></span></h1><p style=\"margin-left: auto;\">前文说到当查找树的结构发生改变时，红黑树的条件可能被破坏，需要通过调整使得查找树重新满足红黑树的条件。调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：<strong>左旋（Rotate Left），右旋（RotateRight）</strong>。</p><h2><span style=\"color: rgb(227, 55, 55);\"><b>三、左旋</b></span></h2><p style=\"margin-left: auto;\">左旋的过程是将<code>x</code>的右子树绕<code>x</code>逆时针旋转，使得<code>x</code>的右子树成为<code>x</code>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p style=\"margin-left: auto;\"><img alt=\"22.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/20/saysky/1529464887512\" width=\"800\" height=\"1002\"><br></p><p><br></p><p>TreeMap<span style=\"color: rgb(75, 75, 75); font-size: 13px;\">中左旋代码如下：</span><br></p><pre><code class=\"lang-java\">/Rotate Left\nprivate void rotateLeft(Entry&lt;K,V&gt; p) {\n    if (p != null) {\n        Entry&lt;K,V&gt; r = p.right;\n        p.right = r.left;\n        if (r.left != null)\n            r.left.parent = p;\n        r.parent = p.parent;\n        if (p.parent == null)\n            root = r;\n        else if (p.parent.left == p)\n            p.parent.left = r;\n        else\n            p.parent.right = r;\n        r.left = p;\n        p.parent = r;\n    }\n}<br></code></pre><p><br></p><p><span style=\"font-size: 22px; color: rgb(227, 55, 55);\"><b>四、右旋</b></span><br></p><p style=\"margin-left: auto;\">右旋的过程是将<code>x</code>的左子树绕<code>x</code>顺时针旋转，使得<code>x</code>的左子树成为<code>x</code>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p style=\"margin-left: auto;\"><img alt=\"23.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/20/saysky/1529464938162\" width=\"800\" height=\"909\"><br></p><p><br></p><p><span style=\"font-size: medium;\">TreeMap<span style=\"color: rgb(75, 75, 75);\">中右旋代码如下：</span></span><br></p><pre><code class=\"lang-java\">//Rotate Right\nprivate void rotateRight(Entry&lt;K,V&gt; p) {\n    if (p != null) {\n        Entry&lt;K,V&gt; l = p.left;\n        p.left = l.right;\n        if (l.right != null) l.right.parent = p;\n        l.parent = p.parent;\n        if (p.parent == null)\n            root = l;\n        else if (p.parent.right == p)\n            p.parent.right = l;\n        else p.parent.left = l;\n        l.right = p;\n        p.parent = l;\n    }\n}<br></code></pre><p><br></p><p><br></p><h1><b style=\"color: rgb(227, 55, 55);\">五、方法剖析</b></h1><h2>get()</h2><p style=\"margin-left: auto;\"><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.value</code>。因此<code>getEntry()</code>是算法的核心。算法思想是根据<code>key</code>的自然顺序（或者比较器顺序）对二叉查找树进行查找，直到找到满足<code>k.compareTo(p.key) == 0</code>的<code>entry</code>。</p><p style=\"margin-left: auto;\"><img alt=\"24.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/20/saysky/1529465000184\" width=\"800\" height=\"648\"><br></p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\"><span style=\"color: rgb(75, 75, 75);\">具体代码如下：</span><br></p><pre><code class=\"lang-java\">/getEntry()方法\nfinal Entry&lt;K,V&gt; getEntry(Object key) {\n    ......\n    if (key == null)//不允许key值为null\n        throw new NullPointerException();\n    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序\n    Entry&lt;K,V&gt; p = root;\n    while (p != null) {\n        int cmp = k.compareTo(p.key);\n        if (cmp &lt; 0)//向左找\n            p = p.left;\n        else if (cmp &gt; 0)//向右找\n            p = p.right;\n        else\n            return p;\n    }\n    return null;\n}<br></code></pre><p><br></p><p><br></p><h2>put()</h2><p style=\"margin-left: auto;\"><code>put(K key, V value)</code>方法是将指定的<code>key</code>,&nbsp;<code>value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到则会在红黑树中插入新的<code>entry</code>，如果插入之后破坏了红黑树的约束，还需要进行调整（旋转，改变某些节点的颜色）。</p><pre><code class=\"lang-java\">public V put(K key, V value) {\n    ......\n    int cmp;\n    Entry&lt;K,V&gt; parent;\n    if (key == null)\n        throw new NullPointerException();\n    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序\n    do {\n        parent = t;\n        cmp = k.compareTo(t.key);\n        if (cmp &lt; 0) t = t.left;//向左找\n        else if (cmp &gt; 0) t = t.right;//向右找\n        else return t.setValue(value);\n    } while (t != null);\n    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);//创建并插入新的entry\n    if (cmp &lt; 0) parent.left = e;\n    else parent.right = e;\n    fixAfterInsertion(e);//调整\n    size++;\n    return null;\n}<br></code></pre><p><span style=\"font-size: medium;\"><span style=\"color: rgb(75, 75, 75);\">上述代码的插入部分并不难理解：首先在红黑树上找到合适的位置，然后创建新的</span><code>entry</code><span style=\"color: rgb(75, 75, 75);\">并插入（当然，新插入的节点一定是树的叶子）。难点是调整函数</span><code>fixAfterInsertion()</code><span style=\"color: rgb(75, 75, 75);\">，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。</span></span><br></p><p><img alt=\"25.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/20/saysky/1529465098046\" width=\"800\" height=\"1856\"><br></p><p><span style=\"font-size: medium;\"><span style=\"color: rgb(75, 75, 75);\">调整函数</span><code>fixAfterInsertion()</code><span style=\"color: rgb(75, 75, 75);\">的具体代码如下，其中用到了上文中提到的</span><code>rotateLeft()</code><span style=\"color: rgb(75, 75, 75);\">和</span><code>rotateRight()</code><span style=\"color: rgb(75, 75, 75);\">函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。</span></span><br></p><pre><code class=\"lang-java\">//红黑树调整函数fixAfterInsertion()\nprivate void fixAfterInsertion(Entry&lt;K,V&gt; x) {\n    x.color = RED;\n    while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) {\n        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));\n            if (colorOf(y) == RED) {//如果y为null，则视为BLACK\n                setColor(parentOf(x), BLACK);              // 情况1\n                setColor(y, BLACK);                        // 情况1\n                setColor(parentOf(parentOf(x)), RED);      // 情况1\n                x = parentOf(parentOf(x));                 // 情况1\n            } else {\n                if (x == rightOf(parentOf(x))) {\n                    x = parentOf(x);                       // 情况2\n                    rotateLeft(x);                         // 情况2\n                }\n                setColor(parentOf(x), BLACK);              // 情况3\n                setColor(parentOf(parentOf(x)), RED);      // 情况3\n                rotateRight(parentOf(parentOf(x)));        // 情况3\n            }\n        } else {\n            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));\n            if (colorOf(y) == RED) {\n                setColor(parentOf(x), BLACK);              // 情况4\n                setColor(y, BLACK);                        // 情况4\n                setColor(parentOf(parentOf(x)), RED);      // 情况4\n                x = parentOf(parentOf(x));                 // 情况4\n            } else {\n                if (x == leftOf(parentOf(x))) {\n                    x = parentOf(x);                       // 情况5\n                    rotateRight(x);                        // 情况5\n                }\n                setColor(parentOf(x), BLACK);              // 情况6\n                setColor(parentOf(parentOf(x)), RED);      // 情况6\n                rotateLeft(parentOf(parentOf(x)));         // 情况6\n            }\n        }\n    }\n    root.color = BLACK;\n}<br></code></pre><h2>remove()</h2><p style=\"margin-left: auto;\"><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法首先通过上文中提到的<code>getEntry(Object key)</code>方法找到<code>key</code>值对应的<code>entry</code>，然后调用<code>deleteEntry(Entry&lt;K,V&gt; entry)</code>删除对应的<code>entry</code>。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束，因此有可能要进行调整。</p><p style=\"margin-left: auto;\"><strong>有关<code>remove()</code>的具体讲解将放到<a href=\"http://www.cnblogs.com/CarpenterLee/p/5525688.html\" target=\"_blank\">下一篇博文</a>当中，敬请期待！</strong></p><p><br></p><p>原文地址：<a href=\"http://www.cnblogs.com/CarpenterLee/p/5503882.html\" target=\"_blank\">http://www.cnblogs.com/CarpenterLee/p/5503882.html</a></p>', '2018-06-20 11:35:38', '/articles/10018', '0', '0', 'publish', '本文以Java TreeMap为例，从源代码层面，结合详细的图解，剥茧抽丝地讲解红黑树（Red-Black tree）的插入，删除以及由此产生的调整过程。<b style=\"color: rgb(227, 55, 55);\"', '数据结构,红黑树', '史上最清晰的红黑树讲解', '2018-10-16 14:28:19', '27', '0', '10007', '1'), ('10019', '0', '0', '<p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">&nbsp;Java中实现多线程有两种方法：继承Thread类、实现Runnable接口，在程序开发中只要是多线程，肯定永远以实现Runnable接口为主，因为实现Runnable接口相比继承Thread类有如下优势：</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">&nbsp; &nbsp; 1、可以避免由于Java的单继承特性而带来的局限；</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">&nbsp; &nbsp; 2、增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">&nbsp; &nbsp; 3、适合多个相同程序代码的线程区处理同一资源的情况。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\"><br></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">&nbsp; &nbsp; 下面以典型的买票程序（基本都是以这个为例子）为例，来说明二者的区别。</span></p><p style=\"text-align: justify;\"><b style=\"color: rgb(0, 0, 0);\"><span style=\"color: rgb(227, 55, 55);\"><br></span></b></p><p style=\"text-align: justify;\"><b style=\"color: rgb(0, 0, 0);\"><span style=\"color: rgb(227, 55, 55); font-size: 1.25em;\">一、继承 Thread</span></b><br></p><pre><code class=\"lang-java\">package <span style=\"font-style: italic;\">com.liuyanzhao.multi_thread</span>;<br><br>/**<br> * 三个线程各自每人卖5张票，不存在资源共享<br> * @author 言曌<br> * @date 2018/6/21 下午3:41<br> */<br>class <span style=\"font-style: italic;\">MyThread </span>extends <span style=\"font-style: italic;\">Thread </span>{<br><br>    private int ticket = 5;<br><br>    public MyThread(<span style=\"font-style: italic;\">String name</span>) {<br>        super();<br>        this.setName(<span style=\"font-style: italic;\">name</span>);<br>    }<br><br>    @Override<br>    public void run() {<br>        for (int i = 0; i &lt; 10; i++) {<br>            if (ticket &gt; 0) {<br>                <span style=\"font-style: italic;\">System</span>.<span style=\"font-weight: bold; font-style: italic;\">out</span>.println(<span style=\"font-style: italic;\">Thread</span>.currentThread().getName() + \"--\" + ticket--);<br>            }<br>        }<br>    }<br>}<br><br>public class <span style=\"font-style: italic;\">ThreadDemo </span>{<br><br>    public static void main(<span style=\"font-style: italic;\">String args</span>[]) {<br>        <span style=\"font-style: italic;\">MyThread </span>thread = new MyThread(\"甲\");<br>        <span style=\"font-style: italic;\">MyThread </span>thread2 = new MyThread(\"乙\");<br>        <span style=\"font-style: italic;\">MyThread </span>thread3 = new MyThread(\"丙\");<br>        thread.start();<br>        thread2.start();<br>        thread3.start();<br>    }<br><span style=\"color:#f9faf4;\">}<br></span></code></pre><p>运行结果</p><p><img alt=\"WX20180621-155756@2x.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/21/saysky/1529567909697\" width=\"500\" height=\"321\"><br></p><h2><b><span style=\"color: rgb(227, 55, 55);\"><br></span></b></h2><h2><b><span style=\"color: rgb(227, 55, 55);\"><br></span></b></h2><h2><b><span style=\"color: rgb(227, 55, 55);\">二、实现 Runnable</span></b><br></h2><pre><code class=\"lang-java\">package <span style=\"font-style: italic;\">com.liuyanzhao.multi_thread</span>;<br><br>/**<br> * 三个线程共享卖票，存在资源共享<br> * @author 言曌<br> * @date 2018/6/21 下午3:41<br> */<br>class <span style=\"font-style: italic;\">MyThread2 </span>implements <span style=\"font-style: italic;\">Runnable </span>{<br><br>    private int ticket = 5;<br><br>    @Override<br>    public void run() {<br>        for (int i = 0; i &lt; 10; i++) {<br>            if (ticket &gt; 0) {<br>                <span style=\"font-style: italic;\">System</span>.<span style=\"font-weight: bold; font-style: italic;\">out</span>.println(<span style=\"font-style: italic;\">Thread</span>.currentThread().getName() + \"--\" + ticket--);<br>            }<br>        }<br>    }<br>}<br><br>public class <span style=\"font-style: italic;\">ThreadDemo2 </span>{<br><br>    public static void main(<span style=\"font-style: italic;\">String args</span>[]) {<br>        <span style=\"font-style: italic;\">MyThread2 </span>myThread = new MyThread2();<br>        <span style=\"font-style: italic;\">Thread </span>thread = <span style=\"background-color: rgb(82, 80, 58);\">new </span><span style=\"background-color:#52503a;\">Thread</span><span style=\"background-color: rgb(82, 80, 58);\">(</span><span style=\"background-color:#52503a;\">myThread</span><span style=\"background-color: rgb(82, 80, 58);\">,</span><span style=\"background-color: rgb(82, 80, 58);\">\"甲\"</span><span style=\"background-color: rgb(82, 80, 58);\">)</span>;<br>        <span style=\"font-style: italic;\">Thread </span>thread2 = <span style=\"background-color: rgb(82, 80, 58);\">new </span><span style=\"background-color:#52503a;\">Thread</span><span style=\"background-color: rgb(82, 80, 58);\">(</span><span style=\"background-color:#52503a;\">myThread</span><span style=\"background-color: rgb(82, 80, 58);\">,</span><span style=\"background-color: rgb(82, 80, 58);\">\"乙\"</span><span style=\"background-color: rgb(82, 80, 58);\">)</span>;<br>        <span style=\"font-style: italic;\">Thread </span>thread3 = <span style=\"background-color: rgb(82, 80, 58);\">new </span><span style=\"background-color:#52503a;\">Thread</span><span style=\"background-color: rgb(82, 80, 58);\">(</span><span style=\"background-color:#52503a;\">myThread</span><span style=\"background-color: rgb(82, 80, 58);\">,</span><span style=\"background-color: rgb(82, 80, 58);\">\"丙\"</span><span style=\"background-color: rgb(82, 80, 58);\">)</span>;<br>        thread.start();<br>        thread2.start();<br>        thread3.start();<br>    }<br>}<br></code></pre><p><img alt=\"WX20180621-155908@2x.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/21/saysky/1529567981766\" width=\"500\" height=\"113.36515513126491\"><br></p><p><br></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">&nbsp;&nbsp;<span style=\"color: rgb(255, 0, 0);\">针对以上代码补充三点：</span></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px; color: rgb(255, 0, 0);\">&nbsp; &nbsp; 1、在第二种方法（Runnable）中，ticket输出的顺序并不是54321，这是因为线程执行的时机难以预测，ticket--并不是原子操作。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px; color: rgb(255, 0, 0);\">&nbsp; &nbsp; 2、在第一种方法中，我们new了3个Thread对象，即三个线程分别执行三个对象中的代码，因此便是三个线程去独立地完成卖票的任务；而在第二种方法中，我们同样也new了3个Thread对象，但只有一个Runnable对象，3个Thread对象共享这个Runnable对象中的代码，因此，便会出现3个线程共同完成卖票任务的结果。如果我们new出3个Runnable对象，作为参数分别传入3个Thread对象中，那么3个线程便会独立执行各自Runnable对象中的代码，即3个线程各自卖5张票。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px; color: rgb(255, 0, 0);\">&nbsp; &nbsp; 3、在第二种方法中，由于3个Thread对象共同执行一个Runnable对象中的代码，因此可能会造成线程的不安全，比如可能ticket会输出-1（如果我们System.out....语句前加上线程休眠操作，该情况将很有可能出现），这种情况的出现是由于，一个线程在判断ticket为1&gt;0后，还没有来得及减1，另一个线程已经将ticket减1，变为了0，那么接下来之前的线程再将ticket减1，便得到了-1。这就需要加入同步操作（即互斥锁），确保同一时刻只有一个线程在执行每次for循环中的操作。而在第一种方法中，并不需要加入同步操作，因为每个线程执行自己Thread对象中的代码，不存在多个线程共同执行同一个方法的情况。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px; color: rgb(255, 0, 0);\"><br></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">原文地址：<a href=\"https://blog.csdn.net/ns_code/article/details/17161237\" target=\"_blank\">https://blog.csdn.net/ns_code/article/details/17161237</a></span></p>', '2018-06-21 16:01:45', '/articles/10019', '0', '0', 'publish', ' Java中实现多线程有两种方法：继承Thread类、实现Runnable接口，在程序开发中只要是多线程，肯定永远以实现Runnable接口为主，因为实现Runna', 'Java,多线程', '实现多线程的两种方法', '2018-07-05 08:57:44', '6', '0', '10008', '1'), ('10020', '0', '0', '<p style=\"text-align: justify;\">锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段，这里并不打算深入到每个锁的实现和转换过程更多地是阐述Java虚拟机所提供的每个锁的核心优化思想，毕竟涉及到具体过程比较繁琐，如需了解详细过程可以查阅《深入理解Java虚拟机原理》。</p><h3><font color=\"#BE1921\">偏向锁</font></h3><p style=\"text-align: justify;\">偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，<span style=\"color: rgb(65, 140, 175);\"><b>在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。</b></span>所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。</p><h3><font color=\"#BE1921\">轻量级锁</font></h3><p style=\"text-align: justify;\">倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p><h3><font color=\"#BE1921\">自旋锁</font></h3><p style=\"text-align: justify;\">轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p><h3><font color=\"#BE1921\">锁消除</font></h3><p style=\"text-align: justify;\">消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</p><pre><code class=\"lang-java\">public class StringBufferRemoveSync {\n\n    public void add(String str1, String str2) {\n        //StringBuffer是线程安全,由于sb只会在append方法中使用,不可能被其他线程引用\n        //因此sb属于不可能共享的资源,JVM会自动消除内部的锁\n        StringBuffer sb = new StringBuffer();\n        sb.append(str1).append(str2);\n    }\n\n    public static void main(String[] args) {\n        StringBufferRemoveSync rmsync = new StringBufferRemoveSync();\n        for (int i = 0; i &lt; 10000000; i++) {\n            rmsync.add(\"abc\", \"123\");\n        }\n    }\n\n}<br></code></pre>', '2018-06-21 16:52:51', '/articles/10020', '0', '0', 'publish', '锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍', 'Java,多线程,synchronized', 'Java虚拟机对synchronized的优化', '2018-07-04 14:05:00', '9', '0', '10008', '1'), ('10021', '0', '0', '<p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">&nbsp; &nbsp;如果线程调用了对象的wait（）方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">&nbsp; &nbsp;当有线程调用了对象的notifyAll（）方法（唤醒所有wait线程）或notify（）方法（只随机唤醒一个wait线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">&nbsp; &nbsp;优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait（）方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(0, 0, 153);\"><span style=\"font-size: 18px;\"><br></span></span></p><p><br></p><p>下面这个例子，创建了两个消费者和两个生产者，模拟生产一个消费一个</p><p>代码如下</p><pre><code class=\"lang-java\">package com.liuyanzhao.multi_thread;\n\n/**\n&nbsp;* 注意\n&nbsp;* 1、判断仓库有否有货是否，必须用while，而不能用if，\n&nbsp;* 作用是让线程醒过来的时候，还要判断是否为空，\n&nbsp;* 如果用if的话，就不会判断，直接往下走，\n&nbsp;* 会导致连续生产或者消费。\n&nbsp;* 2、超过两个线程的时候，用notifyAll唤醒，不要用notify\n&nbsp;*\n&nbsp;* @author 言曌\n&nbsp;* @date 2018/6/21 下午5:13\n&nbsp;*/\n\nclass Resource {\n&nbsp; &nbsp; private boolean isEmpty = true;\n&nbsp; &nbsp; private int count = 0;\n\n&nbsp; &nbsp; public synchronized void put() { //生产\n&nbsp; &nbsp; &nbsp; &nbsp; //如果不是空，就wait()\n&nbsp; &nbsp; &nbsp; &nbsp; while (!isEmpty) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait();//放弃锁，在这里等，本线程暂停\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (InterruptedException e) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.printStackTrace();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; count++;\n&nbsp; &nbsp; &nbsp; &nbsp; //否则，执行下面代码\n&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(Thread.currentThread().getName() + \" 生产1个，剩余\" + count + \"个\");\n&nbsp; &nbsp; &nbsp; &nbsp; isEmpty = false;\n&nbsp; &nbsp; &nbsp; &nbsp; this.notifyAll();//释放锁，所有wait中的线程重新唤醒，开始抢cpu执行权\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; public synchronized void get() { //消费\n&nbsp; &nbsp; &nbsp; &nbsp; //如果是空的，就wait()\n&nbsp; &nbsp; &nbsp; &nbsp; while (isEmpty) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait();//放弃锁，在这里等，本线程暂停\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (InterruptedException e) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.printStackTrace();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; count--;\n&nbsp; &nbsp; &nbsp; &nbsp; //否则，执行下面代码\n&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(Thread.currentThread().getName() + \" 消费1个，剩余\" + count + \"个\");\n&nbsp; &nbsp; &nbsp; &nbsp; isEmpty = true;\n&nbsp; &nbsp; &nbsp; &nbsp; this.notifyAll();//释放锁，所有wait中的线程重新唤醒，开始抢cpu执行权\n&nbsp; &nbsp; }\n}\n\nclass Producer implements Runnable {\n&nbsp; &nbsp; private Resource res;\n\n&nbsp; &nbsp; public Producer(Resource res) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.res = res;\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public void run() {\n&nbsp; &nbsp; &nbsp; &nbsp; while (true) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res.put();\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\nclass Consumer implements Runnable {\n&nbsp; &nbsp; private Resource res;\n\n&nbsp; &nbsp; public Consumer(Resource res) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.res = res;\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public void run() {\n&nbsp; &nbsp; &nbsp; &nbsp; while (true) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res.get();\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\npublic class ProducerConsumerDemo {\n&nbsp; &nbsp; public static void main(String[] args) {\n&nbsp; &nbsp; &nbsp; &nbsp; Resource r = new Resource();\n&nbsp; &nbsp; &nbsp; &nbsp; Producer producer = new Producer(r);\n&nbsp; &nbsp; &nbsp; &nbsp; Consumer consumer = new Consumer(r);\n&nbsp; &nbsp; &nbsp; &nbsp; Thread t1 = new Thread(producer, \"甲工人\");\n&nbsp; &nbsp; &nbsp; &nbsp; Thread t2 = new Thread(producer, \"乙工人\");\n&nbsp; &nbsp; &nbsp; &nbsp; Thread t3 = new Thread(consumer, \"A用户\");\n&nbsp; &nbsp; &nbsp; &nbsp; Thread t4 = new Thread(consumer, \"B用户\");\n&nbsp; &nbsp; &nbsp; &nbsp; t1.start();\n&nbsp; &nbsp; &nbsp; &nbsp; t2.start();\n&nbsp; &nbsp; &nbsp; &nbsp; t3.start();\n&nbsp; &nbsp; &nbsp; &nbsp; t4.start();\n&nbsp; &nbsp; }\n}<br></code></pre><p>某次运行结果如下<br></p><p><img alt=\"WX20180621-173314@2x.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/21/saysky/1529573838807\" width=\"300\" height=\"371.4765100671141\"><br></p>', '2018-06-21 17:38:32', '/articles/10021', '0', '0', 'publish', '   如果线程调用了对象的wait（）方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。<p style=', 'Java,多线程,wait,notify', 'wait()和notify实现生产者和消费者模式(生产一个消费一个)', '2019-04-16 10:51:07', '3', '0', '10008', '1'), ('10022', '0', '0', '<p>关键字 synchronized 与 wait() 和 notify() / notifyAll() 方法相结合可以实现等待/通知模式，类 ReentrantLock 也可以实现同样的功能，但需要借助于 Condition 对象。</p><pre><code>package com.liuyanzhao.multi_thread.lock;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n&nbsp;* Lock 和 Condition 实现消费者和生产者模式\n&nbsp;* @author 言曌\n&nbsp;* @date 2018/6/21 下午5:13\n&nbsp;*/\n\nclass Resource {\n\n&nbsp; &nbsp; private ReentrantLock lock = new ReentrantLock();\n&nbsp; &nbsp; private Condition condition = lock.newCondition();\n&nbsp; &nbsp; private boolean isEmpty = true;\n&nbsp; &nbsp; private int count = 0;\n\n&nbsp; &nbsp; //生产\n&nbsp; &nbsp; public void put() {&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock.lock();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (!isEmpty) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; condition.await();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count++;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(Thread.currentThread().getName() + \" 生产1个，剩余\" + count + \"个\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isEmpty = false;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; condition.signal();//释放锁\n&nbsp; &nbsp; &nbsp; &nbsp; } catch (InterruptedException e) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.printStackTrace();\n&nbsp; &nbsp; &nbsp; &nbsp; } finally {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock.unlock();\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; //消费\n&nbsp; &nbsp; public void get() {&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock.lock();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (isEmpty) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; condition.await();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count--;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(Thread.currentThread().getName() + \" 消费1个，剩余\" + count + \"个\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isEmpty = true;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; condition.signal();\n&nbsp; &nbsp; &nbsp; &nbsp; } catch (InterruptedException e) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.printStackTrace();\n&nbsp; &nbsp; &nbsp; &nbsp; } finally {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock.unlock();\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\nclass Producer implements Runnable {\n&nbsp; &nbsp; private Resource res;\n\n&nbsp; &nbsp; public Producer(Resource res) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.res = res;\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public void run() {\n&nbsp; &nbsp; &nbsp; &nbsp; while (true) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res.put();\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\nclass Consumer implements Runnable {\n&nbsp; &nbsp; private Resource res;\n\n&nbsp; &nbsp; public Consumer(Resource res) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.res = res;\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public void run() {\n&nbsp; &nbsp; &nbsp; &nbsp; while (true) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res.get();\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\npublic class ProducerConsumerDemo {\n&nbsp; &nbsp; public static void main(String[] args) {\n&nbsp; &nbsp; &nbsp; &nbsp; Resource r = new Resource();\n&nbsp; &nbsp; &nbsp; &nbsp; Producer producer = new Producer(r);\n&nbsp; &nbsp; &nbsp; &nbsp; Consumer consumer = new Consumer(r);\n&nbsp; &nbsp; &nbsp; &nbsp; Thread t1 = new Thread(producer, \"甲工人\");\n&nbsp; &nbsp; &nbsp; &nbsp; Thread t2 = new Thread(producer, \"乙工人\");\n&nbsp; &nbsp; &nbsp; &nbsp; Thread t3 = new Thread(consumer, \"A用户\");\n&nbsp; &nbsp; &nbsp; &nbsp; Thread t4 = new Thread(consumer, \"B用户\");\n&nbsp; &nbsp; &nbsp; &nbsp; t1.start();\n&nbsp; &nbsp; &nbsp; &nbsp; t2.start();\n&nbsp; &nbsp; &nbsp; &nbsp; t3.start();\n&nbsp; &nbsp; &nbsp; &nbsp; t4.start();\n&nbsp; &nbsp; }\n}<br></code></pre><p><br></p><p><br></p><p>其他文章：<span style=\"font-size: 16px;\">&nbsp;</span><a href=\"http://codergroup.cn/articles/10021\" target=\"_blank\">wait()和notify实现生产者和消费者模式(生产一个消费一个)</a></p>', '2018-06-21 18:39:46', '/articles/10022', '0', '0', 'publish', '关键字 synchronized 与 wait() 和 notify() / notifyAll() 方法相结合可以实现等待/通知模式，类 ReentrantLock 也可以实现同样的功能，但需要借助于 Condition 对象。package com.liuya', 'Java,Lock,Condition,多线程', '使用 Lock 和 Condition 实现生产者和消费者模式(生产一个消费一个)', '2018-11-11 15:08:53', '6', '0', '10008', '1'), ('10023', '0', '0', '<p style=\"margin-left: auto;\">&nbsp; &nbsp; &nbsp; 在《Unix网络编程》一书中提到了五种IO模型，分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。</p><p style=\"margin-left: auto;\">&nbsp; &nbsp; &nbsp; 下面就分别来介绍一下这5种IO模型的异同。</p><h2><b>1.阻塞IO模型</b></h2><p style=\"margin-left: auto;\">　　最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。</p><p style=\"margin-left: auto;\">　　当用户线程发出IO请求之后，内核会去查看数据是否就绪，<span style=\"color: rgb(227, 55, 55);\">如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态</span>，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</p><p style=\"margin-left: auto;\">　　典型的阻塞IO模型的例子为：</p><pre><code class=\"lang-java\">data = socket.read();<br></code></pre><p><br></p><h2><b>2.非阻塞IO模型</b></h2><p style=\"margin-left: auto;\">　　当用户线程发起一个read操作后，<span style=\"color: rgb(227, 55, 55);\">并不需要等待，而是马上就得到了一个结果</span>。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p><p style=\"margin-left: auto;\">　　所以事实上，在非阻塞IO模型中，<span style=\"color: rgb(227, 55, 55);\">用户线程需要不断地询问内核数据是否就绪</span>，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</p><p style=\"margin-left: auto;\">　　典型的非阻塞IO模型一般如下：</p><pre><code class=\"lang-java\">while(true){\n&nbsp;&nbsp;&nbsp;&nbsp;data = socket.read();\n&nbsp;&nbsp;&nbsp;&nbsp;if(data!= error){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//处理数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p>但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。<br></p><h2><b><br></b></h2><h2><b>3.多路复用IO模型</b></h2><p><b style=\"color: rgb(227, 55, 55);\">　　多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。</b></p><p style=\"margin-left: auto;\">　　在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p><p style=\"margin-left: auto;\">　　在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。</p><p style=\"margin-left: auto;\">　　也许有朋友会说，我可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。</p><p style=\"margin-left: auto;\">　　而多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。</p><p style=\"margin-left: auto;\">　　另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在<span style=\"color: rgb(227, 55, 55);\">多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多</span>。</p><p style=\"margin-left: auto;\">　　不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p><p style=\"margin-left: auto;\"><br></p><h2><b>4.信号驱动IO模型</b></h2><p style=\"margin-left: auto;\">　　在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p><p style=\"margin-left: auto;\"><br></p><h2><b>5.异步IO模型</b></h2><p style=\"margin-left: auto;\">　　异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。</p><p style=\"margin-left: auto;\">　　也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。</p><p style=\"margin-left: auto;\">　　注意，异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。</p><p style=\"margin-left: auto;\">　</p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\"><span style=\"color: rgb(65, 140, 175);\"><b>　&nbsp; &nbsp; 前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。</b></span></p><p style=\"margin-left: auto;\"><b style=\"\"><br></b></p><p style=\"margin-left: auto;\">原文地址：<a href=\"https://www.cnblogs.com/dolphin0520/p/3916526.html\" target=\"_blank\" style=\"\">https://www.cnblogs.com/dolphin0520/p/3916526.html</a></p>', '2018-06-21 21:00:16', '/articles/10023', '0', '0', 'publish', '      在《Unix网络编程》一书中提到了五种IO模型，分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。 ', 'Java,IO,IO模型', '五种IO模型', '2018-09-27 01:43:12', '9', '0', '10006', '1'), ('10024', '0', '0', '<p style=\"margin-left: auto;\"><br>　　想必很多朋友对ThreadLocal并不陌生，今天我们就来一起探讨下ThreadLocal的使用方法和实现原理。首先，本文先谈一下对ThreadLocal的理解，然后根据ThreadLocal类的源码分析了其实现原理和使用需要注意的地方，最后给出了两个应用场景。</p><p style=\"margin-left: auto;\">　　以下是本文目录大纲：</p><p style=\"margin-left: auto;\">　　一.对ThreadLocal的理解</p><p style=\"margin-left: auto;\">　　二.深入解析ThreadLocal类</p><p style=\"margin-left: auto;\">　　三.ThreadLocal的应用场景</p><p style=\"margin-left: auto;\">　　若有不正之处请多多谅解，并欢迎批评指正。</p><p style=\"margin-left: auto;\">　　请尊重作者劳动成果，转载请标明原文链接：</p><p style=\"margin-left: auto;\">&nbsp;　　<a href=\"http://www.cnblogs.com/dolphin0520/p/3920407.html\" target=\"_blank\">http://www.cnblogs.com/dolphin0520/p/3920407.html</a></p><p style=\"margin-left: auto;\"><br></p><h2><span style=\"color: rgb(227, 55, 55);\"><b>一、对ThreadLocal的理解</b></span></h2><p>&nbsp; &nbsp; &nbsp; &nbsp; ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。<br></p><p style=\"margin-left: auto;\">　　这句话从字面上看起来很容易理解，但是真正理解并不是那么容易。</p><p style=\"margin-left: auto;\">　　我们还是先来看一个例子：</p><pre><code class=\"lang-java\">class&nbsp;ConnectionManager {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;Connection connect =&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Connection openConnection() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(connect ==&nbsp;null){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connect = DriverManager.getConnection();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;connect;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;closeConnection() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(connect!=null)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connect.close();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p style=\"margin-left: auto;\">&nbsp; &nbsp; &nbsp; &nbsp; 假设有这样一个数据库链接管理类，这段代码在单线程中使用是没有任何问题的，但是如果在多线程中使用呢？很显然，在多线程中使用会存在线程安全问题：第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。</p><p style=\"margin-left: auto;\">　　所以出于线程安全的考虑，必须将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理。</p><p style=\"margin-left: auto;\">　　这样将会大大影响程序执行效率，因为一个线程在使用connect进行数据库操作的时候，其他线程只有等待。</p><p style=\"margin-left: auto;\">　　那么大家来仔细分析一下这个问题，这地方到底需不需要将connect变量进行共享？事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。</p><p style=\"margin-left: auto;\">　　到这里，可能会有朋友想到，既然不需要在线程之间共享这个变量，可以直接这样处理，在每个需要使用数据库连接的方法中具体使用时才创建数据库链接，然后在方法调用完毕再释放这个连接。比如下面这样：</p><pre><code class=\"lang-java\">class&nbsp;ConnectionManager {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;&nbsp;Connection connect =&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Connection openConnection() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(connect ==&nbsp;null){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connect = DriverManager.getConnection();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;connect;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;closeConnection() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(connect!=null)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connect.close();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n&nbsp;\n&nbsp;\nclass&nbsp;Dao{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;insert() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConnectionManager connectionManager =&nbsp;new&nbsp;ConnectionManager();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Connection connection = connectionManager.openConnection();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使用connection进行操作\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connectionManager.closeConnection();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p style=\"margin-left: auto;\">这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不尽严重影响程序执行效率，还可能导致服务器压力巨大。</p><p style=\"margin-left: auto;\">　　那么这种情况下使用ThreadLocal是再适合不过的了，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。</p><p style=\"margin-left: auto;\">　　但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</p><p style=\"margin-left: auto;\"><br></p><h2><b style=\"color: rgb(227, 55, 55);\">二、深入解析ThreadLocal类</b></h2><p style=\"margin-left: auto;\">在上面谈到了对ThreadLocal的一些理解，那我们下面来看一下具体ThreadLocal是如何实现的。</p><p style=\"margin-left: auto;\">先了解一下ThreadLocal类提供的几个方法：</p><pre><code class=\"lang-java\">public&nbsp;T get() { }\npublic&nbsp;void&nbsp;set(T value) { }\npublic&nbsp;void&nbsp;remove() { }\nprotected&nbsp;T initialValue() { }<br></code></pre><p style=\"margin-left: auto;\"><br>　　首先我们来看一下ThreadLocal类是如何为每个线程创建一个变量的副本的。</p><p style=\"margin-left: auto;\">　　先看下get方法的实现：</p><pre><code>/**<br> * Returns the value in the current thread\'s copy of this<br> * thread-local variable.  If the variable has no value for the<br> * current thread, it is first initialized to the value returned<br> * by an invocation of the {@link #initialValue} method.<br> *<br> * @return the current thread\'s value of this thread-local<br> */<br>public <span style=\"font-style: italic;\">T </span>get() {<br>    <span style=\"font-style: italic;\">Thread </span>t = <span style=\"font-style: italic;\">Thread</span>.currentThread();<br>    <span style=\"font-style: italic;\">ThreadLocalMap </span>map = getMap(t);<br>    if (map != null) {<br>        <span style=\"font-style: italic;\">ThreadLocalMap</span>.<span style=\"font-style: italic;\">Entry </span>e = map.getEntry(this);<br>        if (e != null) {<br>            @SuppressWarnings(\"unchecked\")<br>            <span style=\"font-style: italic;\">T </span>result = (<span style=\"font-style: italic;\">T</span>)e.value;<br>            return result;<br>        }<br>    }<br>    return setInitialValue();<br><span style=\"color:#f9faf4;\">}</span></code></pre><p style=\"margin-left: auto;\">第一句是取得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。然后接着下面获取到&lt;key,value&gt;键值对，<span style=\"color: rgb(255, 0, 0);\">注意这里获取键值对传进去的是&nbsp; this，而不是当前线程t。</span></p><p style=\"margin-left: auto;\">　　如果获取成功，则返回value值。</p><p style=\"margin-left: auto;\">　　如果map为空，则调用setInitialValue方法返回value。</p><p style=\"margin-left: auto;\">　　我们上面的每一句来仔细分析：</p><p style=\"margin-left: auto;\">　　首先看一下getMap方法中做了什么：</p><pre><code>/**<br> * Get the map associated with a ThreadLocal. Overridden in<br> * InheritableThreadLocal.<br> *<br> * @param  t the current thread<br> * @return the map<br> */<br><span style=\"font-style: italic;\">ThreadLocalMap </span>getMap(<span style=\"font-style: italic;\">Thread t</span>) {<br>    return <span style=\"font-style: italic;\">t</span>.threadLocals;<br><span style=\"color:#f9faf4;\">}</span></code></pre><p style=\"margin-left: auto;\">可能大家没有想到的是，在getMap中，是调用当期线程t，返回当前线程t中的一个成员变量threadLocals。</p><p style=\"margin-left: auto;\">　　那么我们继续取Thread类中取看一下成员变量threadLocals是什么：</p><pre><code><span style=\"font-style: italic;\">/* ThreadLocal values pertaining to this thread. This map is maintained<br></span><span style=\"font-style: italic;\"> * by the ThreadLocal class. */<br></span><span style=\"font-style: italic;\">ThreadLocal</span>.<span style=\"font-style: italic;\">ThreadLocalMap </span>threadLocals <span style=\"color:#f92672;\">= null;</span></code></pre><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类，我们继续取看ThreadLocalMap的实现：</span><br></p><pre><code class=\"lang-java\">static class ThreadLocalMap {\n\n&nbsp; &nbsp; /**\n&nbsp; &nbsp; &nbsp;* The entries in this hash map extend WeakReference, using\n&nbsp; &nbsp; &nbsp;* its main ref field as the key (which is always a\n&nbsp; &nbsp; &nbsp;* ThreadLocal object).&nbsp; Note that null keys (i.e. entry.get()\n&nbsp; &nbsp; &nbsp;* == null) mean that the key is no longer referenced, so the\n&nbsp; &nbsp; &nbsp;* entry can be expunged from table.&nbsp; Such entries are referred to\n&nbsp; &nbsp; &nbsp;* as \"stale entries\" in the code that follows.\n&nbsp; &nbsp; &nbsp;*/\n&nbsp; &nbsp; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; /** The value associated with this ThreadLocal. */\n&nbsp; &nbsp; &nbsp; &nbsp; Object value;\n\n&nbsp; &nbsp; &nbsp; &nbsp; Entry(ThreadLocal&lt;?&gt; k, Object v) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; super(k);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = v;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n    ......\n}<br></code></pre><p style=\"margin-left: auto;\">　　可以看到ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。</p><p style=\"margin-left: auto;\">　　然后再继续看setInitialValue方法的具体实现：</p><pre><code class=\"lang-java\">/**\n&nbsp; &nbsp; &nbsp;* Variant of set() to establish initialValue. Used instead\n&nbsp; &nbsp; &nbsp;* of set() in case user has overridden the set() method.\n&nbsp; &nbsp; &nbsp;*\n&nbsp; &nbsp; &nbsp;* @return the initial value\n&nbsp; &nbsp; &nbsp;*/\n&nbsp; &nbsp; private T setInitialValue() {\n&nbsp; &nbsp; &nbsp; &nbsp; T value = initialValue();\n&nbsp; &nbsp; &nbsp; &nbsp; Thread t = Thread.currentThread();\n&nbsp; &nbsp; &nbsp; &nbsp; ThreadLocalMap map = getMap(t);\n&nbsp; &nbsp; &nbsp; &nbsp; if (map != null)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map.set(this, value);\n&nbsp; &nbsp; &nbsp; &nbsp; else\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; createMap(t, value);\n&nbsp; &nbsp; &nbsp; &nbsp; return value;\n&nbsp; &nbsp; }<br></code></pre><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">很容易了解，就是如果map不为空，就设置键值对，为空，再创建Map，看一下createMap的实现：</span><br></p><pre><code class=\"lang-java\">&nbsp; &nbsp; /**\n&nbsp; &nbsp; &nbsp;* Create the map associated with a ThreadLocal. Overridden in\n&nbsp; &nbsp; &nbsp;* InheritableThreadLocal.\n&nbsp; &nbsp; &nbsp;*\n&nbsp; &nbsp; &nbsp;* @param t the current thread\n&nbsp; &nbsp; &nbsp;* @param firstValue value for the initial entry of the map\n&nbsp; &nbsp; &nbsp;*/\n&nbsp; &nbsp; void createMap(Thread t, T firstValue) {\n&nbsp; &nbsp; &nbsp; &nbsp; t.threadLocals = new ThreadLocalMap(this, firstValue);\n&nbsp; &nbsp; }<br></code></pre><p style=\"margin-left: auto;\">至此，可能大部分朋友已经明白了ThreadLocal是如何为每个线程创建变量的副本的：</p><p style=\"margin-left: auto;\">　　首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。</p><p style=\"margin-left: auto;\">　　初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。</p><p style=\"margin-left: auto;\">　　然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p><p style=\"margin-left: auto;\">　　下面通过一个例子来证明通过ThreadLocal能达到在每个线程中创建变量副本的效果：</p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Test {\n&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal&lt;Long&gt; longLocal =&nbsp;new&nbsp;ThreadLocal&lt;Long&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal&lt;String&gt; stringLocal =&nbsp;new&nbsp;ThreadLocal&lt;String&gt;();\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;set() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;longLocal.set(Thread.currentThread().getId());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringLocal.set(Thread.currentThread().getName());\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;long&nbsp;getLong() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;longLocal.get();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String getString() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;stringLocal.get();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args)&nbsp;throws&nbsp;InterruptedException {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;Test test =&nbsp;new&nbsp;Test();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.set();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getLong());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getString());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread thread1 =&nbsp;new&nbsp;Thread(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.set();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getLong());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getString());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread1.start();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread1.join();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getLong());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getString());\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">这段代码的输出结果为：</span><br></p><p><img alt=\"241058553934886.jpg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/22/saysky/1529667374744\" width=\"536\" height=\"168\"><br></p><p style=\"margin-left: auto;\">从这段代码的输出结果可以看出，在main线程中和thread1线程中，longLocal保存的副本值和stringLocal保存的副本值都不一样。最后一次在main线程再次打印副本值是为了证明在main线程中和thread1线程中的副本值确实是不同的。</p><p style=\"margin-left: auto;\">　<b>　总结一下：</b></p><p style=\"margin-left: auto;\">　　1）实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；</p><p style=\"margin-left: auto;\">　　2）为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；</p><p style=\"margin-left: auto;\">　　3）在进行get之前，必须先set，否则会报空指针异常；</p><p style=\"margin-left: auto;\">　　&nbsp;&nbsp;&nbsp; 如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。</p><p style=\"margin-left: auto;\">　　　 因为在上面的代码分析过程中，我们发现如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null。</p><pre><code class=\"lang-java\">&nbsp;/**\n&nbsp; &nbsp; &nbsp;* Returns the value in the current thread\'s copy of this\n&nbsp; &nbsp; &nbsp;* thread-local variable.&nbsp; If the variable has no value for the\n&nbsp; &nbsp; &nbsp;* current thread, it is first initialized to the value returned\n&nbsp; &nbsp; &nbsp;* by an invocation of the {@link #initialValue} method.\n&nbsp; &nbsp; &nbsp;*\n&nbsp; &nbsp; &nbsp;* @return the current thread\'s value of this thread-local\n&nbsp; &nbsp; &nbsp;*/\n&nbsp; &nbsp; public T get() {\n&nbsp; &nbsp; &nbsp; &nbsp; Thread t = Thread.currentThread();\n&nbsp; &nbsp; &nbsp; &nbsp; ThreadLocalMap map = getMap(t);\n&nbsp; &nbsp; &nbsp; &nbsp; if (map != null) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ThreadLocalMap.Entry e = map.getEntry(this);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e != null) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @SuppressWarnings(\"unchecked\")\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T result = (T)e.value;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return result;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; return setInitialValue();\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; /**\n&nbsp; &nbsp; &nbsp;* Variant of set() to establish initialValue. Used instead\n&nbsp; &nbsp; &nbsp;* of set() in case user has overridden the set() method.\n&nbsp; &nbsp; &nbsp;*\n&nbsp; &nbsp; &nbsp;* @return the initial value\n&nbsp; &nbsp; &nbsp;*/\n&nbsp; &nbsp; private T setInitialValue() {\n&nbsp; &nbsp; &nbsp; &nbsp; T value = initialValue();\n&nbsp; &nbsp; &nbsp; &nbsp; Thread t = Thread.currentThread();\n&nbsp; &nbsp; &nbsp; &nbsp; ThreadLocalMap map = getMap(t);\n&nbsp; &nbsp; &nbsp; &nbsp; if (map != null)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map.set(this, value);\n&nbsp; &nbsp; &nbsp; &nbsp; else\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; createMap(t, value);\n&nbsp; &nbsp; &nbsp; &nbsp; return value;\n&nbsp; &nbsp; }<br></code></pre><p>　　看下面这个例子：<br></p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Test {\n&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal&lt;Long&gt; longLocal =&nbsp;new&nbsp;ThreadLocal&lt;Long&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal&lt;String&gt; stringLocal =&nbsp;new&nbsp;ThreadLocal&lt;String&gt;();\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;set() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;longLocal.set(Thread.currentThread().getId());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringLocal.set(Thread.currentThread().getName());\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;long&nbsp;getLong() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;longLocal.get();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String getString() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;stringLocal.get();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args)&nbsp;throws&nbsp;InterruptedException {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;Test test =&nbsp;new&nbsp;Test();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getLong());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getString());\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread thread1 =&nbsp;new&nbsp;Thread(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.set();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getLong());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getString());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread1.start();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread1.join();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getLong());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getString());\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p style=\"margin-left: auto;\">在main线程中，没有先set，直接get的话，运行时会报空指针异常。</p><p style=\"margin-left: auto;\">　　但是如果改成下面这段代码，即重写了initialValue方法：</p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Test {\n&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal&lt;Long&gt; longLocal =&nbsp;new&nbsp;ThreadLocal&lt;Long&gt;(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;Long initialValue() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Thread.currentThread().getId();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal&lt;String&gt; stringLocal =&nbsp;new&nbsp;ThreadLocal&lt;String&gt;(){;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;String initialValue() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Thread.currentThread().getName();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;set() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;longLocal.set(Thread.currentThread().getId());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringLocal.set(Thread.currentThread().getName());\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;long&nbsp;getLong() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;longLocal.get();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String getString() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;stringLocal.get();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args)&nbsp;throws&nbsp;InterruptedException {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;Test test =&nbsp;new&nbsp;Test();\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.set();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getLong());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getString());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread thread1 =&nbsp;new&nbsp;Thread(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.set();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getLong());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getString());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread1.start();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread1.join();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getLong());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.getString());\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">就可以直接不用先set而直接调用get了。</span><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\"><br></span></p><h2><b style=\"color: rgb(227, 55, 55);\">三、ThreadLocal的应用场景</b></h2><p style=\"margin-left: auto;\">最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。</p><p style=\"margin-left: auto;\">　　如：</p><pre><code class=\"lang-java\">private&nbsp;static&nbsp;ThreadLocal&lt;Connection&gt; connectionHolder\n=&nbsp;new&nbsp;ThreadLocal&lt;Connection&gt;() {\npublic&nbsp;Connection initialValue() {\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;DriverManager.getConnection(DB_URL);\n}\n};\n&nbsp;\npublic&nbsp;static&nbsp;Connection getConnection() {\nreturn&nbsp;connectionHolder.get();\n}<br></code></pre><p style=\"margin-left: auto;\">下面这段代码摘自：</p><p style=\"margin-left: auto;\">　　<a href=\"http://www.iteye.com/topic/103804\" target=\"_blank\">http://www.iteye.com/topic/103804</a></p><pre><code class=\"lang-java\">private&nbsp;static&nbsp;final&nbsp;ThreadLocal threadSession =&nbsp;new&nbsp;ThreadLocal();\n&nbsp;\npublic&nbsp;static&nbsp;Session getSession()&nbsp;throws&nbsp;InfrastructureException {\n&nbsp;&nbsp;&nbsp;&nbsp;Session s = (Session) threadSession.get();\n&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(s ==&nbsp;null) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = getSessionFactory().openSession();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threadSession.set(s);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(HibernateException ex) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;InfrastructureException(ex);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;s;\n}\n<br></code></pre><p style=\"margin-left: auto;\"><br>　　《深入理解Java虚拟机》</p><p style=\"margin-left: auto;\">　　《Java编程思想》</p><p style=\"margin-left: auto;\">　　<a href=\"http://ifeve.com/thread-management-10/\" target=\"_blank\">http://ifeve.com/thread-management-10/</a></p><p style=\"margin-left: auto;\">　　<a href=\"http://www.ibm.com/developerworks/cn/java/j-threads/index3.html\" target=\"_blank\">http://www.ibm.com/developerworks/cn/java/j-threads/index3.html</a></p><p style=\"margin-left: auto;\">　　<a href=\"http://www.iteye.com/topic/103804\" target=\"_blank\">http://www.iteye.com/topic/103804</a></p><p style=\"margin-left: auto;\">　　<a href=\"http://www.iteye.com/topic/777716\" target=\"_blank\">http://www.iteye.com/topic/777716</a></p><p style=\"margin-left: auto;\">　　<a href=\"http://www.iteye.com/topic/757478\" target=\"_blank\">http://www.iteye.com/topic/757478</a></p><p style=\"margin-left: auto;\">　　<a href=\"http://blog.csdn.net/ghsau/article/details/15732053\" target=\"_blank\">http://blog.csdn.net/ghsau/article/details/15732053</a></p><p style=\"margin-left: auto;\">　　<a href=\"http://ispring.iteye.com/blog/162982\" target=\"_blank\">http://ispring.iteye.com/blog/162982</a></p><p style=\"margin-left: auto;\">　　<a href=\"http://blog.csdn.net/imzoer/article/details/8262101\" target=\"_blank\">http://blog.csdn.net/imzoer/article/details/8262101</a></p><p style=\"margin-left: auto;\">　　<a href=\"http://www.blogjava.net/wumi9527/archive/2010/09/10/331654.html\" target=\"_blank\">http://www.blogjava.net/wumi9527/archive/2010/09/10/331654.html</a></p><p style=\"margin-left: auto;\">　　<a href=\"http://bbs.csdn.net/topics/380049261\" target=\"_blank\">http://bbs.csdn.net/topics/380049261</a></p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\">原文地址：<a href=\"https://www.cnblogs.com/dolphin0520/p/3920407.html\" target=\"_blank\">https://www.cnblogs.com/dolphin0520/p/3920407.html</a></p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\">补充：</p><blockquote><p>学习ThreadLocal时看到你的帖子，虽然帖子很老了。但是还是注册一个账号回复一下。</p><p>现学理解帖子有2个地方有歧义：</p><p>1. 开篇说ThreadLocal创建副本，和使用ThreadLocal解决数据库单例在多线程中同时操作查询和关闭的情况是有歧义的。首先我理解不是创建副本，只是分发新的内存地址，以当前线程为key，value指向传入model内存地址。从而达到获取数据线程安全而已。同时因为如此，数据库连接单例如果在2个线程中被引用同一个实例，2线程分别同一时间操作读取和close，肯定会出现冲突。所以需要减少每次new的开销还是得使用数据库连接池。</p><p>2. 你总结中的：在进行get之前，必须先set，否则会报空指针异常；这个不是本身源代码抛出的异常。这个异常是由于你本身的getLong方法返回是long类型，而调用了get方法返回可能是null，null强转long时抛的空指针，如果返回改为Long对象，程序肯定是可以执行完毕的。这点上也是存在歧义的。</p><p>——来自博客园<span style=\"color: rgb(102, 102, 102); font-size: 14px;\">&nbsp;</span>cfriver</p><p style=\"margin-left: auto;\"><br></p></blockquote>', '2018-06-22 19:31:12', '/articles/10024', '0', '0', 'publish', '　　想必很多朋友对ThreadLocal并不陌生，今天我们就来一起探讨下ThreadLocal的使用方法和实现原理。首先，本文先谈一下对ThreadLocal的理解，然后根据ThreadLocal类的源码分析了其实现原理和使用需要注', 'Java,多线程,ThreadLocal', 'Java并发编程：深入剖析ThreadLocal', '2019-03-11 09:36:54', '8', '0', '10008', '1'), ('10025', '0', '0', '<p style=\"margin-left: auto;\">　　在上一篇文章中我们讲到了如何使用关键字synchronized来实现同步访问。本文我们继续来探讨这个问题，从Java 5之后，在java.util.concurrent.locks包下提供了另外一种方式来实现同步访问，那就是Lock。</p><p style=\"margin-left: auto;\">　　也许有朋友会问，既然都可以通过synchronized来实现同步访问了，那么为什么还需要提供Lock？这个问题将在下面进行阐述。本文先从synchronized的缺陷讲起，然后再讲述java.util.concurrent.locks包下常用的有哪些类和接口，最后讨论以下一些关于锁的概念方面的东西</p><p style=\"margin-left: auto;\">　　以下是本文目录大纲：</p><p style=\"margin-left: auto;\">　　一.synchronized的缺陷</p><p style=\"margin-left: auto;\">　　二.java.util.concurrent.locks包下常用的类</p><p style=\"margin-left: auto;\">　　三.锁的相关概念介绍</p><p style=\"margin-left: auto;\">　　若有不正之处请多多谅解，并欢迎批评指正。</p><p style=\"margin-left: auto;\">　　请尊重作者劳动成果，转载请标明原文链接：</p><p style=\"margin-left: auto;\">&nbsp;　　<a href=\"http://www.cnblogs.com/dolphin0520/p/3923167.html\" rel=\"nofollow\">http://www.cnblogs.com/dolphin0520/p/3923167.html</a></p><p style=\"margin-left: auto;\"><br></p><h2><b style=\"color: rgb(227, 55, 55);\">一、synchronized的缺陷</b></h2><p style=\"margin-left: auto;\">synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？</p><p style=\"margin-left: auto;\">　　在上面一篇文章中，我们了解到如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p><p style=\"margin-left: auto;\">　　1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</p><p style=\"margin-left: auto;\">　　2）线程执行发生异常，此时JVM会让线程自动释放锁。</p><p style=\"margin-left: auto;\"><span style=\"color: rgb(227, 55, 55);\">　　那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。</span></p><p style=\"margin-left: auto;\">　　因此就<span style=\"color: rgb(32, 147, 97);\"><b>需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到</b></span>。</p><p style=\"margin-left: auto;\">　　再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</p><p style=\"margin-left: auto;\">　　但是采用synchronized关键字来实现同步的话，就会导致一个问题：</p><p style=\"margin-left: auto;\">　　如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。</p><p style=\"margin-left: auto;\">　　因此就<span style=\"color: rgb(32, 147, 97);\"><b>需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到</b></span>。</p><p style=\"margin-left: auto;\">　　另外，通过<span style=\"color: rgb(32, 147, 97);\"><b>Lock可以知道线程有没有成功获取到锁</b></span>。这个是synchronized无法办到的。</p><p style=\"margin-left: auto;\">　　总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p><p style=\"margin-left: auto;\">　　1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</p><p style=\"margin-left: auto;\">　　2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而<span style=\"color: rgb(32, 147, 97);\"><b>Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象</b></span>。</p><p style=\"margin-left: auto;\"><span style=\"color: rgb(0, 0, 0);\">　　下面我们就来探讨一下java.util.concurrent.locks包中常用的类和接口。</span><br></p><p style=\"margin-left: auto;\">　　</p><h4><b>1.Lock</b></h4><p style=\"margin-left: auto;\">　　首先要说明的就是Lock，通过查看Lock的源码可知，Lock是一个接口：</p><pre><code class=\"lang-java\">public&nbsp;interface&nbsp;Lock {\n&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;lock();\n&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;lockInterruptibly()&nbsp;throws&nbsp;InterruptedException;\n&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;tryLock();\n&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;tryLock(long&nbsp;time, TimeUnit unit)&nbsp;throws&nbsp;InterruptedException;\n&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;unlock();\n&nbsp;&nbsp;&nbsp;&nbsp;Condition newCondition();\n}<br></code></pre><p style=\"margin-left: auto;\">下面来逐个讲述Lock接口中每个方法的使用，lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。newCondition()这个方法暂且不在此讲述，会在后面的线程协作一文中讲述。</p><p style=\"margin-left: auto;\">　　在Lock中声明了四个方法来获取锁，那么这四个方法有何区别呢？</p><p style=\"margin-left: auto;\">　　首先lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</p><p style=\"margin-left: auto;\">　　由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，<span style=\"color: rgb(227, 55, 55);\">使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生</span>。通常使用Lock来进行同步的话，是以下面这种形式去使用的：</p><pre><code class=\"lang-java\">Lock lock = ...;\nlock.lock();\ntry{\n&nbsp;&nbsp;&nbsp;&nbsp;//处理任务\n}catch(Exception ex){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n}finally{\n&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock();&nbsp;&nbsp;&nbsp;//释放锁\n}<br></code></pre><p style=\"margin-left: auto;\">&nbsp; &nbsp; &nbsp; &nbsp;tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p><p style=\"margin-left: auto;\">　　tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p><p style=\"margin-left: auto;\">　　所以，一般情况下通过tryLock来获取锁时是这样使用的：</p><pre><code class=\"lang-java\">Lock lock = ...;\nif(lock.tryLock()) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//处理任务\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(Exception ex){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}finally{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock();&nbsp;&nbsp;&nbsp;//释放锁\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;\n}else&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;//如果不能获取锁，则直接做其他事情\n}\n<br></code></pre><p style=\"margin-left: auto;\">&nbsp; &nbsp; &nbsp; &nbsp; lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</p><p style=\"margin-left: auto;\">　　由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。</p><p style=\"margin-left: auto;\">　　因此lockInterruptibly()一般的使用形式如下：</p><pre><code class=\"lang-java\">public&nbsp;void&nbsp;method()&nbsp;throws&nbsp;InterruptedException {\n&nbsp;&nbsp;&nbsp;&nbsp;lock.lockInterruptibly();\n&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//.....\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;finally&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock();\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n}<br></code></pre><p style=\"margin-left: auto;\">注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。</p><p style=\"margin-left: auto;\">　　因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。</p><p style=\"margin-left: auto;\">　　<span style=\"color: rgb(227, 55, 55);\">而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去</span>。</p><p style=\"margin-left: auto;\">　　</p><p style=\"margin-left: auto;\"><strong>2.ReentrantLock</strong></p><p style=\"margin-left: auto;\">　　ReentrantLock，意思是“可重入锁”，关于可重入锁的概念在下一节讲述。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。</p><p style=\"margin-left: auto;\">　　例子1，lock()的正确使用方法</p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Test {\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;ArrayList&lt;Integer&gt; arrayList =&nbsp;new&nbsp;ArrayList&lt;Integer&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args)&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;Test test =&nbsp;new&nbsp;Test();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.insert(Thread.currentThread());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.start();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.insert(Thread.currentThread());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.start();\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;insert(Thread thread) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lock lock =&nbsp;new&nbsp;ReentrantLock();&nbsp;&nbsp;&nbsp;&nbsp;//注意这个地方\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.lock();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(thread.getName()+\"得到了锁\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;5;i++) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrayList.add(i);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception e) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// TODO: handle exception\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}finally&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(thread.getName()+\"释放了锁\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p><span style=\"color: rgb(0, 0, 0);\">各位朋友先想一下这段代码的输出结果是什么？</span><br></p><p><img alt=\"image.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/22/saysky/1529670443882\" width=\"400\" height=\"89.26014319809069\"><br></p><p style=\"margin-left: auto;\">　　也许有朋友会问，怎么会输出这个结果？第二个线程怎么会在第一个线程释放锁之前得到了锁？原因在于，<span style=\"color: rgb(227, 55, 55);\"><b>在insert方法中的lock变量是局部变量，每个线程执行该方法时都会保存一个副本，那么理所当然每个线程执行到lock.lock()处获取的是不同的锁，所以就不会发生冲突</b></span>。（备注：这个地方输出每次可能都不一样，这里并没有同步，而是new了两个对象，锁不同不能同步）</p><p style=\"margin-left: auto;\">　　知道了原因改起来就比较容易了，只需要将lock声明为类的属性即可。</p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Test {\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;ArrayList&lt;Integer&gt; arrayList =&nbsp;new&nbsp;ArrayList&lt;Integer&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Lock lock =&nbsp;new&nbsp;ReentrantLock();&nbsp;&nbsp;&nbsp;&nbsp;//注意这个地方\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args)&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;Test test =&nbsp;new&nbsp;Test();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.insert(Thread.currentThread());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.start();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.insert(Thread.currentThread());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.start();\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;insert(Thread thread) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.lock();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(thread.getName()+\"得到了锁\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;5;i++) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrayList.add(i);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception e) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// TODO: handle exception\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}finally&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(thread.getName()+\"释放了锁\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p><img alt=\"image.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/22/saysky/1529670256980\" width=\"400\" height=\"94.5107398568019\"><br></p><p><span style=\"color: rgb(0, 0, 0);\">　这样就是正确地使用Lock的方法了。</span><br></p><p><span style=\"color: rgb(0, 0, 0);\"><br></span></p><p><span style=\"color: rgb(0, 0, 0);\"><span style=\"color: rgb(0, 0, 0);\">例子2，tryLock()的使用方法</span><br></span></p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Test {\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;ArrayList&lt;Integer&gt; arrayList =&nbsp;new&nbsp;ArrayList&lt;Integer&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Lock lock =&nbsp;new&nbsp;ReentrantLock();&nbsp;&nbsp;&nbsp;&nbsp;//注意这个地方\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args)&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;Test test =&nbsp;new&nbsp;Test();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.insert(Thread.currentThread());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.start();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.insert(Thread.currentThread());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.start();\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;insert(Thread thread) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(lock.tryLock()) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(thread.getName()+\"得到了锁\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;5;i++) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrayList.add(i);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception e) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// TODO: handle exception\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}finally&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(thread.getName()+\"释放了锁\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(thread.getName()+\"获取锁失败\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p><img alt=\"image.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/22/saysky/1529670703632\" width=\"400\" height=\"98.4\"><br></p><p><br></p><p><span style=\"color: rgb(0, 0, 0);\">例子3，lockInterruptibly()响应中断的使用方法：</span><br></p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Test {\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Lock lock =&nbsp;new&nbsp;ReentrantLock();&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args)&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test test =&nbsp;new&nbsp;Test();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyThread thread1 =&nbsp;new&nbsp;MyThread(test);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyThread thread2 =&nbsp;new&nbsp;MyThread(test);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread1.start();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread2.start();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(2000);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException e) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread2.interrupt();\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;insert(Thread thread)&nbsp;throws&nbsp;InterruptedException{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.lockInterruptibly();&nbsp;&nbsp;&nbsp;//注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(thread.getName()+\"得到了锁\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;startTime = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp; ;) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//插入数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(Thread.currentThread().getName()+\"执行finally\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(thread.getName()+\"释放了锁\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n&nbsp;\nclass&nbsp;MyThread&nbsp;extends&nbsp;Thread {\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Test test =&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;MyThread(Test test) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.test = test;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.insert(Thread.currentThread());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException e) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(Thread.currentThread().getName()+\"被中断\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n<br></code></pre><p><img alt=\"image.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/22/saysky/1529671042243\" width=\"400\" height=\"85.44152744630071\"><br></p><p><br></p><p style=\"margin-left: auto;\">　运行之后，发现thread2能够被正确中断。</p><p style=\"margin-left: auto;\">　　</p><h4><strong>3.ReadWriteLock</strong></h4><p style=\"margin-left: auto;\">　　ReadWriteLock也是一个接口，在它里面只定义了两个方法：</p><pre><code class=\"lang-java\">public&nbsp;interface&nbsp;ReadWriteLock {\n&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Returns the lock used for reading.\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @return the lock used for reading.\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;Lock readLock();\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Returns the lock used for writing.\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @return the lock used for writing.\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;Lock writeLock();\n}<br></code></pre><p style=\"margin-left: auto;\">一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。</p><p style=\"margin-left: auto;\">　　<strong>4.ReentrantReadWriteLock</strong></p><p style=\"margin-left: auto;\">　　ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。</p><p style=\"margin-left: auto;\">　　下面通过几个例子来看一下ReentrantReadWriteLock具体用法。</p><p style=\"margin-left: auto;\">　　假如有多个线程要同时进行读操作的话，先看一下synchronized达到的效果：</p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Test {\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;ReentrantReadWriteLock rwl =&nbsp;new&nbsp;ReentrantReadWriteLock();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args)&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;Test test =&nbsp;new&nbsp;Test();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.get(Thread.currentThread());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.start();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.get(Thread.currentThread());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.start();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;synchronized&nbsp;void&nbsp;get(Thread thread) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;start = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(System.currentTimeMillis() - start &lt;=&nbsp;1) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(thread.getName()+\"正在进行读操作\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(thread.getName()+\"读操作完毕\");\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">这段程序的输出结果会是，直到thread1执行完读操作之后，才会打印thread2执行读操作的信息。</span><br></p><p><font color=\"#000000\"><span style=\"font-size: 14px;\">运行结果</span></font></p><pre><code>Thread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0读操作完毕\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1读操作完毕<br></code></pre><p><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">　而改成用读写锁的话：</span><br></p><pre><code class=\"lang-java\">public&nbsp;class&nbsp;Test {\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;ReentrantReadWriteLock rwl =&nbsp;new&nbsp;ReentrantReadWriteLock();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] args)&nbsp; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;Test test =&nbsp;new&nbsp;Test();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.get(Thread.currentThread());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.start();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.get(Thread.currentThread());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.start();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;get(Thread thread) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rwl.readLock().lock();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;start = System.currentTimeMillis();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(System.currentTimeMillis() - start &lt;=&nbsp;1) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(thread.getName()+\"正在进行读操作\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(thread.getName()+\"读操作完毕\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;finally&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rwl.readLock().unlock();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p>运行结果</p><pre><code>Thread-0正在进行读操作\nThread-0正在进行读操作\nThread-1正在进行读操作\nThread-0正在进行读操作\nThread-1正在进行读操作\nThread-0正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-0正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-0正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-0正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-0正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-0正在进行读操作\nThread-1正在进行读操作\nThread-1正在进行读操作\nThread-0正在进行读操作\nThread-1正在进行读操作\nThread-0正在进行读操作\nThread-1正在进行读操作\nThread-0正在进行读操作\nThread-1正在进行读操作\nThread-0正在进行读操作\nThread-1正在进行读操作\nThread-0正在进行读操作\nThread-1正在进行读操作\nThread-0正在进行读操作\nThread-1正在进行读操作\nThread-0正在进行读操作\nThread-1正在进行读操作\nThread-0读操作完毕\nThread-1读操作完毕<br></code></pre><p style=\"margin-left: auto;\">说明thread1和thread2在同时进行读操作。</p><p style=\"margin-left: auto;\">　　这样就大大提升了读操作的效率。</p><p style=\"margin-left: auto;\">　　不过要注意的是，<span style=\"color: rgb(227, 55, 55);\">如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁</span>。</p><p style=\"margin-left: auto;\">　<span style=\"color: rgb(227, 55, 55);\">　如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁</span>。</p><p style=\"margin-left: auto;\">补充(简而言之：读读共享，写写互斥，读写互斥，写读互斥)</p><p style=\"margin-left: auto;\">　　关于ReentrantReadWriteLock类中的其他方法感兴趣的朋友可以自行查阅API文档。</p><p style=\"margin-left: auto;\">　</p><h4><strong>5.Lock和synchronized的选择</strong></h4><p style=\"margin-left: auto;\">　　总结来说，Lock和synchronized有以下几点不同：</p><p style=\"margin-left: auto;\">　<span style=\"color: rgb(65, 140, 175);\">　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</span></p><p style=\"margin-left: auto;\"><span style=\"color: rgb(65, 140, 175);\">　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</span></p><p style=\"margin-left: auto;\"><span style=\"color: rgb(65, 140, 175);\">　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</span></p><p style=\"margin-left: auto;\"><span style=\"color: rgb(65, 140, 175);\">　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</span></p><p style=\"margin-left: auto;\"><span style=\"color: rgb(65, 140, 175);\">　　5）Lock可以提高多个线程进行读操作的效率。</span></p><p style=\"margin-left: auto;\">　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p><p><br></p><h2><span style=\"color: rgb(227, 55, 55);\">三.锁的相关概念介绍</span></h2><p style=\"margin-left: auto;\">在前面介绍了Lock的基本使用，这一节来介绍一下与锁相关的几个概念。</p><p style=\"margin-left: auto;\">　　<strong>1.可重入锁</strong></p><p style=\"margin-left: auto;\">　　如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，<span style=\"color: rgb(227, 55, 55);\">当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2</span>。</p><p style=\"margin-left: auto;\">　　看下面这段代码就明白了：</p><pre><code>class&nbsp;MyClass {\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;synchronized&nbsp;void&nbsp;method1() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method2();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;synchronized&nbsp;void&nbsp;method2() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}<br></code></pre><p style=\"margin-left: auto;\">&nbsp;　　上述代码中的两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。</p><p style=\"margin-left: auto;\">　　而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。</p><p style=\"margin-left: auto;\">　　</p><p style=\"margin-left: auto;\"><strong>&nbsp; &nbsp; &nbsp; &nbsp;2.可中断锁</strong><br></p><p style=\"margin-left: auto;\">　　可中断锁：顾名思义，就是可以相应中断的锁。</p><p style=\"margin-left: auto;\">　　在Java中，<span style=\"color: rgb(227, 55, 55);\">synchronized就不是可中断锁，而Lock是可中断锁</span>。</p><p style=\"margin-left: auto;\">　　如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p><p style=\"margin-left: auto;\">　　在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。</p><p style=\"margin-left: auto;\">　</p><p style=\"margin-left: auto;\">&nbsp; &nbsp; 　<strong>3.公平锁</strong></p><p style=\"margin-left: auto;\">　　公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</p><p style=\"margin-left: auto;\">　　非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p><p style=\"margin-left: auto;\">　　在Java中，<span style=\"color: rgb(227, 55, 55);\">synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序</span>。</p><p style=\"margin-left: auto;\">　　而对于<span style=\"color: rgb(227, 55, 55);\">ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁</span>。</p><p style=\"margin-left: auto;\">　　看一下这2个类的源代码就清楚了：</p><pre><code class=\"lang-java\">&nbsp;/**\n&nbsp; &nbsp; &nbsp;* Sync object for non-fair locks\n&nbsp; &nbsp; &nbsp;*/\n&nbsp; &nbsp; static final class NonfairSync extends Sync {\n&nbsp; &nbsp; &nbsp; &nbsp; private static final long serialVersionUID = 7316153563782823691L;\n\n&nbsp; &nbsp; &nbsp; &nbsp; /**\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Performs lock.&nbsp; Try immediate barge, backing up to normal\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* acquire on failure.\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/\n&nbsp; &nbsp; &nbsp; &nbsp; final void lock() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (compareAndSetState(0, 1))\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setExclusiveOwnerThread(Thread.currentThread());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; acquire(1);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; protected final boolean tryAcquire(int acquires) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nonfairTryAcquire(acquires);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; /**\n&nbsp; &nbsp; &nbsp;* Sync object for fair locks\n&nbsp; &nbsp; &nbsp;*/\n&nbsp; &nbsp; static final class FairSync extends Sync {\n&nbsp; &nbsp; &nbsp; &nbsp; private static final long serialVersionUID = -3000897897090466540L;\n\n&nbsp; &nbsp; &nbsp; &nbsp; final void lock() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; acquire(1);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; /**\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Fair version of tryAcquire.&nbsp; Don\'t grant access unless\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* recursive call or no waiters or is first.\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/\n&nbsp; &nbsp; &nbsp; &nbsp; protected final boolean tryAcquire(int acquires) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final Thread current = Thread.currentThread();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int c = getState();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (c == 0) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!hasQueuedPredecessors() &amp;&amp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compareAndSetState(0, acquires)) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setExclusiveOwnerThread(current);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (current == getExclusiveOwnerThread()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nextc = c + acquires;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nextc &lt; 0)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new Error(\"Maximum lock count exceeded\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setState(nextc);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }<br></code></pre><p style=\"margin-left: auto;\">&nbsp; &nbsp; &nbsp; &nbsp; 在ReentrantLock中定义了2个静态内部类，一个是NotFairSync，一个是FairSync，分别用来实现非公平锁和公平锁。</p><p style=\"margin-left: auto;\">&nbsp; &nbsp; &nbsp; &nbsp; 我们可以在创建ReentrantLock对象时，通过以下方式来设置锁的公平性：</p><pre><code class=\"lang-java\">ReentrantLock lock =&nbsp;new&nbsp;ReentrantLock(true);<br></code></pre><p>&nbsp;　　如果参数为true表示为公平锁，为fasle为非公平锁。默认情况下，如果使用无参构造器，则是非公平锁。</p><pre><code class=\"lang-java\">&nbsp;/**\n&nbsp; &nbsp; &nbsp;* Creates an instance of {@code ReentrantLock}.\n&nbsp; &nbsp; &nbsp;* This is equivalent to using {@code ReentrantLock(false)}.\n&nbsp; &nbsp; &nbsp;*/\n&nbsp; &nbsp; public ReentrantLock() {\n&nbsp; &nbsp; &nbsp; &nbsp; sync = new NonfairSync();\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; /**\n&nbsp; &nbsp; &nbsp;* Creates an instance of {@code ReentrantLock} with the\n&nbsp; &nbsp; &nbsp;* given fairness policy.\n&nbsp; &nbsp; &nbsp;*\n&nbsp; &nbsp; &nbsp;* @param fair {@code true} if this lock should use a fair ordering policy\n&nbsp; &nbsp; &nbsp;*/\n&nbsp; &nbsp; public ReentrantLock(boolean fair) {\n&nbsp; &nbsp; &nbsp; &nbsp; sync = fair ? new FairSync() : new NonfairSync();\n&nbsp; &nbsp; }<br></code></pre><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\">另外在ReentrantLock类中定义了很多方法，比如：</p><p style=\"margin-left: auto;\">　　isFair()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //判断锁是否是公平锁</p><p style=\"margin-left: auto;\">　　isLocked()&nbsp;&nbsp;&nbsp; //判断锁是否被任何线程获取了</p><p style=\"margin-left: auto;\">　　isHeldByCurrentThread()&nbsp;&nbsp; //判断锁是否被当前线程获取了</p><p style=\"margin-left: auto;\">　　hasQueuedThreads()&nbsp;&nbsp; //判断是否有线程在等待该锁</p><p style=\"margin-left: auto;\">　　在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\">　　<strong>4.读写锁</strong></p><p style=\"margin-left: auto;\">　　读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。</p><p style=\"margin-left: auto;\">　　正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。</p><p style=\"margin-left: auto;\">　　ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。</p><p style=\"margin-left: auto;\">　　可以通过readLock()获取读锁，通过writeLock()获取写锁。</p><p style=\"margin-left: auto;\">　　上面已经演示过了读写锁的使用方法，在此不再赘述。</p><p style=\"margin-left: auto;\">&nbsp;</p><p style=\"margin-left: auto;\">　　参考资料：</p><p style=\"margin-left: auto;\">　　<a href=\"http://blog.csdn.net/ns_code/article/details/17487337\" target=\"_blank\">http://blog.csdn.net/ns_code/article/details/17487337</a></p><p style=\"margin-left: auto;\">　　<a href=\"http://houlinyan.iteye.com/blog/1112535\" target=\"_blank\">http://houlinyan.iteye.com/blog/1112535</a></p><p style=\"margin-left: auto;\">　　<a href=\"http://ifeve.com/locks/\" target=\"_blank\">http://ifeve.com/locks/</a></p><p style=\"margin-left: auto;\">　　<a href=\"http://ifeve.com/read-write-locks/\" target=\"_blank\">http://ifeve.com/read-write-locks/</a></p><p style=\"margin-left: auto;\">　　<a href=\"http://blog.csdn.net/fancyerii/article/details/6783224\" target=\"_blank\">http://blog.csdn.net/fancyerii/article/details/6783224</a></p><p style=\"margin-left: auto;\">　　<a href=\"http://blog.csdn.net/ghsau/article/details/7461369/\" target=\"_blank\">http://blog.csdn.net/ghsau/article/details/7461369/</a></p><p style=\"margin-left: auto;\">　　<a href=\"http://blog.csdn.net/zhaozhenzuo/article/details/37109015\" target=\"_blank\">http://blog.csdn.net/zhaozhenzuo/article/details/37109015</a></p><p><br></p><p>原文地址：<a href=\"http://www.cnblogs.com/dolphin0520/p/3923167.html\" target=\"_blank\">http://www.cnblogs.com/dolphin0520/p/3923167.html</a></p>', '2018-06-22 21:01:11', '/articles/10025', '0', '0', 'publish', '　　在上一篇文章中我们讲到了如何使用关键字synchronized来实现同步访问。本文我们继续来探讨这个问题，从Java 5之后，在java.util.concurrent.locks包下提供了另外一种方式来实现同步访问，那就是Lock。<', 'Java,多线程,Lock,锁,读写锁', 'Java并发编程：Lock', '2018-07-06 23:39:09', '7', '0', '10008', '1');
INSERT INTO `article` VALUES ('10026', '0', '0', '<p style=\"text-align: justify;\"><a href=\"http://lib.csdn.net/base/java\" target=\"_blank\" style=\"\">Java</a>中的线程的生命周期大体可分为5种状态。</p><p>1.&nbsp;新建(NEW)：新创建了一个线程对象。<br></p><p style=\"text-align: justify;\">2.&nbsp;可运行(RUNNABLE)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p><p>3.&nbsp;运行(RUNNING)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。<br>4.&nbsp;阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种：&nbsp;<br></p><blockquote>(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。<br>(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。<br>(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</blockquote><p>5.&nbsp;死亡(DEAD)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p><h2><b style=\"\"><span style=\"color: rgb(227, 55, 55);\">一.线程的状态图</span></b><br></h2><p><span style=\"color: rgb(54, 46, 43);\"><b style=\"\"><span style=\"font-size: 1.5em;\"><img alt=\"7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/23/saysky/1529721150274\" width=\"949\" height=\"700\"><br></span></b></span></p><p><span style=\"color: rgb(54, 46, 43);\"><b style=\"\"><span style=\"font-size: 1.5em;\"><br></span></b></span></p><h2><b style=\"\"><span style=\"color: rgb(227, 55, 55);\">二.初始状态</span><br></b></h2><ol><li>实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态</li></ol><p><br></p><h2><b style=\"color: rgb(227, 55, 55);\">三.可运行状态（Runable）</b><br></h2><ol><li>可运行状态只是说你资格运行，调度程序没有挑选到你，你就永远是可运行状态。</li><li>调用线程的start()方法，此线程进入可运行状态。</li><li>当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入可运行状态。</li><li>当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入可运行状态。</li><li>锁池里的线程拿到对象锁后，进入可运行状态。</li></ol><p style=\"text-align: justify;\"><br></p><h2><span style=\"color: rgb(227, 55, 55);\"><b>四.运行状态（Running）</b></span><br></h2><ol><li>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。<br></li></ol><p><br></p><h2><b style=\"color: rgb(227, 55, 55);\">五.死亡状态（Dead）</b><br></h2><ol><li>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。</li><li>在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</li></ol><p><br></p><h2><span style=\"color: rgb(227, 55, 55);\"><b style=\"\">六.阻塞状态（Blocked）</b><br></span></h2><ol><li>当前线程T调用Thread.sleep()方法，当前线程进入阻塞状态。</li><li>运行在当前线程里的其它线程t2调用join()方法，当前线程进入阻塞状态。</li><li>等待用户输入的时候，当前线程进入阻塞状态。</li></ol><p><br></p><h2><b style=\"\"><span style=\"color: rgb(227, 55, 55);\">七.等待队列(本是Object里的方法，但影响了线程)</span></b><br></h2><ol><li>调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj) 代码段内。</li><li>与等待队列相关的步骤和图</li></ol><ul><li>线程1获取对象A的锁，正在使用对象A。</li><li>线程1调用对象A的wait()方法。</li><li>线程1释放对象A的锁，并马上进入等待队列。</li><li>锁池里面的对象争抢对象A的锁。<br></li><li>线程5获得对象A的锁，进入synchronized块，使用对象A。</li><li>线程5调用对象A的notifyAll()方法，唤醒所有线程，所有线程进入锁池。||||| 线程5调用对象A的notify()方法，唤醒一个线程，不知道会唤醒谁，被唤醒的那个线程进入锁池。</li><li>notifyAll()方法所在synchronized结束，线程5释放对象A的锁。</li><li>锁池里面的线程争抢对象锁，但线程1什么时候能抢到就不知道了。||||| 原本锁池+第6步被唤醒的线程一起争抢对象锁。</li></ul><p><img alt=\"3f19f0fb-33ae-322f-9f6a-035f0bf3a2d5.jpg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/23/saysky/1529722360040\" width=\"936\" height=\"702\"><br></p><p><br></p><h2><b style=\"\"><span style=\"color: rgb(227, 55, 55);\">八.锁池状态</span></b><br></h2><ol><li>当前线程想调用对象A的同步方法时，发现对象A的锁被别的线程占有，此时当前线程进入锁池状态。简言之，锁池里面放的都是想争夺对象锁的线程。</li><li>当一个线程1被另外一个线程2唤醒时，1线程进入锁池状态，去争夺对象锁。</li><li>锁池是在同步的环境下才有的概念，一个对象对应一个锁池。</li></ol><p><br></p><h2><b><span style=\"color: rgb(227, 55, 55);\">九.几个方法的比较</span></b></h2><ol><li>Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入阻塞，但不释放对象锁，millis后线程自动苏醒进入可运行状态。<span style=\"color: rgb(227, 55, 55);\">作用：给其它线程执行机会的最佳方式</span>。</li><li>Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的cpu时间片，由运行状态变会可运行状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。</li><li>t.join()/t.join(long millis)，当前线程里调用其它线程1的join方法，当前线程阻塞，但不释放对象锁，直到线程1执行完毕或者millis时间到，当前线程进入可运行状态。</li><li>obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout)timeout时间到自动唤醒。</li><li>obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。</li></ol><p><br></p><h2><b style=\"color: rgb(227, 55, 55);\">十.两个疑问</b></h2><ol><li>当对象锁被某一线程释放的一瞬间，锁池里面的哪个线程能获得这个锁？随机？队列FIFO？or sth else？</li><li>等待队列里许许多多的线程都wait()在一个对象上，此时某一线程调用了对象的notify()方法，那唤醒的到底是哪个线程？随机？队列FIFO？or sth else？java文档就简单的写了句：选择是任意性的。</li></ol>', '2018-06-22 23:22:31', '/articles/10026', '0', '0', 'publish', 'Java中的线程的生命周期大体可分为5种状态。1. 新建(NEW)：新创建', 'Java,多线程', '线程的五大状态', '2018-10-30 22:54:31', '10', '0', '10008', '1'), ('10027', '0', '0', '<p>下面是Java线程相关的热门面试题，你可以用它来好好准备面试。</p><h4><b>1) 什么是线程？</b></h4><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。欲了解更多详细信息请<a href=\"http://java67.blogspot.com/2014/01/10-points-about-thread-and-javalangthread-in-java.html\" target=\"_blank\">点击这里</a>。</p><h4><b>2) 线程和进程有什么区别？</b></h4><p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。更多详细信息请<a href=\"http://java67.blogspot.com/2012/12/what-is-difference-between-thread-vs-process-java.html\" target=\"_blank\">点击这里</a>。</p><h4><b>3) 如何在Java中实现线程？</b></h4><p>在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。更多详细信息请<a href=\"http://javarevisited.blogspot.sg/2011/02/how-to-implement-thread-in-java.html\" target=\"_blank\">点击这里</a>.</p><h4><b>4) 用Runnable还是Thread？</b></h4><p>这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。更多详细信息请<a href=\"http://javarevisited.blogspot.sg/2012/01/difference-thread-vs-runnable-interface.html\" target=\"_blank\">点击这里</a>。</p><h4><b>6) Thread 类中的start() 和 run() 方法有什么区别？</b></h4><p>这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。更多讨论请<a href=\"http://javarevisited.blogspot.sg/2012/03/difference-between-start-and-run-method.html\" target=\"_blank\">点击这里</a></p><h4><b>7) Java中Runnable和Callable有什么不同？</b></h4><p>Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是<span style=\"color: rgb(227, 55, 55);\">Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象</span>。<a href=\"http://java67.blogspot.com/2013/01/difference-between-callable-and-runnable-java.html\" target=\"_blank\">我的博客</a>有更详细的说明。</p><h4><b>8) Java中CyclicBarrier 和 CountDownLatch有什么不同？</b></h4><p>CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。<a href=\"http://javarevisited.blogspot.com/2012/07/cyclicbarrier-example-java-5-concurrency-tutorial.html\" target=\"_blank\">点此查看更多信息和示例代码</a>。</p><h4><b>9) Java内存模型是什么？</b></h4><p>Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：</p><ul><li>线程内的代码能够按先后顺序执行，这被称为程序次序规则。</li><li>对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。</li><li>前一个对<code>volatile</code>的写操作在后一个<code>volatile</code>的读操作之前，也叫<code>volatile</code>变量规则。</li><li>一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。</li><li>一个线程的所有操作都会在线程终止之前，线程终止规则。</li><li>一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。</li><li>可传递性</li></ul><p>我强烈建议大家阅读《Java并发编程实践》第十六章来加深对Java内存模型的理解。</p><h4><b>10) Java中的volatile 变量是什么？</b></h4><p>volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。<a href=\"http://javarevisited.blogspot.com/2011/06/volatile-keyword-java-example-tutorial.html\" target=\"_blank\">点击这里</a>查看更多volatile的相关内容。</p><h4><b>11) 什么是线程安全？Vector是一个线程安全类吗？</b> （<a href=\"http://javarevisited.blogspot.sg/2011/09/difference-vector-vs-arraylist-in-java.html\" target=\"_blank\">详见这里</a>)</h4><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p><h4><b>12) Java中什么是竞态条件？ 举个例子说明。</b></h4><p>竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理，详见<a href=\"http://javarevisited.blogspot.com/2012/02/what-is-race-condition-in.html\" target=\"_blank\">答案</a>。</p><h4><b>13) Java中如何停止一个线程？</b></h4><p>Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像s<span style=\"color: rgb(227, 55, 55);\">top(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了</span>，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程。<a href=\"http://javarevisited.blogspot.com/2011/10/how-to-stop-thread-java-example.html\" target=\"_blank\">点击这里</a>查看示例代码。</p><h4><b>14) 一个线程运行时发生异常会怎样？</b></h4><p>这是我在一次面试中遇到的一个<a href=\"http://java67.blogspot.sg/2012/09/top-10-tricky-java-interview-questions-answers.html\" target=\"_blank\">很刁钻的Java面试题</a>, 简单的说，如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p><h4><b>15） 如何在两个线程间共享数据？</b></h4><p>你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。这篇教程<a href=\"http://javarevisited.blogspot.sg/2013/12/inter-thread-communication-in-java-wait-notify-example.html\" target=\"_blank\">《Java线程间通信》</a>(涉及到在两个线程间共享对象)用wait和notify方法实现了生产者消费者模型。</p><h4><b>16) Java中notify 和 notifyAll有什么区别？</b></h4><p>这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。<a href=\"http://javarevisited.blogspot.com/2012/10/difference-between-notify-and-notifyall-java-example.html\" target=\"_blank\">我的博客</a>有更详细的资料和示例代码。</p><h4><b>17) 为什么wait, notify 和 notifyAll这些方法不在thread类里面？</b></h4><p>这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是<span style=\"color: rgb(227, 55, 55);\">JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得</span>。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。<span style=\"color: rgb(227, 55, 55);\">简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象</span>。你也可以查看<a href=\"http://javarevisited.blogspot.sg/2012/02/why-wait-notify-and-notifyall-is.html\" target=\"_blank\">这篇文章</a>了解更多。</p><h4><b>18) 什么是ThreadLocal变量？</b></h4><p>ThreadLocal是Java里一种特殊的变量。<span style=\"color: rgb(227, 55, 55);\">每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。</span>它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。查看<a href=\"http://javarevisited.blogspot.sg/2012/05/how-to-use-threadlocal-in-java-benefits.html\" target=\"_blank\">答案</a>了解更多。</p><h4><b>19) 什么是FutureTask？</b></h4><p>在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p><h4><b>20) Java中interrupted 和 isInterruptedd方法的区别？</b></h4><p>interrupted()&nbsp;和&nbsp;isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用<a href=\"http://java67.blogspot.com/2012/11/what-is-static-class-variable-method.html\" target=\"_blank\">静态方法</a>Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p><h4><b>21) 为什么wait和notify方法要在同步块中调用？</b></h4><p>主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p><h4><b>22) 为什么你应该在循环中检查等待条件?</b></h4><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《<a href=\"http://www.amazon.com/gp/product/B000WJOUPA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B000WJOUPA&amp;linkCode=as2&amp;tag=job0ae-20\" target=\"_blank\">Effective Java</a>》这本书中的线程和同步章节。</p><h4><b>23) Java中的同步集合与并发集合有什么区别？</b></h4><p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。<span style=\"color: rgb(227, 55, 55);\">Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性</span>。更多内容详见<a href=\"http://javarevisited.blogspot.com/2010/10/what-is-difference-between-synchronized.html\" target=\"_blank\">答案</a>。</p><h4><b>24） Java中堆和栈有什么不同？</b></h4><p>为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，<span style=\"color: rgb(227, 55, 55);\">一个线程中存储的变量对其它线程是不可见的</span>。而<span style=\"color: rgb(227, 55, 55);\">堆是所有线程共享的一片公用内存区域</span>。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。<br>更多内容详见<a href=\"http://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html\" target=\"_blank\">答案</a>。</p><h4><b>25） 什么是线程池？ 为什么要使用它？</b></h4><p>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。更多内容详见<a href=\"http://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html\" target=\"_blank\">这篇文章</a>。</p><h4><b>26） 如何写代码来解决生产者消费者问题？</b></h4><p>在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型，<a href=\"http://javarevisited.blogspot.sg/2012/02/producer-consumer-design-pattern-with.html\" target=\"_blank\">这篇教程</a>有实现它。</p><h4><b>27） 如何避免死锁？</b></h4><p><img src=\"http://incdn1.b0.upaiyun.com/2014/08/f6ff3f486be6901f09c07fa68db9771c.jpg\" alt=\"\" width=\"420\" height=\"241\"><br>Java多线程中的死锁<br>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：</p><ul><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><p>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。<a href=\"http://javarevisited.blogspot.com/2010/10/what-is-deadlock-in-java-how-to-fix-it.html\" target=\"_blank\">这篇教程</a>有代码示例和避免死锁的讨论细节。</p><h4><b>28) Java中活锁和死锁有什么区别？</b></h4><p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p><h4><b>29） 怎么检测一个线程是否拥有锁？</b></h4><p>我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。你可以查看<a href=\"http://javarevisited.blogspot.com/2010/10/how-to-check-if-thread-has-lock-on.html\" target=\"_blank\">这篇文章</a>了解更多。</p><h4><b>30) 你如何在Java中获取线程堆栈？</b></h4><p>对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。</p><h4><b>31) JVM中哪个参数是用来控制线程的栈堆栈小的</b></h4><p>这个问题很简单， -Xss参数用来控制线程的堆栈大小。你可以查看<a href=\"http://javarevisited.blogspot.com/2011/11/hotspot-jvm-options-java-examples.html\" target=\"_blank\">JVM配置列表</a>来了解这个参数的更多信息。</p><h4><b>32） Java中synchronized 和 ReentrantLock 有什么不同？</b></h4><p>Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。你可以查看<a href=\"http://javarevisited.blogspot.com/2013/03/reentrantlock-example-in-java-synchronized-difference-vs-lock.html\" target=\"_blank\">这篇文章</a>了解更多</p><h4><b>33） 有三个线程T1，T2，T3，怎么确保它们按顺序执行？</b></h4><p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。你可以查看<a href=\"http://javarevisited.blogspot.sg/2013/02/how-to-join-multiple-threads-in-java-example-tutorial.html\" target=\"_blank\">这篇文章</a>了解更多。</p><h4><b>34) Thread类中的yield方法有什么作用？</b></h4><p>Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。<a href=\"http://java67.blogspot.sg/2012/08/difference-between-yield-and-wait.html\" target=\"_blank\">点击这里</a>查看更多yield方法的相关内容。</p><h4><b>35） Java中ConcurrentHashMap的并发度是什么？</b></h4><p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。欲了解更多并发度和内部大小调整请阅读我的文章<a href=\"http://javarevisited.blogspot.com/2013/02/concurrenthashmap-in-java-example-tutorial-working.html\" target=\"_blank\">How ConcurrentHashMap works in Java</a>。</p><h4><b>36） Java中Semaphore是什么？</b></h4><p>Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。更多详细信息请<a href=\"http://javarevisited.blogspot.com/2012/05/counting-semaphore-example-in-java-5.html\" target=\"_blank\">点击这里</a>。</p><h4><b>37）如果你提交任务时，线程池队列已满。会时发会生什么？</b></h4><p>这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。</p><h4><b>38) Java线程池中submit() 和 execute()方法有什么区别？</b></h4><p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。更多详细信息请<a href=\"http://javarevisited.blogspot.sg/2013/07/how-to-create-thread-pools-in-java-executors-framework-example-tutorial.html\" target=\"_blank\">点击这里</a>。</p><h4><b>39) 什么是阻塞式方法？</b></h4><p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。更多详细信息请<a href=\"http://javarevisited.blogspot.sg/2012/02/what-is-blocking-methods-in-java-and.html\" target=\"_blank\">点击这里</a>。</p><h4><b>40) Swing是线程安全的吗？ 为什么？</b></h4><p>你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。<a href=\"http://javarevisited.blogspot.com/2013/08/why-swing-is-not-thread-safe-in-java-Swingworker-Event-thread.html\" target=\"_blank\">点击这里</a>查看更多swing和线程安全的相关内容。</p><h4><b>41） Java中invokeAndWait 和 invokeLater有什么区别？</b></h4><p>这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。更多详细信息请<a href=\"http://javarevisited.blogspot.com/2011/09/invokeandwait-invokelater-swing-example.html\" target=\"_blank\">点击这里</a>。</p><h4><b>42) Swing API中那些方法是线程安全的？</b></h4><p>这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。</p><h4><b>43) 如何在Java中创建Immutable对象？</b></h4><p>这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。我的文章<a href=\"http://javarevisited.blogspot.com/2013/03/how-to-create-immutable-class-object-java-example-tutorial.html\" target=\"_blank\">how to make an object Immutable in Java</a>有详细的教程，看完你可以充满自信。</p><h4><b>44） Java中的ReadWriteLock是什么？</b></h4><p>一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。</p><h4><b>45) 多线程中的忙循环是什么?</b></h4><p>忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。你可以查看<a href=\"http://java67.blogspot.com/2012/08/5-thread-interview-questions-answers-in.html\" target=\"_blank\">这篇文章</a>获得更多信息。</p><h4><b>46）volatile 变量和 atomic 变量有什么不同？</b></h4><p>这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p><h4><b>47) 如果同步块内的线程抛出异常会发生什么？</b></h4><p>这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在<a href=\"http://javarevisited.blogspot.com/2012/11/difference-between-final-finally-and-finalize-java.html\" target=\"_blank\">finally block</a>里释放锁实现。</p><h4><b>48） 单例模式的双检锁是什么？</b></h4><p>这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。你可以查看<a href=\"http://javarevisited.blogspot.sg/2014/05/double-checked-locking-on-singleton-in-java.html\" target=\"_blank\">how double checked locking on Singleton works</a>这篇文章获得更多信息。</p><h4><b>49） 如何在Java中创建线程安全的Singleton？</b></h4><p>这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。你可以查看<a href=\"http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html\" target=\"_blank\">这篇文章</a>获得更多信息。</p><h4><b>50) 写出3条你遵循的多线程最佳实践</b></h4><p>这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：</p><ul><li>给你的线程起个有意义的名字。<br>这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</li><li>避免锁定和缩小同步的范围<br>锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</li><li>多用同步类少用wait 和 notify<br>首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</li><li>多用并发集合少用同步集合<br>这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。我的文章<a href=\"http://javarevisited.blogspot.com/2013/02/concurrent-collections-from-jdk-56-java-example-tutorial.html\" target=\"_blank\">Java并发集合</a>有更详细的说明。</li></ul><h4><b>51) 如何强制启动一个线程？</b></h4><p>这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。</p><h4><b>52) Java中的fork join框架是什么？</b></h4><p>fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。你可以查看<a href=\"http://javarevisited.blogspot.com/2011/09/fork-join-task-java7-tutorial.html\" target=\"_blank\">这篇文章</a>获得更多信息。</p><h4><b>53） Java多线程中调用wait() 和 sleep()方法有什么不同？</b></h4><p>Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。你可以查看<a href=\"http://javarevisited.blogspot.com/2011/12/difference-between-wait-sleep-yield.html\" target=\"_blank\">这篇文章</a>获得更多信息。</p><p>以上就是50道热门Java多线程和并发面试题啦。我没有分享所有题的答案但给未来的阅读者提供了足够的提示和线索来寻找答案。如果你真的找不到某题的答案，联系我吧，我会加上去的。这篇文章不仅可以用来准备面试，还能检查你对多线程、并发、设计模式和竞态条件、死锁和线程安全等线程问题的理解。我打算把这篇文章的问题弄成所有Java多线程问题的大合集，但是没有你的帮助恐怖是不能完成的，你也可以跟我分享其它任何问题，包括那些你被问到却还没有找到答案的问题。这篇文章对初学者或者是经验丰富的Java开发人员都很有用，过两三年甚至五六年你再读它也会受益匪浅。它可以扩展初学者尤其有用因为这个可以扩展他们的知识面，我会不断更新这些题，大家可以在文章后面的评论中提问，分享和回答问题一起把这篇面试题完善。</p>', '2018-06-23 16:00:01', '/articles/10027', '0', '0', 'publish', '下面是Java线程相关的热门面试题，你可以用它来好好准备面试。1) 什么是线程？线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果', 'Java,面试,多线程', '50道Java线程面试题', '2018-10-12 15:36:35', '13', '1', '10008', '1'), ('10028', '0', '0', '<h2><span style=\"color: rgb(227, 55, 55);\"><b>一、并发环境下为什么使用ConcurrentHashMap</b></span></h2><p style=\"text-align: justify;\"><font>1. HashMap在高并发的环境下，<span style=\"color: rgb(65, 140, 175);\">执行put操作会导致HashMap的Entry链表形成环形数据结构，从而导致Entry的next节点始终不为空，因此产生死循环获取Entry</span></font></p><p style=\"text-align: justify;\"><font>2. HashTable虽然是线程安全的，但是效率低下，<span style=\"color: rgb(65, 140, 175);\">当一个线程访问HashTable的同步方法时，其他线程如果也访问HashTable的同步方法，那么会进入阻塞或者轮训状态</span>。</font></p><p style=\"text-align: justify;\"><font>3. 在jdk1.6中ConcurrentHashMap使用锁分段技术提高并发访问效率。首先将数据分成一段一段地存储，然后给每一段数据配一个锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问。然而在jdk1.8中的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层依然采用数组+链表+红黑树的存储结构。</font></p><h2><span style=\"color: rgb(227, 55, 55);\"><b>二、JDK1.6分析</b></span></h2><p style=\"text-align: justify;\"><font>ConcurrentHashMap采用 分段锁的机制，实现并发的更新操作，底层由Segment数组和HashEntry数组组成。Segment继承ReentrantLock用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶。HashEntry 用来封装映射表的键 / 值对；每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组，下面我们通过一个图来演示一下 ConcurrentHashMap 的结构：</font></p><p><img alt=\"20170215184554296.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/23/saysky/1529742349915\" width=\"637\" height=\"535\"><br></p><p><br></p><h2><span style=\"color: rgb(227, 55, 55);\"><b>三、JDK1.8分析</b></span></h2><p style=\"text-align: justify;\"><font>改进一：取消segments字段，直接采用<code>transient volatile HashEntry&lt;K,V&gt; table</code>保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</font></p><p style=\"text-align: justify;\"><font>改进二：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中。如果hash之后散列的很均匀，那么table数组中的每个队列长度主要为0或者1。但实际情况并非总是如此理想，虽然ConcurrentHashMap类默认的加载因子为0.75，<span style=\"color: rgb(227, 55, 55);\">但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能</span>。</font></p><h2><br></h2><h2><b style=\"color: rgb(227, 55, 55);\">四、ConcurrentHashMap的重要属性</b></h2><pre><code class=\"lang-java\">/**\n * races. Updated via CAS.\n * 记录容器的容量大小，通过CAS更新\n */\n private static final long BASECOUNT;\n\n/**\n * 这个sizeCtl是volatile的，那么他是线程可见的，一个思考:它是所有修改都在CAS中进行，但是sizeCtl为什么不设计成LongAdder(jdk8出现的)类型呢？\n * 或者设计成AtomicLong(在高并发的情况下比LongAdder低效)，这样就能减少自己操作CAS了。\n *\n * 默认为0，用来控制table的初始化和扩容操作，具体应用在后续会体现出来。\n * -1 代表table正在初始化\n * -N 表示有N-1个线程正在进行扩容操作\n * 其余情况：\n *1、如果table未初始化，表示table需要初始化的大小。\n *2、如果table初始化完成，表示table的容量，默认是table大小的0.75 倍，居然用这个公式算0.75（n - (n &gt;&gt;&gt; 2)）。\n **/\nprivate static final long SIZECTL;\n\n/**\n *  自旋锁 （锁定通过 CAS） 在调整大小和/或创建 CounterCells 时使用。 在CounterCell类更新value中会使用，功能类似显示锁和内置锁，性能更好\n *  在Striped64类也有应用\n */\n private static final long CELLSBUSY;<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: large;\">Node：保存key，value及key的hash值的数据结构。其中value和next都用volatile修饰，保证并发的可见性。</span><br></p><pre><code class=\"lang-java\">    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n        final int hash;\n        final K key;\n        volatile V val;//volatile类型的\n        volatile Node&lt;K,V&gt; next;//volatile类型的\n\n\n        Node(int hash, K key, V val, Node&lt;K,V&gt; next) {\n            this.hash = hash;\n            this.key = key;\n            this.val = val;\n            this.next = next;\n        }\n        //省略部分代码\n       }<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: large;\">ForwardingNode：一个特殊的Node节点，hash值为-1，其中存储nextTable的引用。</span><br></p><pre><code class=\"lang-java\">    static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; {\n        final Node&lt;K,V&gt;[] nextTable;\n        ForwardingNode(Node&lt;K,V&gt;[] tab) {\n            super(MOVED, null, null, null);\n            this.nextTable = tab;\n        }\n        //省略部分代码\n        }<br></code></pre><p><br></p><p><br></p><h2><b style=\"color: rgb(227, 55, 55);\">五、ConcurrentHashMap的构造函数</b></h2><pre><code class=\"lang-java\">   //默认的构造函数\n    public ConcurrentHashMap(){}\n\n    /**\n    *initialCapacity 初始化容量\n    **/\n    public ConcurrentHashMap(int initialCapacity) {}\n\n    /**\n    *\n    *创建与给定map具有相同映射的新map\n    **/\n    public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m){}\n   /**\n    *initialCapacity 初始容量\n    *loadFactor 负载因子,当容量达到initialCapacity*loadFactor时，执行扩容\n    *concurrencyLevel 预估的并发更新线程数\n    **/\n    public ConcurrentHashMap(int initialCapacity, float loadFactor) {}\n\n    /**\n    *initialCapacity 初始容量\n    *loadFactor 负载因子\n    *concurrencyLevel 预估的并发更新线程数\n    **/\n     public ConcurrentHashMap(int initialCapacity,\n                             float loadFactor, int concurrencyLevel) {}<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: large;\">接下来具体看看第四个构造函数的具体实现：</span><br></p><pre><code class=\"lang-java\"> public ConcurrentHashMap(int initialCapacity,\n                             float loadFactor, int concurrencyLevel) {\n        if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)\n            throw new IllegalArgumentException();\n        if (initialCapacity &lt; concurrencyLevel)   //至少使用尽可能多的bin\n            initialCapacity = concurrencyLevel;   //作为估计线程\n        long size = (long)(1.0 + (long)initialCapacity / loadFactor);\n        int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?\n            MAXIMUM_CAPACITY : tableSizeFor((int)size);\n        this.sizeCtl = cap;//初始化sizeCtl\n    }\n    /**\n    *返回给定所需容量，table的大小总是2的幂次方\n    **/\n    private static final int tableSizeFor(int c) {\n        int n = c - 1;\n        n |= n &gt;&gt;&gt; 1;\n        n |= n &gt;&gt;&gt; 2;\n        n |= n &gt;&gt;&gt; 4;\n        n |= n &gt;&gt;&gt; 8;\n        n |= n &gt;&gt;&gt; 16;\n        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }<br></code></pre><p style=\"text-align: justify;\"><font>ConcurrentHashMap在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作</font></p><p><font><br></font></p><p><font><br><br></font></p><h2><b style=\"color: rgb(227, 55, 55);\">六、put()方法的实现</b></h2><pre><code class=\"lang-java\">    public V put(K key, V value) {\n        return putVal(key, value, false);\n    }\n\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) throw new NullPointerException();\n    int hash = spread(key.hashCode());//对hashCode进行再散列，算法为(h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS\n    int binCount = 0;\n //这边加了一个循环，就是不断的尝试，因为在table的初始化和casTabAt用到了compareAndSwapInt、compareAndSwapObject\n    //因为如果其他线程正在修改tab，那么尝试就会失败，所以这边要加一个for循环，不断的尝试\n    for (Node&lt;K,V&gt;[] tab = table;;) {\n        Node&lt;K,V&gt; f; int n, i, fh;\n        // 如果table为空，初始化；否则，根据hash值计算得到数组索引i，如果tab[i]为空，直接新建节点Node即可。注：tab[i]实质为链表或者红黑树的首节点。\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n\n        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {\n            if (casTabAt(tab, i, null,\n                         new Node&lt;K,V&gt;(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        // 如果tab[i]不为空并且hash值为MOVED(-1)，说明该链表正在进行transfer操作，返回扩容完成后的table。\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else {\n            V oldVal = null;\n            // 针对首个节点进行加锁操作，而不是segment，进一步减少线程冲突\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    if (fh &gt;= 0) {\n                        binCount = 1;\n                        for (Node&lt;K,V&gt; e = f;; ++binCount) {\n                            K ek;\n                            // 如果在链表中找到值为key的节点e，直接设置e.val = value即可。\n                            if (e.hash == hash &amp;&amp;\n                                ((ek = e.key) == key ||\n                                 (ek != null &amp;&amp; key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            // 如果没有找到值为key的节点，直接新建Node并加入链表即可。\n                            Node&lt;K,V&gt; pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node&lt;K,V&gt;(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    // 如果首节点为TreeBin类型，说明为红黑树结构，执行putTreeVal操作。\n                    else if (f instanceof TreeBin) {\n                        Node&lt;K,V&gt; p;\n                        binCount = 2;\n                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,\n                                                       value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            if (binCount != 0) {\n                // 如果节点数&gt;＝8，那么转换链表结构为红黑树结构。\n                if (binCount &gt;= TREEIFY_THRESHOLD)\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    // 计数增加1，有可能触发transfer操作(扩容)。\n    addCount(1L, binCount);\n    return null;\n}\n@SuppressWarnings(\"unchecked\")\nstatic final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {\n    return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);\n}\n\n/*\n *但是这边为什么i要等于((long)i &lt;&lt; ASHIFT) + ABASE呢,计算偏移量\n *ASHIFT是指tab[i]中第i个元素在相对于数组第一个元素的偏移量，而ABASE就算第一数组的内存素的偏移地址\n *所以呢，((long)i &lt;&lt; ASHIFT) + ABASE就算i最后的地址\n * 那么compareAndSwapObject的作用就算tab[i]和c比较，如果相等就tab[i]=v否则tab[i]=c;\n*/\nstatic final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,\n                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) {\n    return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);\n}\n\nstatic final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) {\n    U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);\n}<br></code></pre><p><font>我们还是继续一步步看代码，看inputVal的注释a，这个方法helpTransfer，如果线程进入到这边说明已经有其他线程正在做扩容操作，这个是一个辅助方法</font><br></p><pre><code class=\"lang-java\">/**\n * Helps transfer if a resize is in progress.\n */\nfinal Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) {\n    Node&lt;K,V&gt;[] nextTab; int sc;\n    if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;\n        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) {\n        int rs = resizeStamp(tab.length);\n        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;\n               (sc = sizeCtl) &lt; 0) {\n            //下面几种情况和addCount的方法一样，请参考addCount的备注\n            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)\n                break;\n            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {\n                transfer(tab, nextTab);\n                break;\n            }\n        }\n        return nextTab;\n    }\n    return table;\n}<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: large;\">当我们的putVal执行到addCount的时候</span><br></p><pre><code class=\"lang-java\">private final void addCount(long x, int check) {\n    CounterCell[] as; long b, s;\n\n    //U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x) 每次竟来都baseCount都加1因为x=1\n    if ((as = counterCells) != null ||\n        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {//1\n        CounterCell a; long v; int m;\n        boolean uncontended = true;\n        if (as == null || (m = as.length - 1) &lt; 0 ||\n            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||\n            !(uncontended =\n              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {\n            //多线程CAS发生失败的时候执行\n            fullAddCount(x, uncontended);//2\n            return;\n        }\n        if (check &lt;= 1)\n            return;\n        s = sumCount();\n    }\n    if (check &gt;= 0) {\n        Node&lt;K,V&gt;[] tab, nt; int n, sc;\n        //当条件满足开始扩容\n        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;\n               (n = tab.length) &lt; MAXIMUM_CAPACITY) {\n            int rs = resizeStamp(n);\n            if (sc &lt; 0) {//如果小于0说明已经有线程在进行扩容操作了\n                //一下的情况说明已经有在扩容或者多线程进行了扩容，其他线程直接break不要进入扩容操作\n                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n                    transferIndex &lt;= 0)\n                    break;\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))//如果相等说明扩容已经完成，可以继续扩容\n                    transfer(tab, nt);\n            }\n            //这个时候sizeCtl已经等于(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2等于一个大的负数，这边加上2很巧妙,因为transfer后面对sizeCtl--操作的时候，最多只能减两次就结束\n            else if (U.compareAndSwapInt(this, SIZECTL, sc,\n                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))\n                transfer(tab, null);\n            s = sumCount();\n        }\n    }\n}<br></code></pre><p style=\"text-align: justify;\"><font>看上面注释1，每次都会对baseCount 加1，如果并发竞争太大，那么可能导致U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x) 失败，那么为了提高高并发的时候baseCount可见性失败的问题，又避免一直重试，这样性能会有很大的影响，那么在jdk8的时候是有引入一个类Striped64，其中LongAdder和DoubleAdder就是对这个类的实现。这两个方法都是为解决高并发场景而生的，是AtomicLong的加强版，AtomicLong在高并发场景性能会比LongAdder差。但是LongAdder的空间复杂度会高点。</font></p><p style=\"text-align: justify;\"><font>我们每次进来都对baseCount进行加1当达到一定的容量时，就需要对table进行扩容。扩容方法就是transfer，这个方法稍微复杂一点，大部分的代码我都做了注释</font></p><pre><code class=\"lang-java\">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {\n    int n = tab.length, stride;\n    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)\n        stride = MIN_TRANSFER_STRIDE; // subdivide range\n    if (nextTab == null) {            // initiating\n        try {\n            @SuppressWarnings(\"unchecked\")\n            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];\n            nextTab = nt;\n        } catch (Throwable ex) {      // try to cope with OOME\n            sizeCtl = Integer.MAX_VALUE;\n            return;\n        }\n        nextTable = nextTab;\n        transferIndex = n;\n    }\n    int nextn = nextTab.length;\n    //构建一个连节点的指针，用于标识位\n    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);\n    boolean advance = true;\n    //循环的关键变量，判断是否已经扩容完成，完成就return，退出循环\n    boolean finishing = false; // to ensure sweep before committing nextTab\n    for (int i = 0, bound = 0;;) {\n        Node&lt;K,V&gt; f; int fh;\n        //循环的关键i，i--操作保证了倒序遍历数组\n        while (advance) {\n            int nextIndex, nextBound;\n            if (--i &gt;= bound || finishing)\n                advance = false;\n            else if ((nextIndex = transferIndex) &lt;= 0) {//nextIndex=transferIndex=n=tab.length(默认16)\n                i = -1;\n                advance = false;\n            }\n            else if (U.compareAndSwapInt\n                     (this, TRANSFERINDEX, nextIndex,\n                      nextBound = (nextIndex &gt; stride ?\n                                   nextIndex - stride : 0))) {\n                bound = nextBound;\n                i = nextIndex - 1;\n                advance = false;\n            }\n        }\n        //i&lt;0说明已经遍历完旧的数组tab；i&gt;=n什么时候有可能呢？在下面看到i=n,所以目前i最大应该是n吧。\n        //i+n&gt;=nextn,nextn=nextTab.length，所以如果满足i+n&gt;=nextn说明已经扩容完成\n        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {\n            int sc;\n            if (finishing) {// a\n                nextTable = null;\n                table = nextTab;\n                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);\n                return;\n            }\n            //利用CAS方法更新这个扩容阈值，在这里面sizectl值减一，说明新加入一个线程参与到扩容操作,参考sizeCtl的注释\n            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                //如果有多个线程进行扩容，那么这个值在第二个线程以后就不会相等，因为sizeCtl已经被减1了，所以后面的线程就只能直接返回,始终保证只有一个线程执行了 a(上面注释a)\n                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)\n                    return;\n                finishing = advance = true;//finishing和advance保证线程已经扩容完成了可以退出循环\n                i = n; // recheck before commit\n            }\n        }\n        else if ((f = tabAt(tab, i)) == null)//如果tab[i]为null，那么就把fwd插入到tab[i]，表明这个节点已经处理过了\n            advance = casTabAt(tab, i, null, fwd);\n        else if ((fh = f.hash) == MOVED)//那么如果f.hash=-1的话说明该节点为ForwardingNode，说明该节点已经处理过了\n            advance = true; // already processed\n        else {\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    Node&lt;K,V&gt; ln, hn;\n                    if (fh &gt;= 0) {\n                        int runBit = fh &amp; n;\n                        Node&lt;K,V&gt; lastRun = f;\n                        //这边还对链表进行遍历,这边的的算法和hashmap的算法又不一样了，这班是有点对半拆分的感觉\n                        //把链表分表拆分为，hash&amp;n等于0和不等于0的，然后分别放在新表的i和i+n位置\n                        //次方法同hashmap的resize\n                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {\n                            int b = p.hash &amp; n;\n                            if (b != runBit) {\n                                runBit = b;\n                                lastRun = p;\n                            }\n                        }\n                        if (runBit == 0) {\n                            ln = lastRun;\n                            hn = null;\n                        }\n                        else {\n                            hn = lastRun;\n                            ln = null;\n                        }\n                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {\n                            int ph = p.hash; K pk = p.key; V pv = p.val;\n                            if ((ph &amp; n) == 0)\n                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);\n                            else\n                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);\n                        }\n                        setTabAt(nextTab, i, ln);\n                        setTabAt(nextTab, i + n, hn);\n                        //把已经替换的节点的旧tab的i的位置用fwd替换，fwd包含nextTab\n                        setTabAt(tab, i, fwd);\n                        advance = true;\n                    }//下面红黑树基本和链表差不多\n                    else if (f instanceof TreeBin) {\n                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;\n                        TreeNode&lt;K,V&gt; lo = null, loTail = null;\n                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;\n                        int lc = 0, hc = 0;\n                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {\n                            int h = e.hash;\n                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;\n                                (h, e.key, e.val, null, null);\n                            if ((h &amp; n) == 0) {\n                                if ((p.prev = loTail) == null)\n                                    lo = p;\n                                else\n                                    loTail.next = p;\n                                loTail = p;\n                                ++lc;\n                            }\n                            else {\n                                if ((p.prev = hiTail) == null)\n                                    hi = p;\n                                else\n                                    hiTail.next = p;\n                                hiTail = p;\n                                ++hc;\n                            }\n                        }\n                        //判断扩容后是否还需要红黑树结构\n                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :\n                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;\n                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :\n                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;\n                        setTabAt(nextTab, i, ln);\n                        setTabAt(nextTab, i + n, hn);\n                        setTabAt(tab, i, fwd);\n                        advance = true;\n                    }\n                }\n            }\n        }\n    }\n}<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: large;\">值得细细品味的是，transfer的for循环是倒叙的，说明对table的遍历是从table.length-1开始到0的。我觉得这段代码写得太牛逼了，特别是</span><br></p><pre><code class=\"lang-java\">//利用CAS方法更新这个扩容阈值，在这里面sizectl值减一，说明新加入一个线程参与到扩容操作,参考sizeCtl的注释\nif (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n    //如果有多个线程进行扩容，那么这个值在第二个线程以后就不会相等，因为sizeCtl已经被减1了，所以后面的线程就只能直接返回,始终保证只有一个线程执行了 a(上面注释a)\n    if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)\n        return;\n    finishing = advance = true;//finishing和advance保证线程已经扩容完成了可以退出循环\n    i = n; // recheck before commit\n}<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: large;\">注意：如果链表结构中元素超过TREEIFY_THRESHOLD阈值，默认为8个，则把链表转化为红黑树，提高遍历查询效率.接下来我们看看如何构造树结构，代码如下：</span><br></p><pre><code class=\"lang-java\">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) {\n    Node&lt;K,V&gt; b; int n, sc;\n    if (tab != null) {\n        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)\n            tryPresize(n &lt;&lt; 1);\n        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) {\n            synchronized (b) {\n                if (tabAt(tab, index) == b) {\n                    TreeNode&lt;K,V&gt; hd = null, tl = null;\n                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) {\n                        TreeNode&lt;K,V&gt; p =\n                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,\n                                              null, null);\n                        if ((p.prev = tl) == null)\n                            hd = p;\n                        else\n                            tl.next = p;\n                        tl = p;\n                    }\n                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));\n                }\n            }\n        }\n    }\n}<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: large;\">可以看出，生成树节点的代码块是同步的，进入同步代码块之后，再次验证table中index位置元素是否被修改过。&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: large;\">1、根据table中index位置Node链表，重新生成一个hd为头结点的TreeNode链表。&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: large;\">2、根据hd头结点，生成TreeBin树结构，并把树结构的root节点写到table的index位置的内存中，具体实现如下：</span></p><pre><code class=\"lang-java\">TreeBin(TreeNode&lt;K,V&gt; b) {\n    super(TREEBIN, null, null, null);\n    this.first = b;\n    TreeNode&lt;K,V&gt; r = null;\n    for (TreeNode&lt;K,V&gt; x = b, next; x != null; x = next) {\n        next = (TreeNode&lt;K,V&gt;)x.next;\n        x.left = x.right = null;\n        if (r == null) {\n            x.parent = null;\n            x.red = false;\n            r = x;\n        }\n        else {\n            K k = x.key;\n            int h = x.hash;\n            Class&lt;?&gt; kc = null;\n            for (TreeNode&lt;K,V&gt; p = r;;) {\n                int dir, ph;\n                K pk = p.key;\n                if ((ph = p.hash) &gt; h)\n                    dir = -1;\n                else if (ph &lt; h)\n                    dir = 1;\n                else if ((kc == null &amp;&amp;\n                          (kc = comparableClassFor(k)) == null) ||\n                         (dir = compareComparables(kc, k, pk)) == 0)\n                    dir = tieBreakOrder(k, pk);\n                    TreeNode&lt;K,V&gt; xp = p;\n                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {\n                    x.parent = xp;\n                    if (dir &lt;= 0)\n                        xp.left = x;\n                    else\n                        xp.right = x;\n                    r = balanceInsertion(r, x);\n                    break;\n                }\n            }\n        }\n    }\n    this.root = r;\n    assert checkInvariants(root);\n}<br></code></pre><p><br></p><h2><b style=\"color: rgb(227, 55, 55);\">七、</b><span style=\"font-size: 22px;\"><b style=\"color: rgb(227, 55, 55);\">get()方法</b></span></h2><pre><code class=\"lang-java\">public V get(Object key) {\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;\n    int h = spread(key.hashCode());\n    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;\n        (e = tabAt(tab, (n - 1) &amp; h)) != null) {\n        if ((eh = e.hash) == h) {            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))\n                return e.val;\n        }\n        else if (eh &lt; 0)//如果eh=-1就说明e节点为ForWordingNode,这说明什么，说明这个节点已经不存在了，被另一个线程正则扩容\n        //所以要查找key对应的值的话，直接到新newtable找\n            return (p = e.find(h, key)) != null ? p.val : null;\n        while ((e = e.next) != null) {\n            if (e.hash == h &amp;&amp;\n                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}<br></code></pre><p><span style=\"color: rgb(79, 79, 79); font-size: large;\">这个get请求，我们需要cas来保证变量的原子性。如果tab[i]正被锁住，那么CAS就会失败，失败之后就会不断的重试。这也保证了get在高并发情况下不会出错。&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: large;\">我们来分析下到底有多少种情况会导致get在并发的情况下可能取不到值。1、一个线程在get的时候，另一个线程在对同一个key的node进行remove操作；2、一个线程在get的时候，另一个线程正则重排table。可能导致旧table取不到值。&nbsp;</span></p><p><span style=\"color: rgb(79, 79, 79); font-size: large;\">那么本质是，我在get的时候，有其他线程在对同一桶的链表或树进行修改。那么get是怎么保证同步性的呢？我们看到e = tabAt(tab, (n - 1) &amp; h)) != null，在看下tablAt到底是干嘛的：</span></p><pre><code class=\"lang-java\">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {\n    return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);\n}<br></code></pre><p style=\"text-align: justify;\"><font>它是对tab[i]进行原子性的读取，因为我们知道putVal等对table的桶操作是有加锁的，那么一般情况下我们对桶的读也是要加锁的，但是我们这边为什么不需要加锁呢？因为我们用了Unsafe的getObjectVolatile，因为table是volatile类型，所以对tab[i]的原子请求也是可见的。因为如果同步正确的情况下，根据happens-before原则，对volatile域的写入操作happens-before于每一个后续对同一域的读操作。所以不管其他线程对table链表或树的修改，都对get读取可见。</font></p><h2><br></h2><h2>参考</h2><p style=\"text-align: justify;\"><a href=\"http://www.jianshu.com/p/c0642afe03e0\" target=\"_blank\">深入浅出ConcurrentHashMap（1.8） 作者 占小狼</a></p><p style=\"text-align: justify;\"><a href=\"http://www.cnblogs.com/huaizuo/archive/2016/04/20/5413069.html\" target=\"_blank\">探索jdk8之ConcurrentHashMap 的实现机制 作者 淮左</a></p><p style=\"text-align: justify;\"><a href=\"http://www.cnblogs.com/everSeeker/p/5601861.html\" target=\"_blank\">Java并发编程总结4——ConcurrentHashMap在jdk1.8中的改进 作者 everSeeker</a></p><p><br></p><p>原文地址：<a href=\"https://blog.csdn.net/fjse51/article/details/55260493\" target=\"_blank\">https://blog.csdn.net/fjse51/article/details/55260493</a></p>', '2018-06-23 16:39:44', '/articles/10028', '0', '0', 'publish', '一、并发环境下为什么使用ConcurrentHashMap1. HashMap在高并发的环境下，<s', 'Java,ConcurrentHashMap,HashMap,多线程', 'ConcurrentHashMap的实现原理', '2018-10-05 04:19:50', '20', '0', '10008', '1'), ('10030', '0', '0', '<p style=\"text-align: justify;\">数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的<font color=\"red\">并发</font>操作中可能会出现脏读，不可重复读，幻读。下面通过事例一一阐述它们的概念与联系。</p><hr><p style=\"text-align: justify;\"><b>一、Read uncommitted</b></p><p style=\"text-align: justify;\">读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。</p><p style=\"text-align: justify;\">事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。</p><p style=\"text-align: justify;\">分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是<font color=\"red\">脏读</font>。</p><hr><p style=\"text-align: justify;\">那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。</p><hr><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>二、Read committed</b></p><p style=\"text-align: justify;\">读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。</p><p style=\"text-align: justify;\">事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（<font color=\"red\">第二次检测金额当然要等待妻子转出金额事务提交完</font>）。程序员就会很郁闷，明明卡里是有钱的…</p><p style=\"text-align: justify;\">分析：<span style=\"color: rgb(65, 140, 175);\">这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题</span>。但在这个事例中，出现了<font color=\"red\">一个事务范围内两个相同的查询却返回了不同数据</font>，这就是<font color=\"red\">不可重复读</font>。</p><hr><p style=\"text-align: justify;\">那怎么解决可能的不可重复读问题？Repeatable read ！</p><hr><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b style=\"color: rgb(32, 147, 97);\">三、Repeatable read</b></p><p style=\"text-align: justify;\">重复读，就是在开始读取数据（事务开启）时，不再允许修改操作(在一个事务中，多次读数据都不变)</p><p style=\"text-align: justify;\">事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（<font color=\"red\">事务开启，不允许其他事务的UPDATE修改操作</font>），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p><p style=\"text-align: justify;\">分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，<font color=\"red\">不可重复读对应的是修改，即UPDATE操作</font>。但是可能还会有<font color=\"red\">幻读</font>问题。因为<font color=\"red\">幻读问题对应的是插入INSERT操作，而不是UPDATE操作</font>。</p><hr><p style=\"text-align: justify;\">什么时候会出现幻读？</p><p style=\"text-align: justify;\">事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即<font color=\"red\">新增INSERT</font>了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p><hr><p style=\"text-align: justify;\">那怎么解决幻读问题？Serializable！</p><hr><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>四、Serializable 序列化</b></p><p style=\"text-align: justify;\">Serializable 是最高的事务隔离级别，在该级别下，事务<font color=\"red\">串行化顺序执行</font>，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p><hr><p style=\"text-align: justify;\"><font color=\"red\">值得一提的是：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。Mysql的默认隔离级别是Repeatable read。</font></p><p><br></p><p><br></p><p>原文地址：<a href=\"https://blog.csdn.net/qq_33290787/article/details/51924963\" target=\"_blank\">https://blog.csdn.net/qq_33290787/article/details/51924963</a></p><p><br></p><p>最后附一张图</p><div class=\"simditor-table\"><img alt=\"796066-20170402181558649-581777223.jpg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/23/saysky/1529761874056\" width=\"688\" height=\"228\"><br></div>', '2018-06-23 21:52:03', '/articles/10030', '0', '0', 'publish', '数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发</fon', '数据库,事务,事务隔离级别', '理解事务的4种隔离级别', '2018-07-04 19:39:49', '10', '0', '10004', '1'), ('10031', '0', '1', '<ul><li><p style=\"margin-left: auto;\">get参数通过url传递，post放在request body中。</p></li><li><p style=\"margin-left: auto;\">get请求在url中传递的参数是有长度限制的，而post没有。</p></li><li><p style=\"margin-left: auto;\">get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。</p></li><li><ul><li><p style=\"margin-left: auto;\">get请求只能进行url编码，而post支持多种编码方式</p></li><li><p style=\"margin-left: auto;\">get请求会浏览器主动cache，而post不能。</p></li><li><p style=\"margin-left: auto;\">get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。<br><br></p></li></ul></li><li>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</li></ul><ul><li>GET产生一个TCP数据包；POST产生两个TCP数据包。</li></ul><p style=\"margin-left: auto;\">长的说：</p><p style=\"margin-left: auto;\">对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p style=\"margin-left: auto;\">而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br><br>（据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。）</p><p><br></p><p><br></p><p>GET和POST的区别：</p><table><colgroup><col width=\"33.29355608591885%\"><col width=\"33.29355608591885%\"><col width=\"33.53221957040573%\"></colgroup><thead><tr><th><strong>&nbsp;</strong></th><th><span style=\"font-size: 12px;\"><strong>GET</strong></span></th><th><span style=\"font-size: 12px;\"><strong>POST</strong></span></th></tr></thead><tbody><tr><td><span style=\"font-size: 12px;\"><strong>点击返回/刷新按钮</strong></span></td><td><span style=\"font-size: 12px;\">没有影响</span></td><td><span style=\"font-size: 12px;\">数据会重新发送（浏览器将会提示用户“数据被重新提交”）</span></td></tr><tr><td><span style=\"font-size: 12px;\"><strong>添加书签</strong></span></td><td><span style=\"font-size: 12px;\">可以</span></td><td><span style=\"font-size: 12px;\">不可以</span></td></tr><tr><td><span style=\"font-size: 12px;\"><strong>缓存</strong></span></td><td><span style=\"font-size: 12px;\">可以</span></td><td><span style=\"font-size: 12px;\">不可以</span></td></tr><tr><td><span style=\"font-size: 12px;\"><strong>编码类型(Encoding type)</strong></span></td><td><span style=\"font-size: 12px;\">application/x-www-form-urlencoded</span></td><td><span style=\"font-size: 12px;\">application/x-www-form-urlencoded or multipart/form-data. 请为二进制数据使用multipart编码</span></td></tr><tr><td><span style=\"font-size: 12px;\"><strong>历史记录</strong></span></td><td><span style=\"font-size: 12px;\">有</span></td><td><span style=\"font-size: 12px;\">没有</span></td></tr><tr><td><span style=\"font-size: 12px;\"><strong>长度限制</strong></span></td><td><span style=\"font-size: 12px;\">有</span></td><td><span style=\"font-size: 12px;\">没有</span></td></tr><tr><td><span style=\"font-size: 12px;\"><strong>数据类型限制</strong></span></td><td><span style=\"font-size: 12px;\">只允许ASCII字符类型</span></td><td><span style=\"font-size: 12px;\">没有限制。允许二进制数据</span></td></tr><tr><td><span style=\"font-size: 12px;\"><strong>安全性</strong></span></td><td><span style=\"font-size: 12px;\">查询字符串会显示在地址栏的URL中，不安全，请不要使用GET请求提交敏感数据</span></td><td><span style=\"font-size: 12px;\">因为数据不会显示在地址栏中，也不会缓存下来或保存在浏览记录中，所以看POST求情比GET请求安全，但也不是最安全的方式。如需要传送敏感数据，请使用加密方式传输</span></td></tr><tr><td><span style=\"font-size: 12px;\"><strong>可见性</strong></span></td><td><span style=\"font-size: 12px;\">查询字符串显示在地址栏的URL中，可见</span></td><td><span style=\"font-size: 12px;\">查询字符串不会显示在地址栏中，不可见</span></td></tr></tbody></table><p><span style=\"font-size: 12px;\"><br></span></p><p>其他HTTP请求方式</p><table><colgroup><col width=\"49.88066825775656%\"><col width=\"50.11933174224343%\"></colgroup><thead><tr><th><span style=\"font-size: 12px;\"><strong>方式</strong></span></th><th><span style=\"font-size: 12px;\"><strong>描述</strong></span></th></tr></thead><tbody><tr><td><span style=\"font-size: 12px;\">HEAD</span></td><td><span style=\"font-size: 12px;\">与GET请求类似，不同在于服务器只返回HTTP头部信息，没有页面内容</span></td></tr><tr><td><span style=\"font-size: 12px;\">PUT</span></td><td><span style=\"font-size: 12px;\">上传指定URL的描述</span></td></tr><tr><td><span style=\"font-size: 12px;\">DELETE</span></td><td><span style=\"font-size: 12px;\">删除指定资源</span></td></tr><tr><td><span style=\"font-size: 12px;\">OPTIONS</span></td><td><span style=\"font-size: 12px;\">返回服务器支持的HTTP方法</span></td></tr><tr><td><span style=\"font-size: 12px;\">CONNECT</span></td><td><span style=\"font-size: 12px;\">转换为透明TCP/IP隧道的连接请求</span></td></tr></tbody></table><p><span style=\"font-size: 12px;\">&nbsp;</span></p>', '2018-06-24 08:10:42', '/articles/10031', '0', '0', 'publish', 'get参数通过url传递，post放在request body中。get请求在url中传递的参数是有长度限制的，而post没有。<', '计算机网络,GET,POST', 'GET 和 POST 的区别？', '2018-11-26 09:30:56', '25', '0', '10009', '1'), ('10032', '0', '0', '<h2><b><span style=\"color: rgb(227, 55, 55);\">三次握手是什么？</span></b></h2><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。这就是面试中经常会被问到的<strong>TCP三次握手</strong>。只是了解TCP三次握手的概念，对你获得一份工作是没有任何帮助的，你需要去了解TCP三次握手中的一些细节。先来看图说话。</p><p><img alt=\"tcp4.jpg\" src=\"http://cdn.codergroup.cn/uploads/2018/6/24/saysky/1529804889649\" width=\"600\" height=\"669.6\"><br></p><p>多么清晰的一张图，当然了，也不是我画的，我也只是引用过来说明问题了。</p><ol><li>第一次握手：建立连接。客户端发送连接请求报文段，将<code>SYN</code>位置为1，<code>Sequence Number</code>为x；然后，客户端进入<code>SYN_SEND</code>状态，等待服务器的确认；</li><li>第二次握手：服务器收到<code>SYN</code>报文段。服务器收到客户端的<code>SYN</code>报文段，需要对这个<code>SYN</code>报文段进行确认，设置<code>Acknowledgment Number</code>为x+1(<code>Sequence Number</code>+1)；同时，自己自己还要发送<code>SYN</code>请求信息，将<code>SYN</code>位置为1，<code>Sequence Number</code>为y；服务器端将上述所有信息放到一个报文段（即<code>SYN+ACK</code>报文段）中，一并发送给客户端，此时服务器进入<code>SYN_RECV</code>状态；</li><li>第三次握手：客户端收到服务器的<code>SYN+ACK</code>报文段。然后将<code>Acknowledgment Number</code>设置为y+1，向服务器发送<code>ACK</code>报文段，这个报文段发送完毕以后，客户端和服务器端都进入<code>ESTABLISHED</code>状态，完成TCP三次握手。</li></ol><p>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</p><h2><b><span style=\"color: rgb(227, 55, 55);\"><br></span></b></h2><h2><b><span style=\"color: rgb(227, 55, 55);\">那四次分手呢？</span></b></h2><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p><ol><li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置<code>Sequence Number</code>和<code>Acknowledgment Number</code>，向主机2发送一个<code>FIN</code>报文段；此时，主机1进入<code>FIN_WAIT_1</code>状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次分手：主机2收到了主机1发送的<code>FIN</code>报文段，向主机1回一个<code>ACK</code>报文段，<code>Acknowledgment Number</code>为<code>Sequence Number</code>加1；主机1进入<code>FIN_WAIT_2</code>状态；主机2告诉主机1，我“同意”你的关闭请求；</li><li>第三次分手：主机2向主机1发送<code>FIN</code>报文段，请求关闭连接，同时主机2进入<code>LAST_ACK</code>状态；</li><li>第四次分手：主机1收到主机2发送的<code>FIN</code>报文段，向主机2发送<code>ACK</code>报文段，然后主机1进入<code>TIME_WAIT</code>状态；主机2收到主机1的<code>ACK</code>报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li></ol><p>至此，TCP的四次分手就这么愉快的完成了。当你看到这里，你的脑子里会有很多的疑问，很多的不懂，感觉很凌乱；没事，我们继续总结。</p><h2><b><span style=\"color: rgb(227, 55, 55);\"><br></span></b></h2><h2><b><span style=\"color: rgb(227, 55, 55);\">为什么要三次握手，而不是两次？</span></b></h2><p>既然总结了TCP的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那TCP为什么非要进行三次连接呢？在谢希仁的《<a href=\"https://liuyanzhao.com/tag/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c/\" target=\"_blank\">计算机网络</a>》中是这样说的：</p><blockquote><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p></blockquote><p>在书中同时举了一个例子，如下：</p><blockquote><p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p></blockquote><p><span style=\"color: rgb(227, 55, 55);\">这就很明白了，防止了服务器端的一直等待而浪费资源。</span></p><h2><b><span style=\"color: rgb(227, 55, 55);\"><br></span></b></h2><h2><b><span style=\"color: rgb(227, 55, 55);\">为什么要四次分手？</span></b></h2><p>那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出<code>FIN</code>报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回<code>ACK</code>报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了<code>FIN</code>报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p><ul><li><code>FIN_WAIT_1</code>: 这个状态要好好解释一下，其实<code>FIN_WAIT_1</code>和<code>FIN_WAIT_2</code>状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：<code>FIN_WAIT_1</code>状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了<code>FIN</code>报文，此时该SOCKET即进入到<code>FIN_WAIT_1</code>状态。而当对方回应ACK报文后，则进入到<code>FIN_WAIT_2</code>状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以<code>FIN_WAIT_1</code>状态一般是比较难见到的，而<code>FIN_WAIT_2</code>状态还有时常常可以用netstat看到。（主动方）</li><li><code>FIN_WAIT_2</code>：上面已经详细解释了这种状态，实际上<code>FIN_WAIT_2</code>状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</li><li><code>CLOSE_WAIT</code>：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送<code>FIN</code>报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到<code>CLOSE_WAIT</code>状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送<code>FIN</code>报文给对方，也即关闭连接。所以你在<code>CLOSE_WAIT</code>状态下，需要完成的事情是等待你去关闭连接。（被动方）</li><li><code>LAST_ACK</code>: 这个状态还是比较容易好理解的，它是被动关闭一方在发送<code>FIN</code>报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</li><li><code>TIME_WAIT</code>: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到<code>TIME_WAIT</code>状态，而无须经过<code>FIN_WAIT_2</code>状态。（主动方）</li><li><code>CLOSED</code>: 表示连接中断。</li></ul>', '2018-06-24 09:50:48', '/articles/10032', '0', '0', 'publish', '三次握手是什么？TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手', '计算机网络,三次握手,四次挥手,TCP', '三次握手和四次挥手', '2018-09-11 00:51:28', '29', '0', '10009', '1'), ('10033', '0', '2', '<p style=\"text-align: justify;\">在JDK的Collection中我们时常会看到类似于这样的话：</p><p style=\"text-align: justify;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;例如，ArrayList:</p><blockquote><p style=\"text-align: justify;\">注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。</p></blockquote><p style=\"text-align: justify;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;HashMap中：</p><blockquote><p style=\"text-align: justify;\">注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p></blockquote><p style=\"text-align: justify;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;在这两段话中反复地提到”快速失败”。那么何为”快速失败”机制呢？</p><p style=\"text-align: justify;\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color: rgb(227, 55, 55);\">&nbsp;“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制</span>。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（<span style=\"color: rgb(227, 55, 55);\">是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制</span>。</p><h1><span style=\"color: rgb(255, 0, 0);\">一、fail-fast示例</span></h1><pre><code class=\"lang-java\">public class FailFastTest {\n&nbsp; &nbsp; private static List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; /**\n&nbsp; &nbsp; &nbsp;* @desc:线程one迭代list\n&nbsp; &nbsp; &nbsp;* @Project:test\n&nbsp; &nbsp; &nbsp;* @file:FailFastTest.java\n&nbsp; &nbsp; &nbsp;* @Authro:chenssy\n&nbsp; &nbsp; &nbsp;* @data:2014年7月26日\n&nbsp; &nbsp; &nbsp;*/\n&nbsp; &nbsp; private static class threadOne extends Thread{\n&nbsp; &nbsp; &nbsp; &nbsp; public void run() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Iterator&lt;Integer&gt; iterator = list.iterator();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while(iterator.hasNext()){\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int i = iterator.next();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"ThreadOne 遍历:\" + i);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Thread.sleep(10);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (InterruptedException e) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.printStackTrace();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; /**\n&nbsp; &nbsp; &nbsp;* @desc:当i == 3时，修改list\n&nbsp; &nbsp; &nbsp;* @Project:test\n&nbsp; &nbsp; &nbsp;* @file:FailFastTest.java\n&nbsp; &nbsp; &nbsp;* @Authro:chenssy\n&nbsp; &nbsp; &nbsp;* @data:2014年7月26日\n&nbsp; &nbsp; &nbsp;*/\n&nbsp; &nbsp; private static class threadTwo extends Thread{\n&nbsp; &nbsp; &nbsp; &nbsp; public void run(){\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int i = 0 ;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while(i &lt; 6){\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"ThreadTwo run：\" + i);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(i == 3){\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list.remove(i);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; public static void main(String[] args) {\n&nbsp; &nbsp; &nbsp; &nbsp; for(int i = 0 ; i &lt; 10;i++){\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list.add(i);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; new threadOne().start();\n&nbsp; &nbsp; &nbsp; &nbsp; new threadTwo().start();\n&nbsp; &nbsp; }\n}<br></code></pre><p>运行结果</p><p><img alt=\"QQ20180624-204715@2x.png\" src=\"http://cdn.codergroup.cn/uploads/2018/6/24/saysky/1529844464207\" width=\"2126\" height=\"672\"><br></p><p><br></p><p><br></p><h1><span style=\"font-size: 24px; color: rgb(255, 0, 0);\">二、fail-fast产生原因</span></h1><p style=\"text-align: justify;\">&nbsp;通过上面的示例和讲解，我初步知道fail-fast产生的原因就在于<span style=\"color: rgb(227, 55, 55);\">程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 ConcurrentModificationException 异常信息，从而产生 fail-fast。</span><span style=\"color: rgb(32, 147, 97);\">(注意是结构上，即添加或减少才会抛出异常，修改某个元素的值不会)</span></p><p style=\"text-align: justify;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;要了解fail-fast机制，我们首先要对ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出ConcurrentModificationException异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。下面我将以ArrayList为例进一步分析fail-fast产生的原因。</p><p style=\"text-align: justify;\">从前面我们知道fail-fast是在操作迭代器时产生的。现在我们来看看ArrayList中迭代器的源代码：</p><pre><code class=\"lang-java\">private class Itr implements Iterator&lt;E&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; int cursor;\n&nbsp; &nbsp; &nbsp; &nbsp; int lastRet = -1;\n&nbsp; &nbsp; &nbsp; &nbsp; int expectedModCount = ArrayList.this.modCount;\n\n&nbsp; &nbsp; &nbsp; &nbsp; public boolean hasNext() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return (this.cursor != ArrayList.this.size);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; public E next() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkForComodification();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /** 省略此处代码 */\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; public void remove() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (this.lastRet &lt; 0)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalStateException();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkForComodification();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /** 省略此处代码 */\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; final void checkForComodification() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ArrayList.this.modCount == this.expectedModCount)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ConcurrentModificationException();\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }<br></code></pre><p style=\"text-align: justify;\">&nbsp;从上面的源代码我们可以看出，<span style=\"color: rgb(227, 55, 55);\">迭代器在调用next()、remove()方法时都是调用checkForComodification()方法</span>，<span style=\"color: rgb(227, 55, 55);\">该方法主要就是检测modCount == expectedModCount ? 若不等则抛出ConcurrentModificationException 异常</span>，从而产生fail-fast机制。所以要弄清楚为什么会产生fail-fast机制我们就必须要用弄明白为什么modCount != expectedModCount ，他们的值在什么时候发生改变的。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;expectedModCount 是在Itr中定义的：int expectedModCount = ArrayList.this.modCount;所以他的值是不可能会修改的，所以会变的就是modCount。modCount是在 AbstractList 中定义的，为全局变量：</p><pre><code class=\"lang-java\">protected&nbsp;transient&nbsp;int&nbsp;modCount&nbsp;=&nbsp;0;&nbsp;&nbsp;<br></code></pre><p><span style=\"color: rgb(79, 79, 79);\">那么他什么时候因为什么原因而发生改变呢？请看ArrayList的源码：</span><br></p><pre><code class=\"lang-java\">&nbsp; &nbsp; public boolean add(E paramE) {\n&nbsp; &nbsp; &nbsp; &nbsp; ensureCapacityInternal(this.size + 1);\n&nbsp; &nbsp; &nbsp; &nbsp; /** 省略此处代码 */\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; private void ensureCapacityInternal(int paramInt) {\n&nbsp; &nbsp; &nbsp; &nbsp; if (this.elementData == EMPTY_ELEMENTDATA)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramInt = Math.max(10, paramInt);\n&nbsp; &nbsp; &nbsp; &nbsp; ensureExplicitCapacity(paramInt);\n&nbsp; &nbsp; }\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; private void ensureExplicitCapacity(int paramInt) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.modCount += 1;&nbsp; &nbsp; //修改modCount\n&nbsp; &nbsp; &nbsp; &nbsp; /** 省略此处代码 */\n&nbsp; &nbsp; }\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp;public boolean remove(Object paramObject) {\n&nbsp; &nbsp; &nbsp; &nbsp; int i;\n&nbsp; &nbsp; &nbsp; &nbsp; if (paramObject == null)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; this.size; ++i) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (this.elementData[i] != null)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fastRemove(i);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; else\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; this.size; ++i) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(paramObject.equals(this.elementData[i])))\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fastRemove(i);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; return false;\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; private void fastRemove(int paramInt) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.modCount += 1;&nbsp; &nbsp;//修改modCount\n&nbsp; &nbsp; &nbsp; &nbsp; /** 省略此处代码 */\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; public void clear() {\n&nbsp; &nbsp; &nbsp; &nbsp; this.modCount += 1;&nbsp; &nbsp; //修改modCount\n&nbsp; &nbsp; &nbsp; &nbsp; /** 省略此处代码 */\n&nbsp; &nbsp; }<br></code></pre><p>从上面的源代码我们可以看出，ArrayList中无论add、remove、clear方法只要是涉及了改变ArrayList元素的个数的方法都会导致modCount的改变。所以我们这里可以初步判断由于expectedModCount 得值与modCount的改变不同步，导致两者之间不等从而产生fail-fast机制。知道产生fail-fast产生的根本原因了，我们可以有如下场景：<br></p><p style=\"text-align: justify;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;有两个线程（线程A，线程B），其中线程A负责遍历list、线程B修改list。线程A在遍历list过程的某个时候（此时expectedModCount = modCount=N），线程启动，同时线程B增加一个元素，这是modCount的值发生改变（modCount + 1 = N + 1）。线程A继续遍历执行next方法时，通告checkForComodification方法发现expectedModCount&nbsp; = N&nbsp; ，而modCount = N + 1，两者不等，这时就抛出ConcurrentModificationException 异常，从而产生fail-fast机制。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;所以，直到这里我们已经完全了解了fail-fast产生的根本原因了。知道了原因就好找解决办法了。</p><h1><span style=\"font-size: 24px; color: rgb(255, 0, 0);\"><br></span></h1><h1><span style=\"font-size: 24px; color: rgb(255, 0, 0);\">三、fail-fast解决办法</span></h1><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp;</span>&nbsp;通过前面的实例、源码分析，我想各位已经基本了解了fail-fast的机制，下面我就产生的原因提出解决方案。这里有两种解决方案：</p><p style=\"text-align: justify;\"><span style=\"color: rgb(0, 0, 255);\">&nbsp; &nbsp; 方案一：</span>在遍历过程中所有涉及到改变modCount值得地方全部加上synchronized或者直接使用Collections.synchronizedList，这样就可以解决。但是不推荐，<span style=\"color: rgb(227, 55, 55);\">因为增删造成的同步锁可能会阻塞遍历操作</span>。</p><p style=\"text-align: justify;\"><span style=\"color: rgb(0, 0, 255);\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;方案二：</span>使用CopyOnWriteArrayList来替换ArrayList。推荐使用该方案。</p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp;</span>&nbsp;CopyOnWriteArrayList为何物？ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 该类产生的开销比较大，但是在两种情况下，它非常适合使用。1：在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时。2：当遍历操作的数量大大超过可变操作的数量时。遇到这两种情况使用CopyOnWriteArrayList来替代ArrayList再适合不过了。那么为什么CopyOnWriterArrayList可以替代ArrayList呢？</p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp; &nbsp; &nbsp; </span>&nbsp;&nbsp;第一、CopyOnWriterArrayList的无论是从数据结构、定义都和ArrayList一样。它和ArrayList一样，同样是实现List接口，底层使用数组实现。在方法上也包含add、remove、clear、iterator等方法。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;第二、CopyOnWriterArrayList根本就不会产生ConcurrentModificationException异常，也就是它使用迭代器完全不会产生fail-fast机制。请看：</p><pre><code class=\"lang-java\">private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; /** 省略此处代码 */\n&nbsp; &nbsp; &nbsp; &nbsp; public E next() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(hasNext()))\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NoSuchElementException();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return this.snapshot[(this.cursor++)];\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; /** 省略此处代码 */\n&nbsp; &nbsp; }<br></code></pre><p><span style=\"font-size: medium;\"><span style=\"color: rgb(79, 79, 79);\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><span style=\"color: rgb(79, 79, 79);\">CopyOnWriterArrayList的方法根本就没有像ArrayList中使用checkForComodification方法来判断expectedModCount 与 modCount 是否相等。它为什么会这么做，凭什么可以这么做呢？我们以add方法为例：</span></span><br></p><pre><code class=\"lang-java\">public boolean add(E paramE) {\n&nbsp; &nbsp; &nbsp; &nbsp; ReentrantLock localReentrantLock = this.lock;\n&nbsp; &nbsp; &nbsp; &nbsp; localReentrantLock.lock();\n&nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object[] arrayOfObject1 = getArray();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int i = arrayOfObject1.length;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + 1);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayOfObject2[i] = paramE;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setArray(arrayOfObject2);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int j = 1;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return j;\n&nbsp; &nbsp; &nbsp; &nbsp; } finally {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; localReentrantLock.unlock();\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; final void setArray(Object[] paramArrayOfObject) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.array = paramArrayOfObject;\n&nbsp; &nbsp; }<br></code></pre><p><span style=\"font-size: medium;\"><span style=\"color: rgb(79, 79, 79);\">&nbsp;</span><span style=\"color: rgb(79, 79, 79);\">&nbsp;</span><span style=\"color: rgb(79, 79, 79);\">CopyOnWriterArrayList的add方法与ArrayList的add方法有一个最大的不同点就在于，下面三句代码：</span></span><br></p><pre><code class=\"lang-java\">Object[]&nbsp;arrayOfObject2&nbsp;=&nbsp;Arrays.copyOf(arrayOfObject1,&nbsp;i&nbsp;+&nbsp;1);&nbsp;&nbsp;\narrayOfObject2[i]&nbsp;=&nbsp;paramE;&nbsp;&nbsp;\nsetArray(arrayOfObject2);&nbsp;&nbsp;<br></code></pre><p style=\"text-align: justify;\">&nbsp;就是这三句代码使得CopyOnWriterArrayList不会抛ConcurrentModificationException异常。他们所展现的魅力就在于copy原来的array，再在copy数组上进行add操作，这样做就完全不会影响COWIterator中的array了。</p><p style=\"text-align: justify;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;所以CopyOnWriterArrayList所代表的核心概念就是：任何对array在结构上有所改变的操作（add、remove、clear等），CopyOnWriterArrayList都会copy现有的数据，再在copy的数据上修改，这样就不会影响COWIterator中的数据了，修改完成之后改变原有数据的引用即可。同时这样造成的代价就是产生大量的对象，同时数组的copy也是相当有损耗的。</p><p style=\"text-align: justify;\"></p><p style=\"text-align: justify;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;参考文档：<a href=\"http://www.cnblogs.com/skywang12345/p/3308762.html#a3\" target=\"_blank\" style=\"\">http://www.cnblogs.com/skywang12345/p/3308762.html#a3</a></p><p><br></p><p>&nbsp; &nbsp; &nbsp;我们将&nbsp;</p><pre><code> private static List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></pre><p>&nbsp; &nbsp; &nbsp;改成</p><pre><code>&nbsp; private static List&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;();<br></code></pre><p>&nbsp; &nbsp; 然后进行 add 或者 remove 操作就不会抛出异常了<br></p><p><br></p><p>原文地址：<a href=\"https://blog.csdn.net/chenssy/article/details/38151189\" target=\"_blank\">https://blog.csdn.net/chenssy/article/details/38151189</a></p>', '2018-06-24 20:54:51', '/articles/10033', '0', '0', 'publish', '在JDK的Collection中我们时常会看到类似于这样的话：        例如，ArrayList:<', 'Java,fail-fast,迭代器', 'fail-fast机制', '2018-08-29 15:09:36', '28', '0', '10006', '1');
INSERT INTO `article` VALUES ('10034', '0', '0', '<p>期末复习中：6月24日-7月3日</p>', '2018-06-27 16:13:04', '/articles/10034', '0', '0', 'publish', '期末复习中：6月24日-7月3日', '', '期末复习中，暂停更新', '2018-11-26 09:30:43', '46', '0', '10010', '1'), ('10035', '0', '2', '<p>123123123123123222222222222222222</p>', '2018-07-03 16:40:13', '/articles/10035', '0', '0', 'publish', '123123123123123222222222222222222', '测试,测试1', '标题不短', '2018-10-10 21:25:56', '21', '0', '10011', '23'), ('10036', '0', '0', '<p><span style=\"font-size: 14px;\"><b>MyISAM 和InnoDB 讲解</b></span></p><p style=\"text-align: justify;\">　　InnoDB和MyISAM是许多人在使用MySQL时最常用的两个表类型，这两个表类型各有优劣，视具体应用而定。基本的差别为：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。</p><p style=\"text-align: justify;\">　　以下是一些细节和具体实现的差别：</p><p style=\"text-align: justify;\">　　◆1.InnoDB不支持FULLTEXT类型的索引(备注：MySQL5.6已支持)。</p><p style=\"text-align: justify;\">　　◆2.InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。</p><p style=\"text-align: justify;\">　　◆3.对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</p><p style=\"text-align: justify;\">　　◆4.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</p><p style=\"text-align: justify;\">　　◆5.LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p><p style=\"text-align: justify;\">　　另外，InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”</p><p style=\"text-align: justify;\">　　<span style=\"color: rgb(255, 102, 0);\">两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁。</span>而MyISAM不支持.所以MyISAM往往就容易被人认为只适合在小项目中使用。</p><p style=\"text-align: justify;\">　　作为使用MySQL的用户角度出发，Innodb和MyISAM都是比较喜欢的，如果数据库平台要达到需求：99.9%的稳定性，方便的扩展性和高可用性来说的话，MyISAM绝对是首选。</p><p style=\"text-align: justify;\">　　原因如下：</p><p style=\"text-align: justify;\">　　1、平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。</p><p style=\"text-align: justify;\">　　2、MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。</p><p style=\"text-align: justify;\">　　3、经常隔1，2个月就会发生应用开发人员不小心update一个表where写的范围不对，导致这个表没法正常用了，这个时候MyISAM的优越性就体现出来了，随便从当天拷贝的压缩包取出对应表的文件，随便放到一个数据库目录下，然后dump成sql再导回到主库，并把对应的binlog补上。如果是Innodb，恐怕不可能有这么快速度，别和我说让Innodb定期用导出xxx.sql机制备份，因为最小的一个数据库实例的数据量基本都是几十G大小。</p><p style=\"text-align: justify;\">　　4、从接触的应用逻辑来说，select count(*) 和order by 是最频繁的，大概能占了整个sql总语句的60%以上的操作，而这种操作Innodb其实也是会锁表的，<span style=\"color: rgb(227, 55, 55);\">很多人以为Innodb是行级锁，那个只是where对它主键是有效，非主键的都会锁全表的</span>。</p><p style=\"text-align: justify;\">　　5、还有就是经常有很多应用部门需要我给他们定期某些表的数据，MyISAM的话很方便，只要发给他们对应那表的frm.MYD,MYI的文件，让他们自己在对应版本的数据库启动就行，而Innodb就需要导出xxx.sql了，因为光给别人文件，受字典数据文件的影响，对方是无法使用的。</p><p style=\"text-align: justify;\">　　6、如果和MyISAM比insert写操作的话，Innodb还达不到MyISAM的写性能，如果是针对基于索引的update操作，虽然MyISAM可能会逊色Innodb,但是那么高并发的写，从库能否追的上也是一个问题，还不如通过多实例分库分表架构来解决。</p><p style=\"text-align: justify;\">　　7、如果是用MyISAM的话，merge引擎可以大大加快应用部门的开发速度，他们只要对这个merge表做一些select count(*)操作，非常适合大项目总量约几亿的rows某一类型(如日志，调查统计)的业务表。</p><p style=\"text-align: justify;\">　　当然Innodb也不是绝对不用，用事务的项目就用Innodb的。另外，可能有人会说你MyISAM无法抗太多写操作，但是可以通过架构来弥补。</p><p><br></p><p>原文地址：<a href=\"https://blog.csdn.net/xifeijian/article/details/20316775\" target=\"_blank\">https://blog.csdn.net/xifeijian/article/details/20316775</a></p>', '2018-07-04 11:02:27', '/articles/10036', '0', '0', 'publish', 'MyISAM 和InnoDB 讲解　　InnoDB和MyISAM是许多人在使用MySQL时最常用的两个表类型，这两个表类型各有优劣，', 'MySQL,存储引擎,MyISAM,InnoDB', 'MySQL存储引擎－－MyISAM与InnoDB区别', '2018-11-22 15:16:32', '32', '0', '10004', '1'), ('10037', '0', '0', '<h2><b style=\"color: rgb(227, 55, 55);\">垂直拆分</b></h2><p style=\"margin-left: auto;\">垂直拆分是指数据表<strong>列的拆分</strong>，把一张列比较多的表拆分为多张表<br></p><p style=\"margin-left: auto;\"><img alt=\"191926445106317.png\" src=\"http://cdn.codergroup.cn/uploads/2018/7/4/saysky/1530679164453\" width=\"993\" height=\"292\"><br></p><p style=\"margin-left: auto;\">通常我们按以下原则进行垂直拆分:</p><ol><li>把不常用的字段单独放在一张表;</li><li>把text，blob等大字段拆分出来放在附表中;</li><li>经常组合查询的列放在一张表中;</li></ol><blockquote><p><span style=\"color: rgb(119, 119, 119); font-size: 14px;\">垂直拆分更多时候就应该在数据表设计之初就执行的步骤，然后查询的时候用jion关键起来即可;</span><br></p></blockquote><p style=\"margin-left: auto;\"><br></p><h2><b style=\"color: rgb(227, 55, 55);\">水平拆分</b></h2><p style=\"margin-left: auto;\">水平拆分是指数据表<strong>行的拆分</strong>，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。<br></p><p><img alt=\"1.png\" src=\"http://cdn.codergroup.cn/uploads/2018/7/4/saysky/1530679230878\" width=\"968\" height=\"381\"><br></p><h3>水平拆分的一些技巧</h3><p style=\"margin-left: auto;\"><strong>1. 拆分原则</strong><br>通常情况下，我们使用取模的方式来进行表的拆分;比如一张有400W的用户表<code>users</code>，为提高其查询效率我们把其分成4张表<code>users1，users2，users3，users4</code><br>通过用ID取模的方法把数据分散到四张表内<code>Id%4+1 = [1,2,3,4]</code><br>然后查询,更新,删除也是通过取模的方法来查询</p><pre><code class=\"lang-sql\">$_GET[\'id\'] = 17,\n17%4 + 1 = 2,  \n$tableName = \'users\'.\'2\'\nSelect * from users2 where id = 17;<br></code></pre><p>在insert时还需要一张临时表<code>uid_temp</code>来提供自增的ID,该表的唯一用处就是提供自增的ID;<br></p><pre><code class=\"lang-sql\">insert into uid_temp values(null);<br></code></pre><p style=\"margin-left: auto;\">得到自增的ID后,又通过取模法进行分表插入;<br><strong>注意,进行水平拆分后的表,字段的列和类型和原表应该是相同的,但是要记得去掉auto_increment自增长</strong></p><p style=\"margin-left: auto;\"><strong>另外</strong><br>部分业务逻辑也可以通过地区，年份等字段来进行归档拆分;<br>进行拆分后的表，只能满足部分查询的高效查询需求，这时我们就要在产品策划上，从界面上约束用户查询行为。比如我们是按年来进行归档拆分的,这个时候在页面设计上就约束用户必须要先选择年,然后才能进行查询;<br>在做分析或者统计时，由于是自己人的需求,多点等待其实是没关系的,并且并发很低,这个时候可以用union把所有表都组合成一张视图来进行查询,然后再进行查询;</p><pre><code class=\"lang-sql\">Create view users as select from users1 union select from users2 union.........<br></code></pre><p><br></p><p>原文地址：<a href=\"http://www.cnblogs.com/nixi8/p/4524082.html\" target=\"_blank\">http://www.cnblogs.com/nixi8/p/4524082.html</a></p>', '2018-07-04 12:42:07', '/articles/10037', '0', '0', 'publish', '垂直拆分垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表<p style=\"mar', 'MySQL,数据库', '数据表的垂直拆分和水平拆分', '2019-01-22 01:47:00', '22', '0', '10004', '1'), ('10039', '0', '0', '<p style=\"text-align: justify;\">谈到悲观锁和乐观锁，就要谈到数据库的并发问题，数据库的隔离级别越高并发性就越差</p><p style=\"text-align: justify;\"><b style=\"color: rgb(227, 55, 55);\">并发性</b>：当前系统进行了序列化后，你读取数据库后，别人查询不了，称为并发性不好</p><h2><b style=\"color: rgb(0, 0, 0);\"><span style=\"color: rgb(32, 147, 97);\">简单介绍</span></b><br></h2><p style=\"text-align: justify;\">来自:&nbsp;<a href=\"https://blog.csdn.net/fengxuezhiye/article/details/7380076\" target=\"_blank\">https://blog.csdn.net/fengxuezhiye/article/details/7380076</a></p><p style=\"text-align: justify;\"><b>1、悲观锁</b></p><p style=\"text-align: justify;\">具有排它性（我锁住当前数据后，比人看不到此数据），悲观锁一般是由数据库机制来做到的</p><p style=\"text-align: justify;\">悲观锁的实现：</p><p style=\"text-align: justify;\">通常依赖于数据库机制，在整修过程中将数据库锁定，其它任何用户都不能读取或修改</p><p style=\"text-align: justify;\">悲观锁的适用场景：&nbsp;</p><p style=\"text-align: justify;\">悲观锁一般适合短事物比较多（如某一个数据取出后加1,立即释放）</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>2、乐观锁&nbsp;</b><br>不是锁，是一种冲突检测机制，乐观锁的并发性较好，因为我改的时候，别人可随便修改乐观锁的实现方式：常用的是版本的方式（每个数据表中有一个版本字段version,某一个用户更新数据库后，版本号+1,另一个用户修改后再+1,当用户更新发现数据库当前版本号与读取数据时版本号不一致，等于或小于数据库版本号则更新不了）</p><p style=\"text-align: justify;\">Hibernate使用乐观锁需要在映射文件中配置才可生效</p><p style=\"text-align: justify;\"><br></p><h2><b style=\"color: rgb(32, 147, 97);\">为什么需要锁（并发控制）？</b></h2><p style=\"text-align: justify;\">在多用户环境中，在同一时间可能会有多个用户更新相同的记录，这会产生冲突。这就是著名的并发性问题。</p><p style=\"text-align: justify;\">典型的冲突有：&nbsp;<br>（1）丢失更新：一个事务的更新覆盖了其它事务的更新结果，就是所谓的更新丢失。例如：用户A把值从6改为2，用户B把值从2改为6，则用户A丢失了他的更新。</p><p style=\"text-align: justify;\">（2）脏读：当一个事务读取其它完成一半事务的记录时，就会发生脏读取。例如：用户A,B看到的值都是6，用户B把值改为2，用户A读到的值仍为6。</p><h2><b style=\"color: rgb(32, 147, 97);\">并发控制机制</b></h2><p style=\"text-align: justify;\">悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。&nbsp;<br>乐观锁：假设不会发生并发冲突，<span style=\"color: rgb(227, 55, 55);\">只在提交操作时检查是否违反数据完整性</span>。 <span style=\"color: rgb(200, 167, 50);\">乐观锁不能解决脏读的问题</span>。</p><h2><b style=\"color: rgb(32, 147, 97);\">乐观锁与悲观锁</b></h2><p style=\"text-align: justify;\">悲观锁(Pessimistic Lock)，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<span style=\"color: rgb(227, 55, 55);\">传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</span>。</p><p style=\"text-align: justify;\">乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<span style=\"color: rgb(227, 55, 55);\">乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁</span>。</p><p style=\"text-align: justify;\">两种锁各有优缺点&nbsp;<br>不可认为一种好于另一种，像<span style=\"color: rgb(65, 140, 175);\"><b>乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量</b></span>。但<span style=\"color: rgb(200, 167, 50);\"><b>如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适</b></span>。</p><h2><b style=\"color: rgb(32, 147, 97);\">乐观锁应用</b></h2><ol><li><p style=\"text-align: justify;\">使用自增长的整数表示数据版本号。更新时检查版本号是否一致，比如数据库中数据版本为6，更新提交时version=6+1,使用该version值(=7)与数据库version+1(=7)作比较，如果相等，则可以更新，如果不等则有可能其他程序已更新该记录，所以返回错误。</p></li><li><p style=\"text-align: justify;\">使用时间戳来实现.&nbsp;<br>注：对于以上两种方式,Hibernate自带实现方式：在使用乐观锁的字段前加annotation: @Version, Hibernate在更新时自动校验该字段。</p></li></ol><h2><b style=\"color: rgb(32, 147, 97);\">悲观锁应用</b></h2><p style=\"text-align: justify;\">需要使用数据库的锁机制，比如SQL SERVER 的TABLOCKX（排它表锁） 此选项被选中时，SQL Server 将在整个表上置排它锁直至该命令或事务结束。这将防止其他进程读取或修改表中的数据。</p><p style=\"text-align: justify;\">在实际生产环境里边,如果并发量不大且不允许脏读，可以使用悲观锁解决并发问题；但如果系统的并发非常大的话,悲观锁定会带来非常大的性能问题,所以我们就要选择乐观锁定的方法.&nbsp;<br>悲观锁会造成访问数据库时间较长，并发性不好，特别是长事务。&nbsp;<br>乐观锁在现实中使用得较多，厂商较多采用。</p><h2><b style=\"color: rgb(32, 147, 97);\">一个典型的倚赖数据库的悲观锁调用：</b></h2><pre><code class=\"lang-java\">select * from account where name=”Erica” for update<br></code></pre><p style=\"text-align: justify;\">这条 sql 语句锁定了account 表中所有符合检索条件（ name=”Erica” ）的记录。本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。</p><p style=\"text-align: justify;\">Hibernate 的悲观锁，也是基于数据库的锁机制实现。</p><p style=\"text-align: justify;\">注意，只有在查询开始之前（也就是Hiberate 生成 SQL 之前）设定加锁，才会真正通过数据库的锁机制进行加锁处理，否则，数据已经通过不包含 for update子句的 Select SQL 加载进来，所谓数据库加锁也就无从谈起。</p><p style=\"text-align: justify;\">乐观锁（ Optimistic Locking ）相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p><h2><b style=\"color: rgb(32, 147, 97);\">经典案例分析</b></h2><p style=\"text-align: justify;\">如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户帐户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对几百上千个并发，这样的情况将导致怎样的后果。</p><p style=\"text-align: justify;\">乐观锁机制在一定程度上解决了这个问题。</p><p style=\"text-align: justify;\">乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。</p><p style=\"text-align: justify;\">读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><p style=\"text-align: justify;\">对于上面修改用户帐户信息的例子而言，假设数据库中帐户信息表中有一个version 字段，当前值为 1 ；&nbsp;<br>而当前帐户余额字段（ balance ）为 $100 。</p><p style=\"text-align: justify;\">1 操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除&nbsp;<span style=\"font-size: 19.2px;\">50<span style=\"font-size: 15.936px;\">（</span></span>50（100-$50 ）。</p><p style=\"text-align: justify;\">2 在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除&nbsp;<span style=\"font-size: 19.2px;\">20<span style=\"font-size: 15.936px;\">（</span></span>20（100-$20 ）。</p><p style=\"text-align: justify;\">3 操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</p><p style=\"text-align: justify;\">4 操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ <span style=\"color: rgb(227, 55, 55);\"><b>提交版本必须大于记录当前版本才能执行更新</b></span> “ 的乐观锁策略，因此，操作员 B 的提交被驳回。这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。</p><h2><b style=\"color: rgb(32, 147, 97);\">总结</b></h2><p style=\"text-align: justify;\">从上面的例子可以看出，乐观锁机制避免了长事务中的数据库加锁开销（操作员 A和操作员 B 操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系统整体性能表现。</p><p style=\"text-align: justify;\">需要注意的是，乐观锁机制往往基于系统中的数据存储逻辑，因此也具备一定的局限性，如在上例中，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户余额更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整（如将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途径，而不是将数据库表直接对外公开）。</p><p style=\"text-align: justify;\">谈到悲观锁和乐观锁，就要谈到数据库的并发问题，数据库的隔离级别越高并发性就越差</p><p style=\"text-align: justify;\"><br></p><p><br></p><p>原文地址：<a href=\"https://blog.csdn.net/xlgen157387/article/details/47906553\" target=\"_blank\">https://blog.csdn.net/xlgen157387/article/details/47906553</a></p>', '2018-07-04 17:08:33', '/articles/10039', '0', '0', 'publish', '谈到悲观锁和乐观锁，就要谈到数据库的并发问题，数据库的隔离级别越高并发性就越差并发性', '乐观锁,悲观锁,并发', '并发控制中的乐观锁与悲观锁', '2019-02-26 15:57:57', '23', '0', '10004', '1'), ('10040', '0', '1', '<p><font><font><strong>1、MySQL的复制原理以及流程</strong></font></font></p><p><font>基本原理流程，3个线程以及之间的关联；</font></p><p><font><font><br></font></font></p><p><font></font></p><p><font><font><strong>2、MySQL中myisam与innodb的区别，至少5点</strong></font></font></p><p><font>(1)、问5点不同；</font></p><p><font>(2)、innodb引擎的4大特性</font></p><p><font>(3)、2者selectcount(*)哪个更快，为什么</font></p><p><font><br></font></p><p></p><p><font><font><strong>3、MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义</strong></font></font></p><p><font>(1)、varchar与char的区别</font></p><p><font>(2)、varchar(50)中50的涵义</font></p><p><font>(3)、int（20）中20的涵义</font></p><p><font>(4)、mysql为什么这么设计</font></p><p><font><font><br></font></font></p><p><font><font><strong>4、问了innodb的事务与日志的实现方式</strong></font></font></p><p><font>(1)、有多少种日志；</font></p><p><font>(2)、事物的4种隔离级别</font></p><p><font>(3)、事务是如何通过日志来实现的，说得越深入越好。</font></p><p><font><br></font></p><p><font><font><strong>5、问了MySQL binlog的几种日志录入格式以及区别</strong></font></font></p><p><font>(1)、binlog的日志格式的种类和分别</font></p><p><font>(2)、适用场景；</font></p><p><font>(3)、结合第一个问题，每一种日志格式在复制中的优劣。</font></p><p><font><br></font></p><p><font><font><strong>6、问了下MySQL数据库cpu飙升到500%的话他怎么处理？</strong></font></font></p><p><font>(1)、没有经验的，可以不问；</font></p><p><font>(2)、有经验的，问他们的处理思路。</font></p><p><font><font><strong><br></strong></font></font></p><p><font><font><strong>7、sql优化</strong></font></font></p><p><font>(1)、explain出来的各种item的意义；</font></p><p><font>(2)、profile的意义以及使用场景；</font></p><p><font><br></font></p><p></p><p><font><font><strong>8、备份计划，mysqldump以及xtranbackup的实现原理</strong></font></font></p><p><font>(1)、备份计划；</font></p><p><font>(2)、备份恢复时间；</font></p><p><font>(3)、xtrabackup实现原理</font></p><p><font><br></font></p><p><font><font><strong>9、mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert....value()的话，怎么办？如果备份需要带上master的复制点信息怎么办？</strong></font></font></p><p><font><br></font></p><p><font><font><strong>10、500台db，在最快时间之内重启</strong></font></font></p><p><font><font><strong><br></strong></font></font></p><p><font></font></p><p><font></font></p><p></p><p></p><p></p><p></p><p><font><font><strong>11、innodb的读写参数优化</strong></font></font></p><p><font>(1)、读取参数</font></p><p><font>(2)、写入参数；</font></p><p><font>(3)、与IO相关的参数；</font></p><p><font>(4)、缓存参数以及缓存的适用场景。</font></p><p><font><br></font></p><p></p><p><font><font><strong>12、你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？</strong></font></font></p><p><font><font><strong><br></strong></font></font></p><p><font></font></p><p><font></font></p><p><font></font></p><p><font></font></p><p><font></font></p><p><font></font></p><p><font><font><strong>13、你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？</strong></font></font></p><p><font><font><strong><br></strong></font></font></p><p><font></font></p><p><font></font></p><p><font><font><strong>14、你们数据库是否支持emoji表情，如果不支持，如何操作？</strong></font></font></p><p><font><font><strong><br></strong></font></font></p><p><font></font></p><p><font></font></p><p><font></font></p><p><font></font></p><p><font></font></p><p><font></font></p><p><font><font><strong>15、你是如何维护数据库的数据字典的?</strong></font></font></p><p><font><br></font></p><p><font></font></p><p><font></font></p><p><font><font><strong>16、你们是否有开发规范，如果有，如何执行的</strong></font></font></p><p><font><font><br></font></font></p><p><font><font><strong>17、表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问</strong></font></font></p><p><font>(1)、您是选择拆成子表，还是继续放一起；</font></p><p><font>(2)、写出您这样选择的理由。</font></p><p><font><br></font></p><p></p><p><font><font><strong>18、MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？</strong></font></font></p><p><br></p><p><font><font><strong>19、如何从mysqldump产生的全库备份中只恢复某一个库、某一张表？</strong></font></font></p><p><font><font><br></font></font></p><p><font color=\"#00bfff\"><font><font>开放性问题：据说是腾讯的</font></font></font></p><p><font><strong><strong><font>一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。</font></strong></strong></font></p><p><br></p><h2><b><span style=\"color: rgb(32, 147, 97);\">答案</span></b></h2><p style=\"text-align: justify;\"><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>1、MySQL的复制原理以及流程</b></span></span></p><p style=\"text-align: justify;\">基本原理流程，3个线程以及之间的关联；</p><p style=\"text-align: justify;\"><span style=\"font-size: 10.5pt;\">1. 主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 10.5pt;\">2. 从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；</span></p><p style=\"text-align: justify;\">3. 从：sql执行线程——执行relay log中的语句；</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>2、MySQL中myisam与innodb的区别，至少5点</b></span></span></p><p style=\"text-align: justify;\">(1)、问5点不同；</p><p style=\"text-align: justify;\"><span style=\"font-size: 10.5pt;\">1&gt;.InnoDB支持事物，而MyISAM不支持事物</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 10.5pt;\">2&gt;.InnoDB支持行级锁，而MyISAM支持表级锁</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 10.5pt;\">3&gt;.InnoDB支持MVCC, 而MyISAM不支持</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 10.5pt;\">4&gt;.InnoDB支持外键，而MyISAM不支持</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 10.5pt;\">5&gt;.InnoDB不支持全文索引，而MyISAM支持。</span></p><p style=\"text-align: justify;\">(2)、innodb引擎的4大特性</p><p style=\"text-align: justify;\"><span style=\"font-size: 10.5pt;\">插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 10.5pt;\">(3)、2者selectcount(*)哪个更快，为什么</span></p><p style=\"text-align: justify;\">myisam更快，<span style=\"color: rgb(227, 55, 55);\">因为myisam内部维护了一个计数器</span>，可以直接调取。</p><p style=\"text-align: justify;\"><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><br></span></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>3、MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义</b></span></span><br>(1)、varchar与char的区别<br><span style=\"color: rgb(227, 55, 55);\">char是一种固定长度的类型，varchar则是一种可变长度的类型</span><br>(2)、varchar(50)中50的涵义<br>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，<span style=\"color: rgb(227, 55, 55);\">但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度</span>(memory引擎也一样)<br>(3)、int（20）中20的涵义<br>是指显示字符的长度<br>但要加参数的，最大为255，比如它是记录行数的id,插入10笔资料，它就显示00000000001 ~~~00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0<br>20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；<br>(4)、mysql为什么这么设计<br>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；<br><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>4、问了innodb的事务与日志的实现方式</b></span></span><br>(1)、有多少种日志；<br>错误日志：记录出错信息，也记录一些警告信息或者正确的信息。<br>查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。<br>慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。<br>二进制日志：记录对数据库执行更改的所有操作。<br>中继日志：<br>事务日志：<br><br>(2)、事物的4种隔离级别<br>隔离级别<br>读未提交(RU)<br>读已提交(RC)<br>可重复读(RR)<br>串行<br><br>(3)、事务是如何通过日志来实现的，说得越深入越好。<br>事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的lsn(log sequence number)号; 当事务执行时，会往InnoDB存储引擎的日志<br>的日志缓存里面插入事务日志；当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”<br><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>5、问了MySQL binlog的几种日志录入格式以及区别</b></span></span><br>(1)、binlog的日志格式的种类和分别<br>(2)、适用场景；<br>(3)、结合第一个问题，每一种日志格式在复制中的优劣。<br>Statement：每一条会修改数据的sql都会记录在binlog中。<br>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能 与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条 件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所 产生的日志量会增加多少，以及带来的IO性能问题。)<br>缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的 一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).<br>使用以下函数的语句也无法被复制：<br>* LOAD_FILE()<br>* UUID()<br>* USER()<br>* FOUND_ROWS()<br>* SYSDATE() (除非启动时启用了 --sysdate-is-now 选项)<br>同时在INSERT ...SELECT 会产生比 RBR 更多的行级锁<br>2.Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。<br>优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下 每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题<br>缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比 如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。<br>3.Mixedlevel: 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则 采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择 一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的 变更。<br><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>6、问了下MySQL数据库cpu飙升到500%的话他怎么处理？</b></span></span><br>(1)、没有经验的，可以不问；<br>(2)、有经验的，问他们的处理思路。<br>列出所有进程&nbsp;&nbsp;show processlist&nbsp;&nbsp;观察所有进程&nbsp;&nbsp;多秒没有状态变化的(干掉)<br>查看超时日志或者错误日志 (做了几年开发,一般会是查询以及大批量的插入会导致cpu与i/o上涨,,,,当然不排除网络状态突然断了,,导致一个请求服务器只接受到一半，比如where子句或分页子句没有发送,,当然的一次被坑经历)<br><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>7、sql优化</b></span></span><br>(1)、explain出来的各种item的意义；<br>select_type&nbsp;<br>表示查询中每个select子句的类型<br>type<br>表示MySQL在表中找到所需行的方式，又称“访问类型”<br>possible_keys&nbsp;<br>指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用<br>key<br>显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL<br>key_len<br>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度<br>ref<br>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值&nbsp;<br>Extra<br>包含不适合在其他列中显示但十分重要的额外信息<br><br>(2)、profile的意义以及使用场景；<br>查询到 SQL 会执行多少时间, 并看出 CPU/Memory 使用量, 执行过程中 Systemlock, Table lock 花多少时间等等<br><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>8、备份计划，mysqldump以及xtranbackup的实现原理</b></span></span><br>(1)、备份计划；<br>这里每个公司都不一样，您别说那种1小时1全备什么的就行<br>(2)、备份恢复时间；<br>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考<br>20G的2分钟（mysqldump）<br>80G的30分钟(mysqldump)<br>111G的30分钟（mysqldump)<br>288G的3小时（xtra)<br>3T的4小时（xtra)<br>逻辑导入时间一般是备份时间的5倍以上<br><br>(3)、xtrabackup实现原理<br>在InnoDB内部会维护一个redo日志文件，我们也可以叫做事务日志文件。事务日志会存储每一个InnoDB表数据的记录修改。当InnoDB启动时，InnoDB会检查数据文件和事务日志，并执行两个步骤：它应用（前滚）已经提交的事务日志到数据文件，并将修改过但没有提交的数据进行回滚操作。<br><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>9、mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert....value()的话，怎么办？如果备份需要带上master的复制点信息怎么办？</b></span></span><br>--skip-extended-insert<br>[root@helei-zhuanshu ~]# mysqldump -uroot -p helei --skip-extended-insert<br>Enter password:<br>&nbsp;&nbsp;KEY `idx_c1` (`c1`),<br>&nbsp;&nbsp;KEY `idx_c2` (`c2`)<br>) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=latin1;<br>/*!40101 SET character_set_client = @saved_cs_client */;<br><br>--<br>-- Dumping data for table `helei`<br>--<br><br>LOCK TABLES `helei` WRITE;<br>/*!40000 ALTER TABLE `helei` DISABLE KEYS */;<br>INSERT INTO `helei` VALUES (1,32,37,38,\'2016-10-18 06:19:24\',\'susususususususususususu\');<br>INSERT INTO `helei` VALUES (2,37,46,21,\'2016-10-18 06:19:24\',\'susususususu\');<br>INSERT INTO `helei` VALUES (3,21,5,14,\'2016-10-18 06:19:24\',\'susu\');<br><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>10、500台db，在最快时间之内重启</b></span></span><br>puppet，dsh<br><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>11、innodb的读写参数优化</b></span></span><br>(1)、读取参数<br>global buffer pool以及 local buffer；<br><br>(2)、写入参数；<br>innodb_flush_log_at_trx_commit<br>innodb_buffer_pool_size<br><br>(3)、与IO相关的参数；<br>innodb_write_io_threads = 8<br>innodb_read_io_threads = 8<br>innodb_thread_concurrency = 0<br><br>(4)、缓存参数以及缓存的适用场景。<br>query cache/query_cache_type<br>并不是所有表都适合使用query cache。造成query cache失效的原因主要是相应的table发生了变更<br></p><ul><li>第一个：读操作多的话看看比例，简单来说，如果是用户清单表，或者说是数据比例比较固定，比如说商品列表，是可以打开的，前提是这些库比较集中，数据库中的实务比较小。</li><li>第二个：我们“行骗”的时候，比如说我们竞标的时候压测，把query cache打开，还是能收到qps激增的效果，当然前提示前端的连接池什么的都配置一样。大部分情况下如果写入的居多，访问量并不多，那么就不要打开，例如社交网站的，10%的人产生内容，其余的90%都在消费，打开还是效果很好的，但是你如果是qq消息，或者聊天，那就很要命。</li><li>第三个：小网站或者没有高并发的无所谓，高并发下，会看到 很多 qcache 锁 等待，所以一般高并发下，不建议打开query cache</li></ul><p style=\"text-align: justify;\"><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>12、你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？</b></span></span><br>监控的工具有很多，例如zabbix，lepus，我这里用的是lepus<br><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>13、你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？</b></span></span><br>主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等<br><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>14、你们数据库是否支持emoji表情，如果不支持，如何操作？</b></span></span><br>如果是utf8字符集的话，需要升级至utf8_mb4方可支持<br><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>15、你是如何维护数据库的数据字典的？</b></span></span><br>这个大家维护的方法都不同，我一般是直接在生产库进行注释，利用工具导出成excel方便流通。<br><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>16、你们是否有开发规范，如果有，如何执行的</b></span></span><br>有，开发规范网上有很多了，可以自己看看总结下<br><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>17、表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问</b></span></span><br>(1)、您是选择拆成子表，还是继续放一起；<br>(2)、写出您这样选择的理由。<br>答：拆带来的问题：连接消耗 + 存储拆分空间；不拆可能带来的问题：查询性能；<br>如果能容忍拆分带来的空间问题,拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序IO,减少连接消耗,最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗<br>如果能容忍不拆分带来的查询性能损失的话:上面的方案在某个极致条件下肯定会出现问题,那么不拆就是最好的选择<br><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 18px;\"><b>18、MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？</b></span></span><br>答<span style=\"color: rgb(227, 55, 55);\">：InnoDB是基于索引来完成行锁</span><br>例: select * from tab_with_index where id = 1 for update;<br>for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列,<br><span style=\"color: rgb(227, 55, 55);\">如果 id 不是索引键那么InnoDB将完成表锁,,并发将无从谈起</span></p><p style=\"text-align: justify;\">.</p><p style=\"text-align: justify;\"></p><p><span style=\"font-size: 18px;\"><b>19、如何从mysqldump产生的全库备份中只恢复某一个库、某一张表？</b></span></p><p style=\"text-align: justify;\">答案见：<a href=\"http://suifu.blog.51cto.com/9167728/1830651\" target=\"_blank\">http://suifu.blog.51cto.com/9167728/1830651</a><br><br><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 24px; color: rgb(65, 140, 175);\"><br></span></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 10.5pt;\"><span style=\"font-size: 24px; color: rgb(65, 140, 175);\">开放性问题：据说是腾讯的</span></span><br><b>一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。</b><br>1、如果A表TID是自增长,并且是连续的,B表的ID为索引<br>select * from a,b where a.tid = b.id and a.tid&gt;500000 limit 200;<br><br>2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。<br>select * from b , (select tid from a limit 50000,200) a where b.id = a .tid;</p>', '2018-07-04 22:59:32', '/articles/10040', '0', '0', 'publish', '1、MySQL的复制原理以及流程基本原理流程，3个线程以及之间的关联；<font', '数据库,MySQL', '【MySQL】20个经典面试题', '2019-02-26 16:00:20', '57', '1', '10004', '1'), ('10041', '0', '0', '<p style=\"margin-left: auto;\">　　项目中有好几个地方用到了哈希算法，更确切地说，是SHA算法的应用场景。MD5也是常用的哈希算法，但已经被证明不再安全，SHA-1也是如此，不安全的原因主要是彩虹表，或是碰撞计算，这里不详细描述。一般推荐使用SHA-256或者SHA-512，至少在当前是安全的。<br>　　哈希表在代码中也普遍使用，是一种用于关键字查询的数组或顺序列表，这里就不说了。</p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\"><b>1.	校验安装文件的完整性</b><br>　　在软件部署的时候，计算软件包当前的哈希值是否与预设值相等，防止软件包被篡改或被替换。Linux提供了基于sha算法的命令，用于计算文件的哈希值</p><pre><code>sha256sum fileName</code></pre><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\"><b>2. 存储和校验用户口令</b></p><p style=\"margin-left: auto;\">　　用户口令不能用明文存储，更进一步，如果系统不知道用户口令明文，那就更好了，而哈希算法就可以做到既不知道用户明文，又可以校验用户口令。详见《基于哈希算法的web账户口令存储方法》，<a href=\"http://www.cnblogs.com/todsong/archive/2012/04/22/2465178.html\">http://www.cnblogs.com/todsong/archive/2012/04/22/2465178.html</a></p><p style=\"margin-left: auto;\">&nbsp;</p><p style=\"margin-left: auto;\"><b>3. 校验重复提交的消息</b></p><p style=\"margin-left: auto;\">　　用户可能因为误操作重复提交数据，而这些数据会对系统产生影响，若要拒绝这些消息，最好的方法就是在每次提交时，计算消息的哈希值，当发现疑似重复提交的时候，做消息哈希值的对比。这是一个CPU密集型的操作，如果系统的CPU负载比较低，可以考虑使用。至于如何在代码中使用哈希算法，这里就不描述了，Java、C++都有现成的算法库可用。</p><p style=\"margin-left: auto;\">&nbsp;</p><p style=\"margin-left: auto;\"><b>4. 作为数据库乐观锁的条件</b></p><p style=\"margin-left: auto;\">　　数据库中，最常用的乐观锁方法是在表中增加额外的一列，用于记录一行数据的版本值，通常是一个计数或是时间戳。但是，一张已经存在大量数据的表需要增加额外的版本列，似乎不太可行，也不太方便，此时可以通过哈希计算出虚拟的版本列，用于乐观锁定控制。Oracle数据库提供了哈希算法的存储过程，输入某几个列数据的字符连接，输出该条记录的哈希值，通过比较该值判断数据是否被修改。下面是摘自《Oracle 9i&amp;10g 编程艺术》的例子</p><pre><code><span style=\"line-height: 1.8; color: rgb(0, 0, 255);\">begin</span>\n <span style=\"line-height: 1.8; color: rgb(0, 0, 255);\">for</span> x <span style=\"line-height: 1.8; color: rgb(128, 128, 128);\">in</span> ( <span style=\"line-height: 1.8; color: rgb(0, 0, 255);\">select</span><span style=\"line-height: 1.8; color: rgb(0, 0, 0);\"> deptno, dname, loc\n </span><span style=\"line-height: 1.8; color: rgb(0, 0, 255);\">from</span><span style=\"line-height: 1.8; color: rgb(0, 0, 0);\"> dept\n </span><span style=\"line-height: 1.8; color: rgb(0, 0, 255);\">where</span> deptno <span style=\"line-height: 1.8; color: rgb(128, 128, 128);\">=</span> <span style=\"line-height: 1.8; color: rgb(128, 0, 0); font-weight: bold;\">10</span><span style=\"line-height: 1.8; color: rgb(0, 0, 0);\"> )\n loop\n dbms_output.put_line( </span><span style=\"line-height: 1.8; color: rgb(255, 0, 0);\">\'</span><span style=\"line-height: 1.8; color: rgb(255, 0, 0);\">Dname: </span><span style=\"line-height: 1.8; color: rgb(255, 0, 0);\">\'</span> <span style=\"line-height: 1.8; color: rgb(128, 128, 128);\">||</span><span style=\"line-height: 1.8; color: rgb(0, 0, 0);\"> x.dname );\n dbms_output.put_line( </span><span style=\"line-height: 1.8; color: rgb(255, 0, 0);\">\'</span><span style=\"line-height: 1.8; color: rgb(255, 0, 0);\">Loc: </span><span style=\"line-height: 1.8; color: rgb(255, 0, 0);\">\'</span> <span style=\"line-height: 1.8; color: rgb(128, 128, 128);\">||</span><span style=\"line-height: 1.8; color: rgb(0, 0, 0);\"> x.loc );\n dbms_output.put_line( </span><span style=\"line-height: 1.8; color: rgb(255, 0, 0);\">\'</span><span style=\"line-height: 1.8; color: rgb(255, 0, 0);\">Hash: </span><span style=\"line-height: 1.8; color: rgb(255, 0, 0);\">\'</span> <span style=\"line-height: 1.8; color: rgb(128, 128, 128);\">||</span><span style=\"line-height: 1.8; color: rgb(0, 0, 0);\">\n dbms_crypto.hash\n ( utl_raw.cast_to_raw(x.deptno</span><span style=\"line-height: 1.8; color: rgb(128, 128, 128);\">||</span><span style=\"line-height: 1.8; color: rgb(255, 0, 0);\">\'</span><span style=\"line-height: 1.8; color: rgb(255, 0, 0);\">/</span><span style=\"line-height: 1.8; color: rgb(255, 0, 0);\">\'</span><span style=\"line-height: 1.8; color: rgb(128, 128, 128);\">||</span>x.dname<span style=\"line-height: 1.8; color: rgb(128, 128, 128);\">||</span><span style=\"line-height: 1.8; color: rgb(255, 0, 0);\">\'</span><span style=\"line-height: 1.8; color: rgb(255, 0, 0);\">/</span><span style=\"line-height: 1.8; color: rgb(255, 0, 0);\">\'</span><span style=\"line-height: 1.8; color: rgb(128, 128, 128);\">||</span><span style=\"line-height: 1.8; color: rgb(0, 0, 0);\">x.loc),\n dbms_crypto.hash_sh1 ) );\n </span><span style=\"line-height: 1.8; color: rgb(0, 0, 255);\">end</span><span style=\"line-height: 1.8; color: rgb(0, 0, 0);\"> loop;\n </span><span style=\"line-height: 1.8; color: rgb(0, 0, 255);\">end</span><span style=\"line-height: 1.8; color: rgb(0, 0, 0);\">;\n</span><span style=\"line-height: 1.8; color: rgb(128, 128, 128);\">/</span></code></pre><p><br></p><p style=\"margin-left: auto;\">上面存储过程执行的结果是</p><pre><code><span style=\"line-height: 1.8; color: rgb(0, 0, 0);\">Dname: ACCOUNTING\nLoc: NEW YORK\nHash: C44F7052661CE945D385D5C3F911E70FA99407A6\nPL</span><span style=\"line-height: 1.8; color: rgb(128, 128, 128);\">/</span>SQL <span style=\"line-height: 1.8; color: rgb(0, 0, 255);\">procedure</span> successfully completed.</code></pre><p style=\"margin-left: auto;\">&nbsp;</p><p style=\"margin-left: auto;\"><b>5. 作为数据库表分区的分区条件</b></p><p style=\"margin-left: auto;\">　　如果难以按照某一个列对数据库表做分区，表中的数据又没有太多的业务逻辑，那么通过哈希函数强行分区是个不错的选择。详见《Oracle分区表，哈希分区的新建与增加》，<a href=\"http://www.cnblogs.com/todsong/archive/2012/08/26/2657158.html\">http://www.cnblogs.com/todsong/archive/2012/08/26/2657158.html</a></p>', '2018-07-05 16:35:51', '/articles/10041', '0', '0', 'publish', '　　项目中有好几个地方用到了哈希算法，更确切地说，是SHA算法的应用场景。MD5也是常用的哈希算法，但已经被证明不再安全，SHA-1也是如此，不安全的原因主要是彩虹表，或是碰撞计算，这里不详细描述。一般推荐使用SHA-256或者SHA-51', '算法,哈希,Hash', '哈希算法（Hash、散列）应用场景小结', '2019-04-29 17:39:30', '34', '1', '10013', '1'), ('10042', '0', '0', '<p>在目前的一个简单的项目中，遇到了简单的问题，解决成本&amp;售价输入input框内只能输入某类型数值问题,目前只贴了整数和浮点数的代码。</p><p>限制只能输入<span style=\"font-size: 1.25em;\"><b>整数</b></span>：</p><pre><code class=\"lang-html\">&lt;<span style=\"color:#000080;font-weight:bold;\">input </span><span style=\"color:#008000;font-weight:bold;\"><br></span><span style=\"color:#008000;font-weight:bold;\">       </span><span style=\"color:#0000ff;font-weight:bold;\">onkeyup=</span><span style=\"color:#008000;font-weight:bold;\">\"<br></span><span style=\"color:#008000;font-weight:bold;\">       </span><span style=\"color:#000080;font-weight:bold;\">if</span>(<span style=\"color:#000080;font-weight:bold;\">this</span>.<span style=\"color:#660e7a;font-weight:bold;\">value</span>.<span style=\"color:#660e7a;font-weight:bold;\">length</span>===<span style=\"color:#0000ff;\">1</span>){<br>           <span style=\"color:#000080;font-weight:bold;\">this</span>.<span style=\"color:#660e7a;font-weight:bold;\">value</span>=<span style=\"color:#000080;font-weight:bold;\">this</span>.<span style=\"color:#660e7a;font-weight:bold;\">value</span>.<span style=\"color:#7a7a43;\">replace</span>(<span style=\"color:#0000ff;\">/[^1-9]/g</span>,<span style=\"color:#008000;font-weight:bold;\">\'\'</span>)<br>       }<span style=\"color:#000080;font-weight:bold;\">else</span>{<br>           <span style=\"color:#000080;font-weight:bold;\">this</span>.<span style=\"color:#660e7a;font-weight:bold;\">value</span>=<span style=\"color:#000080;font-weight:bold;\">this</span>.<span style=\"color:#660e7a;font-weight:bold;\">value</span>.<span style=\"color:#7a7a43;\">replace</span>(<span style=\"color:#0000ff;\">/\\D/g</span>,<span style=\"color:#008000;font-weight:bold;\">\'\'</span>)<br>       }<span style=\"color:#008000;font-weight:bold;\">\"<br></span>/&gt;</code></pre><p>限制只能输入 <b>浮点数&amp;整数</b>：</p><pre><code class=\"lang-html\">&lt;<span style=\"color:#000080;font-weight:bold;\">input </span><span style=\"color:#0000ff;font-weight:bold;\">title=</span><span style=\"color:#008000;font-weight:bold;\">\"\" </span><span style=\"color:#0000ff;font-weight:bold;\">onkeyup=</span><span style=\"color:#008000;font-weight:bold;\">\"</span><span style=\"font-style:italic;\">checkInputNum</span>(<span style=\"color:#000080;font-weight:bold;\">this</span>)<span style=\"color:#008000;font-weight:bold;\">\" </span>/&gt;\n</code></pre><pre><code class=\"lang-js\">&lt;<span style=\"color:#000080;font-weight:bold;\">script</span>&gt;<br>    /* <span style=\"font-family:\'宋体\';\">检查输入的浮点数函数</span>*/<br>    function checkInputNum(obj){<br>        <span style=\"color:#808080;font-style:italic;\">//</span><span style=\"color:#808080;font-style:italic;font-family:\'宋体\';\">先把非数字的都替换掉，除了数字和</span><span style=\"color:#808080;font-style:italic;\">.<br></span><span style=\"color:#808080;font-style:italic;\">        </span>obj.<span style=\"color:#660e7a;font-weight:bold;\">value </span>= obj.<span style=\"color:#660e7a;font-weight:bold;\">value</span>.<span style=\"color:#7a7a43;\">replace</span>(<span style=\"color:#0000ff;\">/[^\\d.]/g</span>,<span style=\"color:#008000;font-weight:bold;\">\"\"</span>);<br><br>        <span style=\"color:#808080;font-style:italic;\">//</span><span style=\"color:#808080;font-style:italic;font-family:\'宋体\';\">必须保证第一个为数字而不是</span><span style=\"color:#808080;font-style:italic;\">.<br></span><span style=\"color:#808080;font-style:italic;\">        </span>obj.<span style=\"color:#660e7a;font-weight:bold;\">value </span>= obj.<span style=\"color:#660e7a;font-weight:bold;\">value</span>.<span style=\"color:#7a7a43;\">replace</span>(<span style=\"color:#0000ff;\">/^\\./g</span>,<span style=\"color:#008000;font-weight:bold;\">\"\"</span>);<br><br>        <span style=\"color:#808080;font-style:italic;\">//</span><span style=\"color:#808080;font-style:italic;font-family:\'宋体\';\">保证只有出现一个</span><span style=\"color:#808080;font-style:italic;\">.</span><span style=\"color:#808080;font-style:italic;font-family:\'宋体\';\">而没有多个</span><span style=\"color:#808080;font-style:italic;\">.<br></span><span style=\"color:#808080;font-style:italic;\">        </span>obj.<span style=\"color:#660e7a;font-weight:bold;\">value </span>= obj.<span style=\"color:#660e7a;font-weight:bold;\">value</span>.<span style=\"color:#7a7a43;\">replace</span>(<span style=\"color:#0000ff;\">/\\.{2,}/g</span>,<span style=\"color:#008000;font-weight:bold;\">\".\"</span>);<br><br>        <span style=\"color:#808080;font-style:italic;\">//</span><span style=\"color:#808080;font-style:italic;font-family:\'宋体\';\">保证</span><span style=\"color:#808080;font-style:italic;\">.</span><span style=\"color:#808080;font-style:italic;font-family:\'宋体\';\">只出现一次，而不能出现两次以上<br></span><span style=\"color:#808080;font-style:italic;font-family:\'宋体\';\">        </span>obj.<span style=\"color:#660e7a;font-weight:bold;\">value </span>= obj.<span style=\"color:#660e7a;font-weight:bold;\">value</span>.<span style=\"color:#7a7a43;\">replace</span>(<span style=\"color:#008000;font-weight:bold;\">\".\"</span>,<span style=\"color:#008000;font-weight:bold;\">\"$#$\"</span>).<span style=\"color:#7a7a43;\">replace</span>(<span style=\"color:#0000ff;\">/\\./g</span>,<span style=\"color:#008000;font-weight:bold;\">\"\"</span>).<span style=\"color:#7a7a43;\">replace</span>(<span style=\"color:#008000;font-weight:bold;\">\"$#$\"</span>,<span style=\"color:#008000;font-weight:bold;\">\".\"</span>);<br><br>        <span style=\"color:#808080;font-style:italic;\">//</span><span style=\"color:#808080;font-style:italic;font-family:\'宋体\';\">保证 数字整数位不大于</span><span style=\"color:#808080;font-style:italic;\">8</span><span style=\"color:#808080;font-style:italic;font-family:\'宋体\';\">位  可以根据自己的需求进行更改<br></span><span style=\"color:#808080;font-style:italic;font-family:\'宋体\';\">        </span><span style=\"color:#000080;font-weight:bold;\">if</span>(<span style=\"color:#0000ff;\">100000000</span>&lt;=<span style=\"font-style:italic;\">parseFloat</span>(obj.<span style=\"color:#660e7a;font-weight:bold;\">value</span>))<br>            obj.<span style=\"color:#660e7a;font-weight:bold;\">value </span>= <span style=\"color:#008000;font-weight:bold;\">\"\"</span>;<br>    }<br><br>&lt;/<span style=\"color:#000080;font-weight:bold;\">script</span>&gt;</code></pre>', '2018-07-06 10:21:06', '/articles/10042', '0', '0', 'publish', '在目前的一个简单的项目中，遇到了简单的问题，解决成本&售价输入input框内只能输入某类型数值问题,目前只贴了整数和浮点数的代码。限制只能输入整数：<code ', 'HTML,JS', '前端的简单知识——input框限制只能输入整数&浮点数', '2019-05-06 20:16:32', '95', '0', '10014', '7'), ('10043', '0', '0', '<p>1）.下载redis</p><p>进redis官网，有下载链接，复制过来粘贴到putty回车，下载，如下图第一条：</p><p><img alt=\"\" src=\"G:/YouDaoNote/891506987@qq.com/1a590349e6b643f08a4232b84678bc31/clipboard.png\"><img alt=\"\" src=\"G:/YouDaoNote/891506987@qq.com/1a590349e6b643f08a4232b84678bc31/clipboard.png\"><img alt=\"1.png\" src=\"http://cdn.codergroup.cn/uploads/2018/7/6/HickSalmon/1530862035408\" width=\"646\" height=\"172\"></p><p>2）.然后将下载的文件移动到指定文件夹，并且解压</p><p>-1	移动命令 mv 	需要移动的文件	要移动到的文件夹路径；</p><p>-2	cd 移动到的文件夹路径；</p><p>-3	tar -zxvf 	下载的文件。</p><p>3).将配置文件redis.conf复制一份放到/etc/redis文件夹之下,redis文件夹默认没有，需要创建。</p><p>创建redis文件夹	mkdir 	/etc/redis</p><p>复制命令 cp	需要复制的文件	要复制到的文件夹路径</p><p>4).配置文件修改</p><p>vi /etc/redis.conf</p><p>利用 “/字符串”回车可以搜索该文件中这个字符串的位置，按n可以查看下一个的位置</p><p>-1.	bind 127.0.0.1 将这个注释掉，默认只让本机访问，不注释，云上的redis，本地将不能访问；</p><p>-2.	requirepass	登陆的密码 写在后面就行了；</p><p>-3	protected-mode 	值为yes，登陆的时候需要密码，为no时，登录不需要密码，不安全</p>', '2018-07-06 15:28:27', '/articles/10043', '0', '0', 'publish', '1）.下载redis进redis官网，有下载链接，复制过来粘贴到putty回车，下载，如下图第一条：<img alt=\"\" src=\"G:/YouDaoNote/891506987@qq.com/1a590349e6b643f08a4232b84678bc31/cl', 'Ubuntu16.04,redis,配置', 'redis安装与简单配置（Ubuntu16.04）', '2019-05-14 20:24:42', '32', '0', '10015', '9'), ('10044', '0', '0', '<h1><b style=\"color: rgb(227, 55, 55);\">一、可回收对象判断</b></h1><p style=\"text-align: justify;\"><span style=\"font-size: 16px;\">引用计数器算法<span style=\"color: rgb(32, 147, 97);\">：为对象放置一个引用计数器，当对象被引用时则计数器加一，当引用消失时减一，如果一个对象的计数器标识为零的时候，则表明该对象可被回收。这种方法比较简单，但无法解决对象之间互相引用的情况</span>。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 16px;\">GC Roots算法：该方法可以解决上面算法中的对象互相引用无法判断可回收状态的问题。顾名思义，GC Root指的是程序使用对象，总会有一个“入口”，这里可以是栈里的本地变量引用，也可以是方法区中的类静态属性引用、常量引用、JNI的Java引用。当一个对象，如果所有的GC Root沿着对象引用链都到不了，这证明该对象到GC Roots不可达，即该对象没有使用的“入口”，自然是可回收的。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 16px;\"><img alt=\"GC-Roots算法.png\" src=\"http://cdn.codergroup.cn/uploads/2018/7/6/saysky/1530867691405\" width=\"834\" height=\"530\"><br></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 16px;\"><br></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 16px;\">如图1，当root3=null的时候，Object5、6、7便到所有root不可达，即使Object6和Object7是互相引用的关系也可以判断为可回收状态。如果想回收Object2，则需要该对象到root1 和 root2的引用链都断了才能回收。</span></p><h1><b style=\"color: rgb(227, 55, 55);\">二、对象回收的流程</b></h1><p><img alt=\"Java对象回收流程图.png\" src=\"http://cdn.codergroup.cn/uploads/2018/7/6/saysky/1530867719447\" width=\"452\" height=\"846\"><br></p><p><span style=\"font-size: 16px;\">对象回收流程如上图所示，需要注意的两点为：</span></p><p><span style=\"font-size: 16px;\">1、一个对象GC Roots不可达以及已经执行过finalize方法才可被回收；</span></p><p><span style=\"font-size: 16px;\">2、一个对象的finalize方法只会被执行一次；</span></p>', '2018-07-06 18:03:19', '/articles/10044', '0', '0', 'publish', '一、可回收对象判断引用计数器算法<span style=\"color: rg', 'Java,jvm', 'Java对象回收流程', '2019-04-27 18:13:19', '31', '0', '10016', '1'), ('10045', '0', '1', '<p style=\"margin-left: auto;\"><strong>垃圾收集算法、垃圾回收算法、</strong><strong>java</strong><strong>垃圾收集器</strong></p><p style=\"margin-left: auto;\"><strong>目录</strong><br><strong>1. 垃圾收集算法</strong><br>1）引用计数法<br>2）根搜索法<br><strong>2. 垃圾回收算法</strong><br>1）复制算法<br>2）标记-清除算法<br>3）标记-整理算法<br>4）分代收集算法<br><strong>3. java垃圾收集器</strong><br><strong>新生代GC器：</strong><br>1）Serial垃圾收集器<br>2）ParNew垃圾收集器<br>3）Parallel Scavenge垃圾收集器<br><strong>老年代GC器</strong><br>1）Serial和Parallel Scavenge都有对应的老年代版本<br>2）CMS垃圾收集器<br><a href=\"http://www.importnew.com/15311.html\" target=\"_blank\"><strong>G1回收器</strong></a><br><strong>4.java对象的内存分配位置<br><strong>5.java TLAB<strong><br><strong>6.java 何时触发GC<br></strong></strong></strong></strong>1) new gen对象什么时候会晋升到old gen中？<br>2) 什么时候会出现old gen空间不足（old gen空间不足时，会触发full gc）？</p><p style=\"margin-left: auto;\">&nbsp;</p><p style=\"margin-left: auto;\"><strong>1.&nbsp;</strong><strong>垃圾收集算法</strong></p><p style=\"margin-left: auto;\"><strong>1</strong><strong>）</strong><strong>引用计数法</strong></p><p style=\"margin-left: auto;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 给对象添加引用计数器，当引用对象时计数器+1，引用失效时，计数器-1，当计数器等于0时，对象失效，内存可以被回收。</p><p style=\"margin-left: auto;\">优点：实现简单高效。</p><p style=\"margin-left: auto;\">缺点：对象之间的互相循环引用问题不好解决。</p><p style=\"margin-left: auto;\"><strong>2</strong><strong>）根搜索法</strong></p><p style=\"margin-left: auto;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过GC roots可达的对象路径称为引用链（reference chain），当一个对象没有引用链时（即从GC roots不可达）则视为不可用对象，内存可以被回收。java使用该算法进行垃圾收集。</p><p style=\"margin-left: auto;\">哪些对象可以视为GC roots ?</p><p style=\"margin-left: auto;\">a.&nbsp;虚拟机栈中（即栈帧中的本地变量）的引用对象；</p><p style=\"margin-left: auto;\">b.&nbsp;本地方法栈中的引用对象；</p><p style=\"margin-left: auto;\">c.&nbsp;方法区（永久代）中的静态变量引用的对象和常量池中引用的对象</p><p style=\"margin-left: auto;\">&nbsp;</p><p style=\"margin-left: auto;\"><strong>2.&nbsp;</strong><strong>垃圾回收算法</strong></p><p style=\"margin-left: auto;\"><strong>1</strong><strong>）</strong><strong>复制算法</strong></p><p style=\"margin-left: auto;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将内存分为（大小相等）两部分，每次只使用其中一块进行内存分配，当内存使用完后，就出发GC，将存活的对象直接复制到另一块空闲的内存中，然后对当前使用的内存块一次性清除所有，然后转到另一块内存进行使用。</p><p style=\"margin-left: auto;\">优点：简单，高效。</p><p style=\"margin-left: auto;\">缺点：浪费内存，因为每次都有另一块内存空闲着。</p><p style=\"margin-left: auto;\"><strong>2</strong><strong>）</strong><strong>标记</strong><strong>-</strong><strong>清除算法</strong></p><p style=\"margin-left: auto;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 分两步进行，第一步标记出可以回收的对象，第二步统一清理可以回收的对象内存。</p><p style=\"margin-left: auto;\">缺点：首先标记和清除步骤效率都不高，其次会产生内存碎片。</p><p style=\"margin-left: auto;\"><strong>3</strong><strong>）标记</strong><strong>-</strong><strong>整理算法</strong></p><p style=\"margin-left: auto;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类似于标记-清除算法，但是第二步进行内存回收时，将存活的对象向内存一端移动，达到消除内存碎片问题。</p><p style=\"margin-left: auto;\"><strong>4</strong><strong>）分代收集算法</strong></p><p style=\"margin-left: auto;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java sun hotspot虚拟机将内存分为新生代（堆）、老年代（堆）、永久代（方法区、常量池、即时编译代码）几个区域，新生代主要使用基于复制算法的垃圾回收，老年代和永久代主要使用标记-整理算法进行垃圾回收。具体每个区域使用哪种垃圾回收算法还要视收集器的实现制约。</p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\"><img alt=\"1.png\" src=\"http://cdn.codergroup.cn/uploads/2018/7/6/saysky/1530872363604\" width=\"475\" height=\"398\"><br></p><p style=\"margin-left: auto;\"><img alt=\"2.png\" src=\"http://cdn.codergroup.cn/uploads/2018/7/6/saysky/1530872369199\" width=\"339\" height=\"455\"><br></p><p style=\"margin-left: auto;\"><strong>3. java</strong><strong>垃圾收集器</strong></p><p style=\"margin-left: auto;\"><strong>新生代</strong><strong>GC</strong><strong>器：</strong></p><p style=\"margin-left: auto;\"><strong>1</strong><strong>）</strong><strong>Serial</strong><strong>垃圾收集器：</strong></p><p style=\"margin-left: auto;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 单线程串行垃圾收集器，使用复制算法进行垃圾回收，GC时需要暂停所有用户线程，直到GC完成。</p><p style=\"margin-left: auto;\">注：此处的串行垃圾收集器中的串行意义是指GC过程和用户线程执行过程是串行的，即GC过程中用户线程暂停，用户线程执行是，GC是不执行的。</p><p style=\"margin-left: auto;\"><strong>2</strong><strong>）</strong><strong>ParNew</strong><strong>垃圾收集器：</strong></p><p style=\"margin-left: auto;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 多线程串行垃圾收集器，Serial的多线程版本，其它特性同Serial。</p><p style=\"margin-left: auto;\"><strong>3</strong><strong>）</strong><strong>Parallel Scavenge</strong><strong>垃圾收集器：</strong></p><p style=\"margin-left: auto;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类似于ParNew，但是该收集器关注的是cpu的吞吐量（throughput=user-cpu-time/total-cpu），通过参数-XX:GCTimeRation和-XX:MaxGCPauseMillis来控制吞吐量，是吞吐量优先的收集器，同样使用复制算法进行垃圾回收，GC过程需要暂停所有用户线程。</p><p style=\"margin-left: auto;\">&nbsp;</p><p style=\"margin-left: auto;\"><strong>老年代</strong><strong>GC</strong><strong>器：</strong></p><p style=\"margin-left: auto;\"><strong>1</strong><strong>）</strong><strong>Serial</strong><strong>和</strong><strong>Parallel Scavenge</strong><strong>都有对应的老年代版本：</strong></p><p style=\"margin-left: auto;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serial Old和Parallel Old垃圾收集器，它们与新生代的区别在于老年代区域的版本，采用标记-整理算法进行垃圾回收。</p><p style=\"margin-left: auto;\"><strong>2</strong><strong>）</strong><strong>CMS</strong><strong>垃圾收集器：</strong></p><p style=\"margin-left: auto;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Concurrent Mark Sweep收集器，是真正意义上的多线程并行垃圾收集器，CMS在GC过程中的某些阶段用户线程是可以运行的，因此说它是真正意义上的并行垃圾收集器，前面介绍的垃圾收集器在GC过程中都要暂停用户线程，因此，视它们为与用户线程串行执行的垃圾收集器。CMS GC过程分四步完成：</p><p style=\"margin-left: auto;\">a.初始标记：只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</p><p style=\"margin-left: auto;\">b.并发标记：进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</p><p style=\"margin-left: auto;\">c.重新标记：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。</p><p style=\"margin-left: auto;\">d.并发清除：清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。</p><p style=\"margin-left: auto;\"><strong>**G1回收</strong><strong>器：</strong>&nbsp;</p><p style=\"margin-left: auto;\">参考：<a href=\"http://www.importnew.com/15311.html\" target=\"_blank\">http://www.importnew.com/15311.html</a></p><p style=\"margin-left: auto;\">&nbsp;</p><p style=\"margin-left: auto;\"><strong>4.&nbsp;</strong><strong>java对象的内存分配<strong>位置</strong></strong></p><p style=\"margin-left: auto;\">1) 编译器通过逃逸分析，确定对象是在栈上分配还是在堆上分配。如果是在堆上分配，则进入选项2.<br>2) 如果tlab_top + size &lt;= tlab_end，则在在TLAB上直接分配对象并增加tlab_top 的值，如果现有的TLAB不足以存放当前对象则3.<br>3) 重新申请一个TLAB，并再次尝试存放当前对象。如果放不下，则4.<br>4) 在Eden区加锁（这个区是多线程共享的），如果eden_top + size &lt;= eden_end则将对象存放在Eden区，增加eden_top 的值，如果Eden区不足以存放，则5.<br>执行一次Young GC（minor collection）。<br>5) 经过Young GC之后，如果Eden区任然不足以存放当前对象，则直接分配到老年代。</p><p style=\"margin-left: auto;\">&nbsp;</p><p style=\"margin-left: auto;\"><strong>5.&nbsp;</strong><strong>java TLAB</strong><br>JVM在内存新生代Eden Space中开辟了一小块线程私有的区域，称作TLAB（Thread-local allocation buffer）。默认设定为占用Eden Space的1%。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。<br>也就是说，Java中每个线程都会有自己的缓冲区称作TLAB（Thread-local allocation buffer），每个TLAB都只有一个线程可以操作，TLAB结合bump-the-pointer技术可以实现快速的对象分配，而不需要任何的锁进行同步，也就是说，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可。<br>关于对象分配的JDK源码可以参见JVM 之 Java对象创建[初始化]中对OpenJDK源码的分析。</p><p style=\"margin-left: auto;\">&nbsp;</p><p style=\"margin-left: auto;\"><strong>6.&nbsp;</strong><strong>java 何时触发GC</strong></p><p style=\"margin-left: auto;\">eden或old gen空间不足时会发出minor gc或full gc。</p><p style=\"margin-left: auto;\"><strong>1) new gen对象什么时候会晋升到old gen中？</strong></p><p style=\"margin-left: auto;\">1. 多次minor gc后依然存活的对象，在存活年龄超过MaxTenuringThreshold阈值时会晋升到old gen中。<br>2. 在创建大对象/数组时，如果设置了PretenureSizeThreshold，超过大小的对象会直接在old gen中分配内存。</p><p style=\"margin-left: auto;\"><br><strong>2) 什么时候会出现old gen空间不足（<strong>old gen空间不足时，会触发full gc</strong>）？</strong><br>1. 创建大对象，大数组时，如果设置了PretenureSizeThreshold，超过阈值会直接在old gen中分配内存，此时可能会出现old gen内存不足。<br>2. minor gc完成后，可能会有对象满足了MaxTenuringThreshold设置的晋升年龄，需要晋升到old gen，此时可能会出现old gen内存不足。<br>3. 如果设置了新生代收集担保机制即HandlePromotionFailure关闭，则会在old gen中预留edu+survivor大小的空间作为担保，如果minor gc时，<br>old gen无法提供足够内存进行担保，会出现old gen内存不足。<br>4. 调用System.gc()时，会建议jvm进行full gc，但是并不保证一定会进行，大多数情况会执行full gc。因此，要慎用System.gc()，因为full gc<br>比较耗时，增加full gc次数会严重影响程序执行效率。-XX:+DisableExplicitGC可以关闭System.gc()调用。<br>5. perm gen内存不足时，也会出发full gc。</p><p style=\"margin-left: auto;\"><br></p><p style=\"margin-left: auto;\">原文地址：<a href=\"https://www.cnblogs.com/wrencai/p/5668621.html\" rel=\"nofollow\">https://www.cnblogs.com/wrencai/p/5668621.html</a></p>', '2018-07-06 18:20:18', '/articles/10045', '0', '0', 'publish', '垃圾收集算法、垃圾回收算法、java垃圾收集器目录</', 'Java,jvm,gc', 'java垃圾回收算法和垃圾收集器', '2019-05-14 19:15:35', '33', '0', '10016', '1'), ('10046', '0', '0', '<p><b>1.为什么会有年轻代</b><br></p><p style=\"text-align: justify;\">我们先来屡屡，为什么需要把堆分代？不分代不能完成他所做的事情么？其实不分代完全可以，分代的唯一理由就是优化GC性能。你先想想，如果没有分代，那我们所有的对象都在一块，GC的时候我们要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而我们的很多对象都是朝生夕死的，如果分代的话，我们把新创建的对象放到某一地方，当GC的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><p style=\"text-align: justify;\"></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>2.年轻代中的GC</b></p><p style=\"text-align: justify;\">&nbsp;&nbsp;&nbsp; HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p><p style=\"text-align: justify;\">因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p><p style=\"text-align: justify;\">在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p><p style=\"text-align: justify;\"><img alt=\"young_gc.png\" src=\"http://cdn.codergroup.cn/uploads/2018/7/6/saysky/1530872987749\" width=\"829\" height=\"345\"><br></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b style=\"color: rgb(227, 55, 55);\">3.一个对象的这一辈子</b></p><p style=\"text-align: justify;\">我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。</p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><b>4.有关年轻代的JVM参数</b></p><p style=\"text-align: justify;\">1)-XX:NewSize和-XX:MaxNewSize</p><p style=\"text-align: justify;\">用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。</p><p style=\"text-align: justify;\">2)-XX:SurvivorRatio</p><p style=\"text-align: justify;\">用于设置Eden和其中一个Survivor的比值，这个值也比较重要。</p><p style=\"text-align: justify;\">3)-XX:+PrintTenuringDistribution</p><p style=\"text-align: justify;\">这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。</p><p style=\"text-align: justify;\">4).-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold</p><p style=\"text-align: justify;\">用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。</p><p><br></p><p><br></p><p>原文地址：<a href=\"http://ifeve.com/jvm-yong-generation/\" rel=\"nofollow\">http://ifeve.com/jvm-yong-generation/</a></p>', '2018-07-06 19:53:30', '/articles/10046', '0', '0', 'publish', '1.为什么会有年轻代我们先来屡屡，为什么需要把堆分代？不分代不能完成他所做的事情么？其实不分代完全可以，分代的唯一理由就是优化GC性能。你先想想，如果没有分代，那我们所有的对象都在一块，GC的时候我们', 'JVM', '聊聊JVM的年轻代', '2019-05-12 22:41:45', '35', '0', '10016', '1'), ('10517', '0', '0', '<p>本站源码出售，可当毕业设计，也可以当博客系统项目学习</p><p>本站基于 SpringBoot + SpringData JPA +Thymeleaf 实现，MySQL数据库。</p><p>引入Spring Security作为权限框架，Redis 作为部分缓存。</p><p>前端采用 BootStrap + jQuery 实现。</p><p><span style=\"color: rgb(227, 55, 55);\">需要的朋友可以联系博主：847064370 (微信同号)</span></p><p><span style=\"color: rgb(227, 55, 55);\">价格可以谈</span></p><h2><b>提供服务</b></h2><p>1.本系统所有源码和数据库文件（通过GitHub私有仓库方式拉人或直接发送zip包代码文件）</p><p>2.远程调试运行部署</p><p>3.需要服务器部署也可以援助</p><p>4.不懂的地方提供讲解</p><p>5.提出Bug，博主会进行修改</p><p>6.提出改造建议，博主会考虑采纳并修改</p><h2><b>适合用户</b></h2><p>1.做毕设的同学，该项目五脏俱全，如果做博客、论坛类项目可以直接拿来用，或者删减一些不必要的功能。</p><p>2.做个人网站的朋友，可以保留前端页面，如果你有自己的前端模板，也可以很方面的进行修改，无需修改后端代码。</p><p>3.学习SpringBoot的同学，可以学习到整个网站的结构，每个模块怎么实现</p><p><br></p><h2><b>主要功能</b></h2><p>文章、分类、标签、评论、点赞、收藏、提问、回答、评论点赞</p><p><span style=\"font-size: 16px;\">注册、登录、找回密码(邮件发送)</span><br></p><p>两种角色，管理员和普通用户（可以扩展）</p><p>七牛云上传</p><p>第三方登录(QQ登录和GitHub登录)</p><p>等等</p><p><br></p><h2><b>界面</b></h2><p>后台管理界面（管理员）</p><p><img alt=\"WX20190506-201403@2x.png\" src=\"http://cdn.codergroup.cn/uploads/2019/5/6/saysky/1557148633442\" width=\"2878\" height=\"1798\"><br></p><p><br></p><p>前台管理界面（普通用户）</p><p><img alt=\"WX20190506-201518@2x.png\" src=\"http://cdn.codergroup.cn/uploads/2019/5/6/saysky/1557148666601\" width=\"2878\" height=\"1798\"><br></p>', '2019-05-06 20:10:29', '/articles/10517', '0', '0', 'publish', '本站源码出售，可当毕业设计，也可以当博客系统项目学习本站基于 SpringBoot + SpringData JPA +Thymeleaf 实现，MySQL数据库。引入Spring Security作为权限框架，Redis 作为部分缓存。前端采用 Bo', '源码,出售', '本站源码出售', '2019-05-14 20:14:32', '2', '0', '10079', '1');
COMMIT;

-- ----------------------------
--  Table structure for `article_zan`
-- ----------------------------
DROP TABLE IF EXISTS `article_zan`;
CREATE TABLE `article_zan` (
  `article_id` bigint(20) NOT NULL,
  `zan_id` bigint(20) NOT NULL,
  UNIQUE KEY `UK_as6utms0q91qhl62ytxedd9b4` (`zan_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `article_zan`
-- ----------------------------
BEGIN;
INSERT INTO `article_zan` VALUES ('10000', '1'), ('10001', '2'), ('10003', '7'), ('10010', '8'), ('10011', '12'), ('10013', '13'), ('10003', '14'), ('10041', '22'), ('10040', '23'), ('10027', '52'), ('10002', '56');
COMMIT;

-- ----------------------------
--  Table structure for `authority`
-- ----------------------------
DROP TABLE IF EXISTS `authority`;
CREATE TABLE `authority` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `authority`
-- ----------------------------
BEGIN;
INSERT INTO `authority` VALUES ('1', 'ROLE_ADMIN'), ('2', 'ROLE_USER');
COMMIT;

-- ----------------------------
--  Table structure for `bind`
-- ----------------------------
DROP TABLE IF EXISTS `bind`;
CREATE TABLE `bind` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `create_time` datetime DEFAULT NULL,
  `credential` varchar(255) DEFAULT NULL,
  `identifier` varchar(255) NOT NULL,
  `status` int(11) DEFAULT NULL,
  `bind_type_id` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=63 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `bind`
-- ----------------------------
BEGIN;
INSERT INTO `bind` VALUES ('4', '2018-06-15 15:43:49', null, '799EFEA0C51C2F575CEEE822CCBC2019', '1', '1', '8'), ('5', '2018-06-18 22:23:13', null, '90BCD55EE1184B5D899EA5EF067ADA84', '1', '1', '8'), ('6', '2018-06-20 19:46:39', null, 'BCD437BC6EC38B683FD77E1E910FD1A4', '1', '1', '17'), ('7', '2018-07-03 16:38:15', null, '7E52AF82A3534AE6836335B1393DE1DC', '1', '1', '23'), ('8', '2018-07-04 13:46:27', null, '651DEBC6E3191FFBDBE0D8AADE4050C8', '1', '1', '1'), ('9', '2018-07-04 14:25:45', null, '25662729', '1', '2', '1'), ('10', '2018-07-07 14:45:51', null, '87CE5E6F736FBB35D6EC6C191091205D', '1', '1', '29'), ('11', '2018-07-16 15:12:26', null, '15256C24EFB842F52B9FF12C923D1C63', '1', '1', '35'), ('12', '2018-07-17 11:37:11', null, 'F3852979572AF7DF3379F65B8BE67921', '1', '1', '37'), ('13', '2018-07-18 08:52:57', null, '38271392', '1', '2', '38'), ('14', '2018-08-14 10:14:14', null, '19666476', '1', '2', '47'), ('15', '2018-08-17 22:19:29', null, '2293CF0CC64A50324C348E03F5F60874', '1', '1', '48'), ('16', '2018-08-25 18:01:09', null, '856F8F950599E31FEBE09821A07FCC17', '1', '1', '52'), ('17', '2018-09-03 12:49:18', null, '486EBEDF73767886C5C8AD6D39096102', '1', '1', '56'), ('18', '2018-09-03 13:26:42', null, 'F05ABAD5111B0D17CF24AEE46B83572F', '1', '1', '57'), ('19', '2018-09-11 00:00:24', null, '206DA74F9BB45F02A2E778077E5ED984', '1', '1', '59'), ('20', '2018-09-19 11:16:32', null, 'C02BF8D346BE85EEF7928C6FD1C01331', '1', '1', '61'), ('21', '2018-09-19 22:35:58', null, 'F147091C1B75BBB1003605CF863730FF', '1', '1', '62'), ('22', '2018-09-20 19:20:42', null, '4253145', '1', '2', '63'), ('23', '2018-09-21 11:57:49', null, '8840636', '1', '2', '64'), ('24', '2018-09-26 14:21:25', null, 'D20938A8AEE6630CCFD2BD517FFBA2C5', '1', '1', '66'), ('25', '2018-09-27 16:04:15', null, '5A9FC5B29A166742946113CE3354B42C', '1', '1', '67'), ('26', '2018-09-29 14:55:20', null, 'BFE04622A417F2FB7DEF681B4BB5411C', '1', '1', '68'), ('27', '2018-09-29 15:39:28', null, 'B7D9C01114B10E1F803583016E03A5C1', '1', '1', '69'), ('28', '2018-10-03 11:00:28', null, '8FBE18109DC95CDDED943DE8E05DC540', '1', '1', '70'), ('29', '2018-10-11 20:36:38', null, '013193E655F0B827009F8FB3B073FEF1', '1', '1', '77'), ('32', '2018-10-31 13:46:46', null, '3259282', '1', '2', '86'), ('41', '2018-11-09 17:47:10', null, '30073959', '1', '2', '91'), ('42', '2018-11-16 14:33:44', null, '08FE19DDD9863386FFC3DFAE3B21D288', '1', '1', '98'), ('43', '2018-11-18 15:17:09', null, '19279530', '1', '2', '100'), ('44', '2018-11-18 19:48:07', null, '035E5AE504FE740A69EA6D3BF435E184', '1', '1', '101'), ('45', '2018-12-04 15:27:12', null, 'BFA2F821DE5BDA263E7B9AD250A08390', '1', '1', '107'), ('46', '2018-12-05 20:21:01', null, 'C764A87FF06185F1BEE4E81EE6E338A3', '1', '1', '108'), ('47', '2018-12-18 16:20:44', null, '21006495', '1', '2', '93'), ('48', '2018-12-19 19:38:09', null, 'C09FDE38DE0D4AE57CC20A0484DE8606', '1', '1', '22'), ('50', '2018-12-29 14:08:56', null, '32508238', '1', '2', '113'), ('51', '2018-12-31 18:10:38', null, '9D1034ED0194FF551C16F5BBEECAFA24', '1', '1', '114'), ('57', '2019-01-24 11:01:02', null, '86CDF06C86D6FF6A18B7FE68C8FD0409', '1', '1', '123'), ('58', '2019-03-01 12:32:04', null, 'CBC4501093F526E4FA502B73C27DB00C', '1', '1', '111'), ('59', '2019-03-04 14:41:32', null, 'B4CB18B4DEFCDEBFA94F3D2CDF770B6C', '1', '1', '134'), ('60', '2019-03-04 17:20:47', null, 'CDEDCC7719B4BB558FF7C1A4D8248168', '1', '1', '135'), ('61', '2019-03-08 18:03:06', null, 'E476F39BD7A37D45F1B877D53B97B883', '1', '1', '136'), ('62', '2019-03-09 09:01:59', null, '44897084', '1', '2', '136');
COMMIT;

-- ----------------------------
--  Table structure for `bind_type`
-- ----------------------------
DROP TABLE IF EXISTS `bind_type`;
CREATE TABLE `bind_type` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(20) DEFAULT NULL,
  `style` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_mc0u8igslj2oxpmqmge36owa7` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `bind_type`
-- ----------------------------
BEGIN;
INSERT INTO `bind_type` VALUES ('1', 'qq', 'fa fa-qq text-primary'), ('2', 'github', 'fa fa-github text-success');
COMMIT;

-- ----------------------------
--  Table structure for `bookmark`
-- ----------------------------
DROP TABLE IF EXISTS `bookmark`;
CREATE TABLE `bookmark` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `create_time` datetime DEFAULT NULL,
  `article_id` bigint(20) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `bookmark`
-- ----------------------------
BEGIN;
INSERT INTO `bookmark` VALUES ('2', '2018-06-15 16:25:57', '10003', '8'), ('3', '2018-06-18 22:34:50', '10010', '8'), ('4', '2018-06-19 23:26:43', '10013', '11'), ('5', '2018-06-20 10:31:14', '10016', '1'), ('6', '2018-06-20 11:40:50', '10003', '1');
COMMIT;

-- ----------------------------
--  Table structure for `bulletin`
-- ----------------------------
DROP TABLE IF EXISTS `bulletin`;
CREATE TABLE `bulletin` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` longtext NOT NULL,
  `create_time` datetime DEFAULT NULL,
  `guid` varchar(255) DEFAULT NULL,
  `is_sticky` int(11) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `position` int(11) DEFAULT NULL,
  `status` varchar(255) DEFAULT NULL,
  `title` varchar(200) NOT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `bulletin`
-- ----------------------------
BEGIN;
INSERT INTO `bulletin` VALUES ('1', '<h1>使用协议</h1><p>特别提示：您只有无条件接受以下所有服务条款，才能申请CoderGroup及旗下网站和软件（以下简称CoderGroup）的注册帐号。我们会坚定不移的实施保护我们用户隐私的措施。本隐私政策适用於您与CoderGroup的交互行为以及您登记和使用CoderGroup的在线服务。除了在本隐私政策和服务条款以及其 他公布的准则的规定的情况下，我们不会公布与用户个人身份有关的资料。请注意CoderGroup不时地会检查其隐私措施，因此有关的措施会随之变化。我们恳请您定期光顾 本页以确保对我们隐私政策最新版本始终保持了解。在阅读完本政策之後，如果您对CoderGroup的隐私措施有进一步的问题，请与admin@codergroup.cn 联系。</p><p><br></p><h2>接受条款</h2><p>CoderGroup系列产品根据以下服务条款为您提供服务。这些条款可由CoderGroup随时更新，且毋须另行通知。您在使用CoderGroup系列产品提供的各项服务之前，应仔细阅读本使用协议。如您不同意本使用协议及/或随时对其的修改，请您立即停止使用CoderGroup所提供的全部服务；您一旦使用CoderGroup系列产品，即视为您已了解并完全同意本使用协议各项内容，包括CoderGroup对使用协议随时所做的任何修改，并成为CoderGroup用户（以下简称“用户”）。</p><h2>服务说明</h2><p>1）因技术故障或其它不可抗力导致长时间无法正常服务时，不承担任何赔偿责任，CoderGroup系列产品保留不经事先通知为维修保养、升级或其它目的暂停任何部分的权利；</p><p>2）除非本使用协议另有其它明示规定，增加或强化目前本服务的任何新功能，包括所推出的新产品，均受到本使用协议之规范。</p><h2>账号说明及安全</h2><p>用户有义务保证密码和帐号的安全，用户利用该密码和帐号所进行的一切活动引起的任何损失或损害，由用户自行承担全部责任，CoderGroup不承担任何责任。如用户发现帐号遭到未授权的使用或发生其他任何安全问题，应立即修改帐号密码并妥善保管，如有必要，请通知CoderGroup。因黑客行为或用户的保管疏忽导致帐号非法使用，CoderGroup不承担任何责任。</p><h2>隐私声明</h2><p>CoderGroup非常重视对用户隐私权的保护，CoderGroup承诺不会在任何情况下擅自将用户的个人资料即注册信息以任何方式提供给其他个人或组织</p><h2>用户行为</h2><p>用户对其自行发表、上传或传送的内容负全部责任，所有用户不得在CoderGroup任何页面发布、转载、传送含有下列内容之一的信息，否则CoderGroup有权自行处理并不通知用户：</p><p>1) 违反宪法确定的基本原则的；</p><p>2) 危害国家安全，泄漏国家机密，颠覆国家政权，破坏国家统一的；</p><p>3) 损害国家荣誉和利益的；</p><p>4) 煽动民族仇恨、民族歧视，破坏民族团结的；</p><p>5) 破坏国家宗教政策，宣扬邪教和封建迷信的；</p><p>6) 散布谣言，扰乱社会秩序，破坏社会稳定的；</p><p>7) 散布淫秽、色情、赌博、暴力、恐怖或者教唆犯罪的；</p><p>8) 侮辱或者诽谤他人，侵害他人合法权益的；</p><p>9) 煽动非法集会、结社、游行、示威、聚众扰乱社会秩序的；</p><p>10) 以非法民间组织名义活动的；</p><p>11) 含有法律、行政法规禁止的其他内容的。</p><h2>责任赔偿</h2><p>由于您通过本服务提供、发布或传送之内容、您与本服务连线、您违反本使用协议、或您侵害他人任何权利因而衍生或导致任何第三人提出任何索赔或请求，包括合理的律师费，您同意赔偿CoderGroup及其子公司、关联企业、高级职员、代理人、品牌共有人或其它合作伙伴及员工，并使其免受损害，并承担由此引发的全部法律责任。</p><h2>责任声明</h2><p>1）用户明确同意其使用CoderGroup服务所存在的风险及一切后果将完全由用户本人承担，CoderGroup对此不承担任何责任。</p><p>2）CoderGroup无法保证服务一定能满足用户的要求，也不保证服务的及时性、安全性、准确性。</p><p>3）对于因不可抗力或CoderGroup不能控制的原因造成的服务中断或其它缺陷，CoderGroup不承担任何责任，但将尽力减少因此而给用户造成的损失和影响。</p><p>4）CoderGroup有权于任何时间暂时或永久修改或终止本服务(或其任何部分)，而无论其通知与否，CoderGroup对用户和任何第三人均无需承担任何责任。</p><h2>责任声明</h2><p>1）本协议的订立、执行和解释及争议的解决均应适用中华人民共和国法律。</p><p>2）如本协议中的任何条款无论因何种原因完全或部分无效或不具有执行力，本协议的其余条款仍应有效并且有约束力。</p><p>3）本协议解释权及修订权归CoderGroup团队所有。</p>', '2018-06-14 02:59:03', '/bulletins/uprotocol', '0', 'uprotocol', '1', 'publish', '用户协议', '1'), ('2', '<p><b>文章</b>\n</p><ul><li>1、每发布一篇文章：可获得10分；</li><li>2、每评论一次文章：可获得2分；\n</li><li>3、博主的文章被赞一次：可获得5分;</li><li>4、博主的文章被收藏一次：可获得5分;</li><li>5、博主的文章被评论一次：可获得2分;</li></ul><p>\n</p><p><b>问答</b></p><ul><li>1、每提出一个问题：可获得2分；</li><li>2、每回答一个问题：可获得3分；</li><li>3、回答被采纳：可获得5分；</li><li>4、回答被投票：顶1票+1分，踩1票-1分</li></ul><p>\n</p><p>\n</p><p><span style=\\\"color: rgb(227, 55, 55);\\\">温馨提示：鼓励大家多发文章，回答问题，积极互动。</span></p><p><span style=\\\"color: rgb(227, 55, 55);\\\">对于恶意刷分者，我们将扣除其相应的得分，情节严重的，将予以警告。</span></p>', '2018-06-14 03:03:37', '/bulletins/reputation-explanation', '0', 'reputation-explanation', '1', 'publish', '用户积分(声望)说明', '1'), ('4', '<p>本站源码出售，可当毕业设计，也可以当博客系统项目学习</p><p>本站基于 SpringBoot + SpringData JPA +Thymeleaf 实现，MySQL数据库。</p><p>引入Spring Security作为权限框架，Redis 作为部分缓存。</p><p>前端采用 BootStrap + jQuery 实现。</p><p><br></p><p>需要的朋友可以联系博主：847064370 (微信同号)</p><p>价格可以谈</p><p><br></p><h2><b>提供服务</b></h2><p>1.本系统所有源码和数据库文件（通过GitHub私有仓库方式拉人或直接发送zip包代码文件）</p><p>2.远程调试运行部署</p><p>3.需要服务器部署也可以援助</p><p>4.不懂的地方提供讲解</p><p>5.提出Bug，博主会进行修改</p><p>6.提出改造建议，博主会考虑采纳并修改</p><p><br></p><h2><b>适合用户</b></h2><p>1.做毕设的同学，该项目五脏俱全，如果做博客、论坛类项目可以直接拿来用，或者删减一些不必要的功能。</p><p>2.做个人网站的朋友，可以保留前端页面，如果你有自己的前端模板，也可以很方面的进行修改，无需修改后端代码。</p><p>3.学习SpringBoot的同学，可以学习到整个网站的结构，每个模块怎么实现</p>', '2019-05-06 19:49:02', '/bulletins/sell', '1', 'sell', '100', 'publish', '本站源码出售', '1');
COMMIT;

-- ----------------------------
--  Table structure for `cai`
-- ----------------------------
DROP TABLE IF EXISTS `cai`;
CREATE TABLE `cai` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `create_time` datetime DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=63 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `cai`
-- ----------------------------
BEGIN;
INSERT INTO `cai` VALUES ('1', '2018-06-15 15:56:59', '8'), ('2', '2018-06-15 15:57:01', '8'), ('3', '2018-06-15 15:57:04', '8'), ('4', '2018-06-18 22:38:47', '8'), ('5', '2018-06-18 22:38:49', '8'), ('6', '2018-06-18 22:39:18', '1'), ('7', '2018-06-20 20:07:49', '17'), ('8', '2018-06-20 20:07:51', '17'), ('9', '2018-07-06 10:21:50', '7'), ('10', '2018-08-24 11:24:42', '51'), ('11', '2018-10-10 13:06:07', '71'), ('12', '2018-10-10 13:06:12', '71'), ('13', '2018-10-10 13:06:12', '71'), ('14', '2018-10-10 13:06:30', '71'), ('15', '2018-10-10 14:28:51', '71'), ('16', '2018-10-12 14:07:07', '75'), ('17', '2018-10-30 17:08:14', '71'), ('18', '2018-10-30 17:08:18', '71'), ('19', '2018-11-04 00:25:51', '71'), ('20', '2018-11-04 12:52:25', '71'), ('21', '2018-11-04 12:52:26', '71'), ('22', '2018-11-04 12:52:28', '71'), ('23', '2018-11-04 12:52:30', '71'), ('24', '2018-11-04 12:53:50', '71'), ('25', '2018-11-04 12:53:51', '71'), ('26', '2018-11-04 12:53:53', '71'), ('27', '2018-11-04 15:53:06', '71'), ('28', '2018-11-05 17:15:56', '75'), ('29', '2018-11-05 19:31:59', '71'), ('30', '2018-11-05 21:01:15', '75'), ('31', '2018-11-05 21:01:20', '75'), ('32', '2018-11-05 21:04:21', '75'), ('33', '2018-11-05 21:04:31', '75'), ('34', '2018-11-05 21:04:32', '75'), ('35', '2018-11-05 21:04:33', '75'), ('36', '2018-11-05 22:00:06', '71'), ('37', '2018-11-10 20:46:00', '71'), ('38', '2018-11-18 21:31:24', '101'), ('39', '2018-11-24 20:26:27', '104'), ('40', '2018-12-31 18:11:09', '114'), ('41', '2018-12-31 18:11:11', '114'), ('42', '2018-12-31 18:11:12', '114'), ('43', '2019-01-08 13:51:18', '115'), ('44', '2019-01-08 13:51:19', '115'), ('45', '2019-01-08 13:51:20', '115'), ('46', '2019-01-08 13:51:24', '115'), ('47', '2019-01-28 13:59:13', '93'), ('48', '2019-01-28 13:59:14', '93'), ('49', '2019-01-28 13:59:14', '93'), ('50', '2019-01-28 13:59:15', '93'), ('51', '2019-01-28 13:59:17', '93'), ('52', '2019-03-15 16:14:47', '136'), ('53', '2019-03-15 16:14:51', '136'), ('54', '2019-03-21 07:59:44', '113'), ('55', '2019-03-21 15:08:46', '111'), ('56', '2019-03-26 18:42:55', '115'), ('57', '2019-03-30 21:08:55', '113'), ('58', '2019-04-02 09:27:39', '113'), ('59', '2019-04-02 09:27:40', '113'), ('61', '2019-04-02 09:27:53', '113'), ('62', '2019-04-04 09:56:03', '113');
COMMIT;

-- ----------------------------
--  Table structure for `category`
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `guid` varchar(255) DEFAULT NULL,
  `is_hidden` varchar(1) DEFAULT NULL,
  `name` varchar(20) NOT NULL,
  `position` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=10080 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `category`
-- ----------------------------
BEGIN;
INSERT INTO `category` VALUES ('10000', '/saysky/articles?category=10000', 'N', '诗歌', '1', '1'), ('10001', '/saysky/articles?category=10001', 'N', '面试', '2', '1'), ('10002', '/qiqi/articles?category=10002', 'N', 'love', '1', '8'), ('10003', '/saysky/articles?category=10003', 'N', 'JavaWeb', '3', '1'), ('10004', '/saysky/articles?category=10004', 'N', '数据库', '4', '1'), ('10005', '/xinyue/articles?category=10005', 'N', 'ceshi', '1', '10'), ('10006', '/saysky/articles?category=10006', 'N', 'Java', '5', '1'), ('10007', '/saysky/articles?category=10007', 'N', '数据结构', '6', '1'), ('10008', '/saysky/articles?category=10008', 'N', 'Java并发编程', '7', '1'), ('10009', '/saysky/articles?category=10009', 'N', '计算机网络', '8', '1'), ('10010', '/saysky/articles?category=10010', 'N', '其他', '9', '1'), ('10011', '/l1012384/articles?category=10011', 'N', '20180501', '1', '23'), ('10012', '/sunny/articles?category=10012', 'N', 'Java', '1', '26'), ('10013', '/saysky/articles?category=10013', 'N', '算法', '10', '1'), ('10014', '/ai211932/articles?category=10014', 'N', '日常记录', '1', '7'), ('10015', '/HickSalmon/articles?category=10015', 'N', 'Ubuntu16.04', '1', '9'), ('10016', '/saysky/articles?category=10016', 'N', 'JVM', '11', '1'), ('10017', '/admin1/articles?category=10017', 'N', 'd\'s', '1', '31'), ('10018', '/ai211932/articles?category=10018', 'N', 'springboot学习之路', '2', '7'), ('10019', '/poker/articles?category=10019', 'N', '101', '1', '33'), ('10020', '/saysky/articles?category=10020', 'N', '个人情感', '12', '1'), ('10021', '/saysky/articles?category=10021', 'N', 'saysky', '13', '1'), ('10022', '/qiqi/articles?category=10022', 'N', 'python', '2', '8'), ('10023', '/ai211932/articles?category=10023', 'N', '日常总结', '3', '7'), ('10024', '/chree/articles?category=10024', 'N', '123', '1', '47'), ('10025', '/wangbing1991/articles?category=10025', 'N', 'test', '1', '48'), ('10026', '/codegroup/articles?category=10026', 'N', 'Java', '1', '54'), ('10027', '/yitiao/articles?category=10027', 'N', '123', '1', '51'), ('10028', '/yitiao/articles?category=10028', 'N', '456', '2', '51'), ('10029', '/sunweijia/articles?category=10029', 'N', 'javac', '1', '71'), ('10031', '/qwertyuiop/articles?category=10031', 'N', '测试数据', '1', '82'), ('10035', '/sunweijia/articles?category=10035', 'N', '撒旦法', '2', '71'), ('10036', '/sunweijia/articles?category=10036', 'N', '不心腹大患樊', '3', '71'), ('10037', '/sunweijia/articles?category=10037', 'N', '是大法官', '4', '71'), ('10038', '/sunweijia/articles?category=10038', 'N', '哈哈', '5', '71'), ('10039', '/sunweijia/articles?category=10039', 'N', '匹配', '6', '71'), ('10040', '/sunweijia/articles?category=10040', 'N', 'china', '7', '71'), ('10041', '/Albert/articles?category=10041', 'N', 'Albert', '1', '94'), ('10042', '/test1/articles?category=10042', 'N', 'wenzhang', '1', '77'), ('10043', '/chenzi/articles?category=10043', 'N', 'ddd', '1', '96'), ('10044', '/Zachary/articles?category=10044', 'N', 'java', '1', '93'), ('10045', '/Lewis/articles?category=10045', 'N', 'Spring', '1', '70'), ('10046', '/Lewis/articles?category=10046', 'N', 'SpringBoot', '2', '70'), ('10047', '/Lewis/articles?category=10047', 'N', 'Java', '3', '70'), ('10048', '/tvb1/articles?category=10048', 'N', '心情', '1', '97'), ('10049', '/mmma/articles?category=10049', 'N', '撒旦', '1', '101'), ('10050', '/Webb_Chen/articles?category=10050', 'N', 'test', '1', '100'), ('10051', '/Webb_Chen/articles?category=10051', 'N', '测试', '2', '100'), ('10052', '/jlb0906/articles?category=10052', 'N', '123', '1', '102'), ('10053', '/tiger/articles?category=10053', 'N', 'test', '1', '109'), ('10054', '/fans/articles?category=10054', 'N', '1', '1', '111'), ('10055', '/qwe86314/articles?category=10055', 'N', 'js', '1', '113'), ('10056', '/ME_Pu/articles?category=10056', 'N', 'java', '1', '25'), ('10057', '/ME_Pu/articles?category=10057', 'N', '默认分类', '2', '25'), ('10058', '/Empirefree/articles?category=10058', 'N', 'Empirefree', '2', '115'), ('10059', '/Empirefree/articles?category=10059', 'N', '阿斯蒂芬', '1', '115'), ('10060', '/Empirefree/articles?category=10060', 'N', '大师傅', '3', '115'), ('10061', '/achi/articles?category=10061', 'N', '因垂丝汀', '1', '59'), ('10062', '/Hhc0917/articles?category=10062', 'N', 'ceshi', '1', '120'), ('10063', '/gszdc/articles?category=10063', 'N', 'aerors', '1', '122'), ('10065', '/fans/articles?category=10065', 'N', 'myself', '2', '111'), ('10066', '/qwe86314/articles?category=10066', 'N', '9999', '2', '113'), ('10068', '/fantasy/articles?category=10068', 'N', 'test', '1', '139'), ('10069', '/qbian/articles?category=10069', 'N', 'test', '1', '140'), ('10070', '/Forever/articles?category=10070', 'N', '1', '1', '129'), ('10071', '/2530047598/articles?category=10071', 'N', '测试', '1', '136'), ('10078', '/wangwei/articles?category=10078', 'N', 'Java', '1', '153'), ('10079', '/saysky/articles?category=10079', 'N', '商品', '14', '1');
COMMIT;

-- ----------------------------
--  Table structure for `comment`
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `cai_size` int(11) DEFAULT NULL,
  `content` varchar(10000) NOT NULL,
  `create_time` datetime DEFAULT NULL,
  `floor` int(11) DEFAULT NULL,
  `is_sticky` int(11) DEFAULT NULL,
  `pid` bigint(20) DEFAULT NULL,
  `status` varchar(255) DEFAULT NULL,
  `zan_size` int(11) DEFAULT NULL,
  `article_id` bigint(20) DEFAULT NULL,
  `reply_user_id` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=87 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `comment`
-- ----------------------------
BEGIN;
INSERT INTO `comment` VALUES ('1', '0', '姐姐姐姐', '2018-06-14 21:32:23', '1', '0', null, 'publish', '0', '10002', '1', '1'), ('2', '0', '这个用户评论昵称链接忘了改，点击会404，晚上夜深人静再改', '2018-06-15 14:53:47', '2', '0', null, 'publish', '0', '10002', '1', '1'), ('3', '0', '（￣▽￣）', '2018-06-15 14:55:58', '3', '0', null, 'publish', '1', '10002', '1', '7'), ('4', '0', '好棒棒', '2018-06-15 15:55:52', '4', '0', null, 'publish', '1', '10002', '1', '8'), ('5', '1', '啦啦啦', '2018-06-15 15:56:53', '5', '0', null, 'publish', '1', '10002', '1', '8'), ('6', '0', '(⌒▽⌒)', '2018-06-15 16:04:49', '1', '0', null, 'publish', '0', '10003', '8', '1'), ('7', '0', '(⌒▽⌒)', '2018-06-15 16:05:29', '2', '0', null, 'publish', '0', '10003', '8', '8'), ('8', '0', 'test', '2018-06-15 16:15:07', '3', '0', null, 'publish', '0', '10003', '8', '1'), ('9', '0', '出bug啦', '2018-06-15 16:24:10', '6', '0', null, 'publish', '0', '10002', '1', '8'), ('10', '0', '出问题啦', '2018-06-15 16:26:13', '1', '0', null, 'publish', '0', '10001', '1', '8'), ('11', '0', '文明评论。。。。。。', '2018-06-17 20:48:04', '4', '0', null, 'publish', '0', '10003', '8', '9'), ('12', '1', '加油', '2018-06-18 22:35:00', '1', '0', null, 'publish', '1', '10010', '1', '8'), ('13', '0', '谢谢老婆', '2018-06-18 22:37:17', null, '0', '12', 'publish', '1', '10010', '8', '1'), ('14', '0', '(⌒▽⌒)', '2018-06-18 22:39:12', '2', '0', null, 'publish', '0', '10010', '1', '8'), ('15', '0', '感谢分享哈 谢谢', '2018-06-20 10:58:28', '1', '0', null, 'publish', '0', '10017', '1', '15'), ('16', '0', '啦啦啦', '2018-06-20 11:41:17', '5', '0', null, 'publish', '0', '10003', '8', '8'), ('17', '0', 'dd', '2018-06-20 20:07:40', '1', '0', null, 'publish', '0', '10009', '1', '17'), ('19', '0', 'dd', '2018-06-20 20:08:01', null, '0', '17', 'publish', '1', '10009', '17', '17'), ('20', '0', '(⌒▽⌒)', '2018-06-21 00:19:25', '1', '0', null, 'publish', '0', '10018', '1', '16'), ('21', '0', '(･∀･)', '2018-06-24 17:02:16', '1', '0', null, 'publish', '0', '10031', '1', '1'), ('22', '0', '文章详情页打开感觉可以新开一个界面挺好，可能是个人习惯问题。。。。。。。。。', '2018-06-26 11:26:03', '1', '0', null, 'publish', '0', '10033', '1', '17'), ('23', '0', '很好的建议！', '2018-06-26 23:54:43', null, '0', '22', 'publish', '0', '10033', '17', '1'), ('24', '0', '楼主好好面试!带小弟飞', '2018-07-06 09:34:56', '1', '0', null, 'publish', '0', '10040', '1', '7'), ('29', '0', '(\"▔□▔)/', '2018-08-10 11:27:41', '7', '0', null, 'publish', '0', '10002', '1', '41'), ('46', '0', '测试评论(⌒▽⌒)', '2018-09-20 21:32:35', '1', '0', null, 'publish', '0', '10035', '23', '63'), ('47', '0', '嗯嗯 测试', '2018-09-20 21:32:51', null, '0', '46', 'publish', '0', '10035', '63', '63'), ('72', '0', '(￣3￣)', '2019-01-01 10:53:57', '2', '0', null, 'publish', '0', '10004', '1', '113'), ('86', '0', '6666666牛逼', '2019-03-08 16:55:53', '1', '0', null, 'publish', '0', '10045', '1', '113');
COMMIT;

-- ----------------------------
--  Table structure for `comment_cai`
-- ----------------------------
DROP TABLE IF EXISTS `comment_cai`;
CREATE TABLE `comment_cai` (
  `comment_id` bigint(20) NOT NULL,
  `cai_id` bigint(20) NOT NULL,
  UNIQUE KEY `UK_c3bitmqg2fgcktae238xlf28k` (`cai_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `comment_cai`
-- ----------------------------
BEGIN;
INSERT INTO `comment_cai` VALUES ('5', '1'), ('12', '5'), ('50', '17'), ('51', '18'), ('53', '27');
COMMIT;

-- ----------------------------
--  Table structure for `comment_zan`
-- ----------------------------
DROP TABLE IF EXISTS `comment_zan`;
CREATE TABLE `comment_zan` (
  `comment_id` bigint(20) NOT NULL,
  `zan_id` bigint(20) NOT NULL,
  UNIQUE KEY `UK_qph99kuqwhept3uff6iockfbg` (`zan_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `comment_zan`
-- ----------------------------
BEGIN;
INSERT INTO `comment_zan` VALUES ('5', '3'), ('4', '4'), ('3', '6'), ('12', '10'), ('13', '11'), ('19', '21'), ('25', '27'), ('32', '34'), ('53', '61'), ('50', '63'), ('51', '64'), ('57', '69'), ('53', '75'), ('65', '97'), ('64', '98'), ('78', '117'), ('84', '131'), ('85', '132'), ('89', '133'), ('83', '135'), ('92', '137');
COMMIT;

-- ----------------------------
--  Table structure for `job`
-- ----------------------------
DROP TABLE IF EXISTS `job`;
CREATE TABLE `job` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(20) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_atcl7ldp04r846fq0cep4e3wi` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `job`
-- ----------------------------
BEGIN;
INSERT INTO `job` VALUES ('15', 'CG影视动画师'), ('3', 'Java工程师'), ('5', 'JS工程师'), ('9', 'Linux系统工程师'), ('4', 'PHP工程师'), ('7', 'Phython工程师'), ('12', 'UI设计师'), ('6', 'WEB前端工程师'), ('10', '交互设计师'), ('17', '产品经理'), ('14', '全栈工程师'), ('19', '其他'), ('2', '学生'), ('16', '数据库工程师'), ('1', '未设置'), ('8', '移动开发工程师'), ('13', '算法工程师'), ('11', '软件测试工程师'), ('18', '页面重构设计');
COMMIT;

-- ----------------------------
--  Table structure for `login_record`
-- ----------------------------
DROP TABLE IF EXISTS `login_record`;
CREATE TABLE `login_record` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `area` varchar(100) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `ip` varchar(40) DEFAULT NULL,
  `login_type` varchar(255) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=256 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `login_record`
-- ----------------------------
BEGIN;
INSERT INTO `login_record` VALUES ('1', '山东省青岛市 移动', '2018-06-14 03:01:28', '223.104.170.150', 'qq授权登录', '1'), ('2', '江西省 移动', '2018-06-14 09:17:22', '39.176.195.33', '账号密码登录', '1'), ('3', '江西省 移动', '2018-06-14 10:45:08', '39.176.195.33', 'qq授权登录', '1'), ('4', '江西省 移动', '2018-06-14 11:00:50', '39.176.195.33', '账号密码登录', '1'), ('5', '江西省 移动', '2018-06-14 14:35:41', '39.176.195.3', '账号密码登录', '1'), ('6', '江西省 移动', '2018-06-14 14:48:33', '39.176.195.3', '账号密码登录', '2'), ('7', '江西省 移动', '2018-06-14 19:15:08', '39.176.195.253', '账号密码登录', '1'), ('8', '山东省青岛市 移动', '2018-06-14 21:23:59', '223.104.170.196', 'qq授权登录', '1'), ('9', '山东省青岛市 移动', '2018-06-15 01:35:29', '223.104.170.196', 'qq授权登录', '1'), ('10', '江西省南昌市 江西师范大学', '2018-06-15 10:08:18', '219.229.250.59', '账号密码登录', '1'), ('11', '江西省南昌市 移动', '2018-06-15 14:44:30', '223.104.10.231', '账号密码登录', '1'), ('12', '山东省青岛市 移动', '2018-06-15 14:44:32', '223.104.170.135', '账号密码登录', '7'), ('13', '江西省南昌市 移动', '2018-06-15 14:47:01', '223.104.10.231', '账号密码登录', '1'), ('14', '山东省青岛市 移动', '2018-06-15 14:47:02', '223.104.170.135', '账号密码登录', '7'), ('15', '江西省南昌市 电信', '2018-06-15 15:39:28', '182.97.50.219', '账号密码登录', '8'), ('16', '江西省 移动', '2018-06-15 17:09:29', '39.176.195.216', 'qq授权登录', '1'), ('17', '江西省 移动', '2018-06-15 20:03:45', '39.176.195.216', 'qq授权登录', '1'), ('18', '江西省赣州市 移动', '2018-06-17 09:09:14', '39.168.133.228', '账号密码登录', '1'), ('19', 'IANA 保留地址用于本地回送', '2018-06-19 21:41:39', '127.0.0.1', 'qq授权登录', '8'), ('20', 'IANA 保留地址用于本地回送', '2018-06-19 23:19:48', '127.0.0.1', '账号密码登录', '11'), ('21', 'IANA 保留地址用于本地回送', '2018-06-20 10:56:34', '127.0.0.1', '账号密码登录', '15'), ('22', 'IANA 保留地址用于本地回送', '2018-06-20 11:40:33', '127.0.0.1', 'qq授权登录', '8'), ('23', 'IANA 保留地址用于本地回送', '2018-06-20 20:05:38', '127.0.0.1', '账号密码登录', '17'), ('24', 'IANA 保留地址用于本地回送', '2018-06-22 09:04:50', '127.0.0.1', '账号密码登录', '1'), ('25', '广东省广州市 腾讯云', '2018-06-22 19:04:24', '111.230.202.204', '账号密码登录', '1'), ('26', '广东省广州市 腾讯云', '2018-06-24 20:35:04', '111.230.202.204', '账号密码登录', '1'), ('27', '广东省广州市 腾讯云', '2018-06-24 20:36:16', '111.230.202.204', '账号密码登录', '1'), ('28', '广东省广州市 腾讯云', '2018-06-26 11:25:02', '111.230.202.204', '账号密码登录', '17'), ('29', '广东省广州市 腾讯云', '2018-06-26 20:27:54', '111.230.202.204', '账号密码登录', '17'), ('30', '广东省广州市 腾讯云', '2018-06-26 23:04:30', '111.230.202.204', '账号密码登录', '1'), ('31', '广东省广州市 腾讯云', '2018-06-27 21:07:35', '111.230.202.204', '账号密码登录', '22'), ('32', '广东省广州市 腾讯云', '2018-07-03 21:06:00', '111.230.202.204', '账号密码登录', '24'), ('33', '广东省广州市 腾讯云', '2018-07-03 21:29:14', '111.230.202.204', '账号密码登录', '25'), ('34', '广东省广州市 腾讯云', '2018-07-04 10:53:22', '111.230.202.204', '账号密码登录', '1'), ('35', '广东省广州市 腾讯云', '2018-07-06 09:30:52', '111.230.202.204', '账号密码登录', '7'), ('36', '广东省广州市 腾讯云', '2018-07-06 15:20:53', '111.230.202.204', '账号密码登录', '9'), ('37', '广东省广州市 腾讯云', '2018-07-06 15:22:04', '111.230.202.204', '账号密码登录', '9'), ('38', '广东省广州市 腾讯云', '2018-07-06 15:25:19', '111.230.202.204', 'qq授权登录', '1'), ('39', '广东省广州市 腾讯云', '2018-07-07 17:50:29', '111.230.202.204', 'qq授权登录', '1'), ('40', '广东省广州市 腾讯云', '2018-07-07 17:57:25', '111.230.202.204', '账号密码登录', '7'), ('41', '广东省广州市 腾讯云', '2018-07-07 18:06:09', '111.230.202.204', 'qq授权登录', '1'), ('42', '广东省广州市 腾讯云', '2018-07-08 12:48:07', '111.230.202.204', 'qq授权登录', '1'), ('43', '广东省广州市 腾讯云', '2018-07-08 12:58:05', '111.230.202.204', 'qq授权登录', '1'), ('44', '山东省青岛市 移动', '2018-07-08 22:30:39', '223.104.170.249', '账号密码登录', '7'), ('45', '广东省广州市 腾讯云', '2018-07-11 22:00:53', '111.230.202.204', '账号密码登录', '32'), ('46', '广东省广州市 腾讯云', '2018-07-11 22:38:59', '111.230.202.204', 'qq授权登录', '1'), ('47', '广东省广州市 腾讯云', '2018-07-14 00:17:22', '111.230.202.204', 'qq授权登录', '1'), ('48', '广东省广州市 腾讯云', '2018-07-15 15:13:09', '111.230.202.204', 'qq授权登录', '1'), ('49', '广东省广州市 腾讯云', '2018-07-16 13:42:56', '111.230.202.204', 'qq授权登录', '1'), ('50', '广东省广州市 腾讯云', '2018-07-18 17:46:19', '111.230.202.204', 'qq授权登录', '1'), ('51', '广东省广州市 腾讯云', '2018-07-19 10:22:28', '111.230.202.204', '账号密码登录', '40'), ('52', '广东省广州市 腾讯云', '2018-07-19 14:43:27', '111.230.202.204', 'qq授权登录', '8'), ('53', '广东省广州市 腾讯云', '2018-07-20 16:40:20', '111.230.202.204', '账号密码登录', '7'), ('54', '广东省广州市 腾讯云', '2018-07-26 10:25:05', '111.230.202.204', '账号密码登录', '11'), ('55', '广东省广州市 腾讯云', '2018-07-30 19:11:12', '111.230.202.204', '账号密码登录', '41'), ('56', '广东省广州市 腾讯云', '2018-08-03 21:47:36', '111.230.202.204', '账号密码登录', '17'), ('57', '广东省广州市 腾讯云', '2018-08-04 11:19:30', '111.230.202.204', '账号密码登录', '22'), ('58', '广东省广州市 腾讯云', '2018-08-06 23:54:00', '111.230.202.204', '账号密码登录', '24'), ('59', '广东省广州市 腾讯云', '2018-08-06 23:54:24', '111.230.202.204', '账号密码登录', '24'), ('60', '广东省广州市 腾讯云', '2018-08-07 14:31:19', '111.230.202.204', '账号密码登录', '45'), ('61', '广东省广州市 腾讯云', '2018-08-08 12:15:31', '111.230.202.204', 'qq授权登录', '1'), ('62', '广东省广州市 腾讯云', '2018-08-09 16:53:25', '111.230.202.204', 'qq授权登录', '1'), ('63', '广东省广州市 腾讯云', '2018-08-15 10:54:23', '111.230.202.204', '账号密码登录', '7'), ('64', '广东省广州市 腾讯云', '2018-08-17 22:20:27', '111.230.202.204', '账号密码登录', '48'), ('65', '广东省广州市 腾讯云', '2018-08-24 11:33:58', '111.230.202.204', '账号密码登录', '51'), ('66', '广东省广州市 腾讯云', '2018-08-24 11:34:53', '111.230.202.204', '账号密码登录', '51'), ('67', '广东省广州市 腾讯云', '2018-08-24 11:35:11', '111.230.202.204', '账号密码登录', '51'), ('68', '广东省广州市 腾讯云', '2018-08-24 16:01:41', '111.230.202.204', '账号密码登录', '51'), ('69', '广东省广州市 腾讯云', '2018-08-27 20:37:10', '111.230.202.204', '账号密码登录', '53'), ('70', '山西省太原市 电信', '2018-08-27 21:00:23', '1.68.2.20', '账号密码登录', '53'), ('71', '广东省广州市 腾讯云', '2018-08-28 09:18:53', '111.230.202.204', '账号密码登录', '51'), ('72', '广东省广州市 腾讯云', '2018-08-29 15:08:58', '111.230.202.204', '账号密码登录', '51'), ('73', '广东省广州市 腾讯云', '2018-08-29 17:32:24', '111.230.202.204', '账号密码登录', '7'), ('74', '广东省广州市 腾讯云', '2018-08-30 23:21:09', '111.230.202.204', '账号密码登录', '54'), ('75', '广东省广州市 腾讯云', '2018-08-31 13:45:13', '111.230.202.204', 'qq授权登录', '1'), ('76', '广东省广州市 腾讯云', '2018-08-31 15:17:50', '111.230.202.204', '账号密码登录', '54'), ('77', '广东省广州市 腾讯云', '2018-08-31 15:19:39', '111.230.202.204', '账号密码登录', '55'), ('78', '广东省广州市 腾讯云', '2018-08-31 16:04:19', '111.230.202.204', '账号密码登录', '55'), ('79', '广东省广州市 腾讯云', '2018-09-04 14:22:20', '111.230.202.204', '账号密码登录', '51'), ('80', '广东省广州市 腾讯云', '2018-09-04 21:12:27', '111.230.202.204', '账号密码登录', '51'), ('81', '广东省广州市 腾讯云', '2018-09-04 21:13:11', '111.230.202.204', '账号密码登录', '51'), ('82', '广东省广州市 腾讯云', '2018-09-04 21:45:12', '111.230.202.204', '账号密码登录', '7'), ('83', '广东省广州市 腾讯云', '2018-09-05 08:47:06', '111.230.202.204', '账号密码登录', '51'), ('84', '广东省广州市 腾讯云', '2018-09-05 08:48:15', '111.230.202.204', '账号密码登录', '51'), ('85', '广东省广州市 腾讯云', '2018-09-05 10:45:33', '111.230.202.204', '账号密码登录', '51'), ('86', '广东省广州市 腾讯云', '2018-09-05 16:50:59', '111.230.202.204', '账号密码登录', '51'), ('87', '广东省广州市 腾讯云', '2018-09-06 11:37:42', '111.230.202.204', '账号密码登录', '51'), ('88', '广东省广州市 腾讯云', '2018-09-09 16:27:40', '111.230.202.204', '账号密码登录', '7'), ('89', '广东省广州市 腾讯云', '2018-09-12 19:04:13', '111.230.202.204', 'qq授权登录', '1'), ('90', '广东省广州市 腾讯云', '2018-09-15 17:45:41', '111.230.202.204', '账号密码登录', '7'), ('91', '广东省广州市 腾讯云', '2018-09-17 20:48:59', '111.230.202.204', 'qq授权登录', '1'), ('92', '广东省广州市 腾讯云', '2018-09-18 09:38:42', '111.230.202.204', '账号密码登录', '51'), ('93', '广东省广州市 腾讯云', '2018-09-20 21:25:15', '111.230.202.204', 'github授权登录', '63'), ('94', '广东省广州市 腾讯云', '2018-09-29 12:31:25', '111.230.202.204', 'qq授权登录', '35'), ('95', '广东省广州市 腾讯云', '2018-09-29 12:32:24', '111.230.202.204', 'qq授权登录', '1'), ('96', '广东省广州市 腾讯云', '2018-09-29 15:40:17', '111.230.202.204', '账号密码登录', '69'), ('97', '广东省广州市 腾讯云', '2018-09-29 16:44:06', '111.230.202.204', 'qq授权登录', '68'), ('98', '广东省广州市 腾讯云', '2018-10-08 16:31:07', '111.230.202.204', 'qq授权登录', '1'), ('99', '广东省广州市 腾讯云', '2018-10-09 21:55:55', '111.230.202.204', 'qq授权登录', '1'), ('100', '广东省广州市 腾讯云', '2018-10-09 21:55:59', '111.230.202.204', 'github授权登录', '1'), ('101', '广东省广州市 腾讯云', '2018-10-09 21:59:20', '111.230.202.204', '账号密码登录', '20'), ('102', '广东省广州市 腾讯云', '2018-10-10 14:28:25', '111.230.202.204', '账号密码登录', '71'), ('103', '广东省广州市 腾讯云', '2018-10-10 19:09:09', '111.230.202.204', '账号密码登录', '72'), ('104', '广东省广州市 腾讯云', '2018-10-10 19:22:48', '111.230.202.204', '账号密码登录', '71'), ('105', '广东省广州市 腾讯云', '2018-10-10 19:25:13', '111.230.202.204', '账号密码登录', '72'), ('106', '广东省广州市 腾讯云', '2018-10-10 20:45:07', '111.230.202.204', '账号密码登录', '75'), ('107', '广东省广州市 腾讯云', '2018-10-11 16:39:39', '111.230.202.204', '账号密码登录', '72'), ('108', '广东省广州市 腾讯云', '2018-10-11 20:39:16', '111.230.202.204', '账号密码登录', '78'), ('109', '广东省广州市 腾讯云', '2018-10-11 20:57:02', '111.230.202.204', '账号密码登录', '77'), ('110', '广东省广州市 腾讯云', '2018-10-12 22:46:35', '111.230.202.204', '账号密码登录', '79'), ('111', '广东省广州市 腾讯云', '2018-10-14 13:59:23', '111.230.202.204', 'qq授权登录', '1'), ('112', '广东省广州市 腾讯云', '2018-10-15 15:32:50', '111.230.202.204', '账号密码登录', '77'), ('113', '广东省广州市 腾讯云', '2018-10-16 17:04:08', '111.230.202.204', '账号密码登录', '75'), ('114', '广东省广州市 腾讯云', '2018-10-18 19:31:45', '111.230.202.204', '账号密码登录', '72'), ('115', '广东省广州市 腾讯云', '2018-10-24 21:58:25', '111.230.202.204', '账号密码登录', '72'), ('116', '广东省广州市 腾讯云', '2018-10-25 15:03:08', '111.230.202.204', '账号密码登录', '71'), ('117', '广东省广州市 腾讯云', '2018-10-26 09:45:06', '111.230.202.204', '账号密码登录', '78'), ('118', '广东省广州市 腾讯云', '2018-10-26 09:45:27', '111.230.202.204', '账号密码登录', '78'), ('119', '广东省广州市 腾讯云', '2018-10-26 09:56:39', '111.230.202.204', '账号密码登录', '78'), ('120', '广东省广州市 腾讯云', '2018-10-27 15:32:38', '111.230.202.204', '账号密码登录', '72'), ('121', '广东省广州市 腾讯云', '2018-10-27 18:05:53', '111.230.202.204', '账号密码登录', '72'), ('122', '广东省广州市 腾讯云', '2018-10-28 13:41:49', '111.230.202.204', '账号密码登录', '82'), ('123', '广东省广州市 腾讯云', '2018-10-30 15:08:10', '111.230.202.204', '账号密码登录', '82'), ('124', '广东省广州市 腾讯云', '2018-10-30 16:00:52', '111.230.202.204', '账号密码登录', '71'), ('125', '广东省广州市 腾讯云', '2018-11-01 18:58:05', '111.230.202.204', '账号密码登录', '75'), ('126', '广东省广州市 腾讯云', '2018-11-02 14:13:41', '111.230.202.204', '账号密码登录', '77'), ('128', '广东省广州市 腾讯云', '2018-11-02 18:34:11', '111.230.202.204', 'qq授权登录', '72'), ('129', '广东省广州市 腾讯云', '2018-11-03 09:56:09', '111.230.202.204', '账号密码登录', '87'), ('130', '广东省广州市 腾讯云', '2018-11-03 15:40:44', '111.230.202.204', '账号密码登录', '87'), ('131', '广东省广州市 腾讯云', '2018-11-03 15:41:03', '111.230.202.204', '账号密码登录', '87'), ('132', '广东省广州市 腾讯云', '2018-11-05 15:55:37', '111.230.202.204', '账号密码登录', '72'), ('133', '广东省广州市 腾讯云', '2018-11-05 17:25:44', '111.230.202.204', '账号密码登录', '71'), ('134', '广东省广州市 腾讯云', '2018-11-05 19:38:55', '111.230.202.204', '账号密码登录', '71'), ('135', '广东省广州市 腾讯云', '2018-11-06 19:35:25', '111.230.202.204', '账号密码登录', '89'), ('136', '广东省广州市 腾讯云', '2018-11-06 19:38:09', '111.230.202.204', '账号密码登录', '88'), ('137', '广东省广州市 腾讯云', '2018-11-06 22:35:04', '111.230.202.204', '账号密码登录', '88'), ('138', '广东省广州市 腾讯云', '2018-11-07 18:17:05', '111.230.202.204', '账号密码登录', '71'), ('139', '广东省广州市 腾讯云', '2018-11-07 20:14:51', '111.230.202.204', '账号密码登录', '71'), ('140', '广东省广州市 腾讯云', '2018-11-07 20:54:42', '111.230.202.204', '账号密码登录', '72'), ('141', '广东省广州市 腾讯云', '2018-11-08 17:17:35', '111.230.202.204', '账号密码登录', '71'), ('142', '广东省广州市 腾讯云', '2018-11-08 22:48:30', '111.230.202.204', '账号密码登录', '71'), ('143', '广东省广州市 腾讯云', '2018-11-09 10:06:21', '111.230.202.204', '账号密码登录', '93'), ('144', '广东省广州市 腾讯云', '2018-11-09 10:07:05', '111.230.202.204', '账号密码登录', '93'), ('145', '广东省广州市 腾讯云', '2018-11-09 10:28:49', '111.230.202.204', 'github授权登录', '91'), ('146', '广东省广州市 腾讯云', '2018-11-09 10:29:23', '111.230.202.204', 'github授权登录', '91'), ('147', '广东省广州市 腾讯云', '2018-11-09 11:50:59', '111.230.202.204', 'github授权登录', '91'), ('148', '广东省广州市 腾讯云', '2018-11-09 14:59:41', '111.230.202.204', '账号密码登录', '75'), ('149', '广东省广州市 腾讯云', '2018-11-09 17:12:16', '111.230.202.204', '账号密码登录', '78'), ('150', '广东省广州市 腾讯云', '2018-11-09 17:17:26', '111.230.202.204', '账号密码登录', '72'), ('151', '广东省广州市 腾讯云', '2018-11-09 17:47:27', '111.230.202.204', 'github授权登录', '91'), ('152', '广东省广州市 腾讯云', '2018-11-09 17:50:23', '111.230.202.204', 'github授权登录', '91'), ('153', '广东省广州市 腾讯云', '2018-11-09 18:31:56', '111.230.202.204', '账号密码登录', '72'), ('154', '广东省广州市 腾讯云', '2018-11-09 21:39:37', '111.230.202.204', '账号密码登录', '72'), ('155', '广东省广州市 腾讯云', '2018-11-09 23:23:38', '111.230.202.204', '账号密码登录', '72'), ('156', '广东省广州市 腾讯云', '2018-11-10 10:31:00', '111.230.202.204', '账号密码登录', '75'), ('157', '北京市丰台区 联通', '2018-11-10 13:13:19', '124.64.16.62', '账号密码登录', '71'), ('158', '广东省广州市 腾讯云', '2018-11-11 15:10:46', '111.230.202.204', 'qq授权登录', '1'), ('159', '广东省广州市 腾讯云', '2018-11-12 14:46:27', '111.230.202.204', '账号密码登录', '92'), ('160', '广东省广州市 腾讯云', '2018-11-12 18:27:04', '111.230.202.204', 'qq授权登录', '67'), ('161', '广东省广州市 腾讯云', '2018-11-12 18:49:53', '111.230.202.204', '账号密码登录', '92'), ('162', '广东省广州市 腾讯云', '2018-11-12 19:00:59', '111.230.202.204', '账号密码登录', '92'), ('163', '广东省广州市 腾讯云', '2018-11-13 18:49:42', '111.230.202.204', 'qq授权登录', '70'), ('164', '广东省广州市 腾讯云', '2018-11-13 19:44:00', '111.230.202.204', 'qq授权登录', '70'), ('165', '广东省广州市 腾讯云', '2018-11-14 13:16:26', '111.230.202.204', 'qq授权登录', '1'), ('166', '广东省广州市 腾讯云', '2018-11-17 10:56:39', '111.230.202.204', '账号密码登录', '25'), ('167', '广东省广州市 腾讯云', '2018-11-18 20:15:31', '111.230.202.204', 'github授权登录', '100'), ('168', '广东省广州市 腾讯云', '2018-11-18 20:19:25', '111.230.202.204', 'github授权登录', '100'), ('169', '广东省广州市 腾讯云', '2018-11-19 07:22:33', '111.230.202.204', 'github授权登录', '100'), ('170', '广东省广州市 腾讯云', '2018-11-19 09:49:57', '111.230.202.204', 'qq授权登录', '101'), ('171', '广东省广州市 腾讯云', '2018-11-20 08:29:55', '111.230.202.204', 'github授权登录', '100'), ('172', '广东省广州市 腾讯云', '2018-11-20 22:37:07', '111.230.202.204', '账号密码登录', '102'), ('173', '广东省广州市 腾讯云', '2018-11-24 13:01:09', '111.230.202.204', 'github授权登录', '100'), ('174', '广东省广州市 腾讯云', '2018-11-30 10:44:56', '111.230.202.204', '账号密码登录', '105'), ('175', '广东省广州市 腾讯云', '2018-12-04 18:13:12', '111.230.202.204', 'qq授权登录', '67'), ('176', '广东省广州市 腾讯云', '2018-12-13 14:04:49', '111.230.202.204', '账号密码登录', '109'), ('177', '广东省广州市 腾讯云', '2018-12-13 14:27:50', '111.230.202.204', '账号密码登录', '109'), ('178', '广东省广州市 腾讯云', '2018-12-14 22:26:09', '111.230.202.204', 'github授权登录', '1'), ('179', '广东省广州市 腾讯云', '2018-12-17 17:49:04', '111.230.202.204', '账号密码登录', '104'), ('180', '广东省广州市 腾讯云', '2018-12-29 14:09:11', '111.230.202.204', 'github授权登录', '113'), ('181', '广东省广州市 腾讯云', '2019-01-01 10:53:32', '111.230.202.204', '账号密码登录', '113'), ('182', '广东省广州市 腾讯云', '2019-01-01 21:37:07', '111.230.202.204', 'qq授权登录', '1'), ('183', '广东省广州市 腾讯云', '2019-01-03 14:48:14', '111.230.202.204', '账号密码登录', '25'), ('184', '广东省广州市 腾讯云', '2019-01-07 17:13:43', '111.230.202.204', '账号密码登录', '25'), ('185', '广东省广州市 腾讯云', '2019-01-08 13:08:55', '111.230.202.204', '账号密码登录', '115'), ('186', '广东省广州市 腾讯云', '2019-01-08 13:40:53', '111.230.202.204', '账号密码登录', '115'), ('187', '广东省广州市 腾讯云', '2019-01-09 17:50:46', '111.230.202.204', 'qq授权登录', '1'), ('188', '广东省广州市 腾讯云', '2019-01-09 22:35:39', '111.230.202.204', '账号密码登录', '115'), ('189', '广东省广州市 腾讯云', '2019-01-10 10:19:33', '111.230.202.204', '账号密码登录', '115'), ('190', '广东省广州市 腾讯云', '2019-01-10 15:46:37', '111.230.202.204', '账号密码登录', '116'), ('191', '广东省广州市 腾讯云', '2019-01-10 17:58:05', '111.230.202.204', '账号密码登录', '22'), ('192', '广东省广州市 腾讯云', '2019-01-10 19:20:48', '111.230.202.204', 'qq授权登录', '1'), ('193', '广东省广州市 腾讯云', '2019-01-11 10:47:12', '111.230.202.204', '账号密码登录', '111'), ('194', '广东省广州市 腾讯云', '2019-01-14 15:59:56', '111.230.202.204', 'qq授权登录', '1'), ('195', '广东省广州市 腾讯云', '2019-01-14 23:28:46', '111.230.202.204', '账号密码登录', '59'), ('196', '广东省广州市 腾讯云', '2019-01-15 19:09:20', '111.230.202.204', '账号密码登录', '115'), ('197', '广东省广州市 腾讯云', '2019-01-23 15:39:44', '111.230.202.204', 'qq授权登录', '1'), ('198', '广东省广州市 腾讯云', '2019-01-23 21:53:05', '111.230.202.204', 'qq授权登录', '1'), ('199', '广东省广州市 腾讯云', '2019-01-24 08:50:43', '111.230.202.204', '账号密码登录', '115'), ('200', '广东省广州市 腾讯云', '2019-01-24 14:19:55', '111.230.202.204', '账号密码登录', '115'), ('201', '广东省广州市 腾讯云', '2019-01-25 17:29:03', '111.230.202.204', '账号密码登录', '93'), ('202', '广东省广州市 腾讯云', '2019-02-02 09:17:34', '111.230.202.204', 'qq授权登录', '1'), ('203', '广东省广州市 腾讯云', '2019-02-04 09:41:28', '111.230.202.204', '账号密码登录', '115'), ('204', '广东省广州市 腾讯云', '2019-02-16 20:59:44', '111.230.202.204', 'qq授权登录', '8'), ('205', '广东省广州市 腾讯云', '2019-02-19 17:03:43', '111.230.202.204', '账号密码登录', '111'), ('206', '广东省广州市 腾讯云', '2019-02-22 11:36:39', '111.230.202.204', 'qq授权登录', '1'), ('207', '广东省广州市 腾讯云', '2019-02-24 21:36:04', '111.230.202.204', '账号密码登录', '128'), ('208', '广东省广州市 腾讯云', '2019-02-24 21:44:48', '111.230.202.204', '账号密码登录', '128'), ('209', '广东省广州市 腾讯云', '2019-02-24 21:44:49', '111.230.202.204', '账号密码登录', '128'), ('210', '广东省广州市 腾讯云', '2019-03-01 17:35:25', '111.230.202.204', 'qq授权登录', '111'), ('211', '广东省广州市 腾讯云', '2019-03-01 17:46:15', '111.230.202.204', 'qq授权登录', '111'), ('212', '广东省广州市 腾讯云', '2019-03-01 17:51:36', '111.230.202.204', 'qq授权登录', '111'), ('213', '广东省广州市 腾讯云', '2019-03-02 20:59:17', '111.230.202.204', 'qq授权登录', '111'), ('214', '广东省广州市 腾讯云', '2019-03-04 17:26:58', '111.230.202.204', 'qq授权登录', '111'), ('215', '广东省广州市 腾讯云', '2019-03-08 14:50:01', '111.230.202.204', '账号密码登录', '113'), ('216', '广东省广州市 腾讯云', '2019-03-09 17:55:58', '111.230.202.204', '账号密码登录', '115'), ('217', '广东省广州市 腾讯云', '2019-03-10 20:32:42', '111.230.202.204', 'qq授权登录', '136'), ('218', '广东省广州市 腾讯云', '2019-03-12 18:33:27', '111.230.202.204', '账号密码登录', '113'), ('219', '广东省广州市 腾讯云', '2019-03-13 14:04:34', '111.230.202.204', 'qq授权登录', '136'), ('220', '广东省广州市 腾讯云', '2019-03-14 11:12:43', '111.230.202.204', '账号密码登录', '138'), ('221', '广东省广州市 腾讯云', '2019-03-14 12:50:14', '111.230.202.204', 'qq授权登录', '136'), ('222', '广东省广州市 腾讯云', '2019-03-15 15:59:25', '111.230.202.204', 'qq授权登录', '136'), ('223', '广东省广州市 腾讯云', '2019-03-16 19:10:46', '111.230.202.204', '账号密码登录', '139'), ('224', '广东省广州市 腾讯云', '2019-03-20 16:23:05', '111.230.202.204', 'qq授权登录', '1'), ('225', '广东省广州市 腾讯云', '2019-03-21 09:36:17', '111.230.202.204', '账号密码登录', '140'), ('226', '广东省广州市 腾讯云', '2019-03-21 09:51:35', '111.230.202.204', '账号密码登录', '129'), ('227', '广东省广州市 腾讯云', '2019-03-21 10:11:27', '111.230.202.204', 'qq授权登录', '111'), ('228', '广东省广州市 腾讯云', '2019-03-21 13:34:26', '111.230.202.204', 'qq授权登录', '136'), ('229', '广东省广州市 腾讯云', '2019-03-26 18:30:56', '111.230.202.204', '账号密码登录', '115'), ('230', '广东省广州市 腾讯云', '2019-03-29 20:42:29', '111.230.202.204', 'qq授权登录', '136'), ('231', '广东省广州市 腾讯云', '2019-03-30 17:49:02', '111.230.202.204', 'qq授权登录', '136'), ('232', '广东省广州市 腾讯云', '2019-03-30 21:04:17', '111.230.202.204', '账号密码登录', '113'), ('233', '广东省广州市 腾讯云', '2019-03-31 20:43:07', '111.230.202.204', 'qq授权登录', '136'), ('234', '广东省广州市 腾讯云', '2019-04-01 13:56:14', '111.230.202.204', '账号密码登录', '113'), ('235', '广东省广州市 腾讯云', '2019-04-01 14:06:31', '111.230.202.204', 'qq授权登录', '136'), ('236', '广东省广州市 腾讯云', '2019-04-02 08:34:52', '111.230.202.204', 'qq授权登录', '136'), ('237', '广东省广州市 腾讯云', '2019-04-02 11:22:19', '111.230.202.204', 'qq授权登录', '1'), ('238', '广东省广州市 腾讯云', '2019-04-02 14:55:22', '111.230.202.204', 'qq授权登录', '136'), ('239', '广东省广州市 腾讯云', '2019-04-02 15:23:56', '111.230.202.204', '账号密码登录', '113'), ('240', '广东省广州市 腾讯云', '2019-04-02 16:26:53', '111.230.202.204', 'qq授权登录', '136'), ('241', '广东省广州市 腾讯云', '2019-04-03 21:13:12', '111.230.202.204', 'qq授权登录', '136'), ('242', '广东省广州市 腾讯云', '2019-04-09 10:04:18', '111.230.202.204', 'qq授权登录', '136'), ('243', '广东省广州市 腾讯云', '2019-04-12 08:37:55', '111.230.202.204', '账号密码登录', '113'), ('244', '广东省广州市 腾讯云', '2019-04-18 08:19:21', '111.230.202.204', 'qq授权登录', '1'), ('246', '广东省广州市 腾讯云', '2019-04-24 09:33:42', '111.230.202.204', 'qq授权登录', '1'), ('247', '广东省广州市 腾讯云', '2019-04-24 17:06:00', '111.230.202.204', 'qq授权登录', '1'), ('248', '广东省广州市 腾讯云', '2019-04-26 22:49:14', '111.230.202.204', 'qq授权登录', '1'), ('249', '广东省广州市 腾讯云', '2019-04-28 10:47:18', '111.230.202.204', '账号密码登录', '150'), ('250', '广东省广州市 腾讯云', '2019-04-28 19:14:43', '111.230.202.204', 'qq授权登录', '1'), ('251', 'IANA 保留地址用于本地回送', '2019-05-06 19:33:30', '127.0.0.1', '账号密码登录', '1'), ('252', 'IANA 保留地址用于本地回送', '2019-05-06 21:16:52', '127.0.0.1', '账号密码登录', '1'), ('253', 'IANA 保留地址用于本地回送', '2019-05-09 11:25:48', '127.0.0.1', '账号密码登录', '1'), ('254', 'IANA 保留地址用于本地回送', '2019-05-14 20:15:12', '127.0.0.1', '账号密码登录', '1'), ('255', 'IANA 保留地址用于本地回送', '2019-06-01 22:42:29', '127.0.0.1', '账号密码登录', '1');
COMMIT;

-- ----------------------------
--  Table structure for `mail_retrieve`
-- ----------------------------
DROP TABLE IF EXISTS `mail_retrieve`;
CREATE TABLE `mail_retrieve` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `account` varchar(100) DEFAULT NULL,
  `create_time` bigint(20) DEFAULT NULL,
  `out_time` bigint(20) DEFAULT NULL,
  `sid` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_c12ytnb53vmfbpsg08ta7wl4v` (`account`)
) ENGINE=InnoDB AUTO_INCREMENT=135 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `mail_retrieve`
-- ----------------------------
BEGIN;
INSERT INTO `mail_retrieve` VALUES ('1', 'cmpfx', '1528958399014', '1528960199014', 'f224f36b09290881a0a57cc0eca35831'), ('2', 'luhaotian', '1529030599634', '1529032399634', '98b07af2bed46d00a6d54eddf8df81d1'), ('3', 'Nico', '1529044316930', '1529046116930', '8bb1851aa3b5bace5a34a3ba0138f7af'), ('4', 'ambition', '1529044327207', '1529046127207', 'cab87425ca23d03e407983adbe75063d'), ('7', 'qiqi', '1529050014264', '1529051814264', '15ad9502c5455f24a873b1a3891af011'), ('9', 'mojie', '1529244270212', '1529246070212', '4797ed9fa1e19fce4448f190263ed2a8'), ('11', 'tsaizhenya', '1529291284591', '1529293084591', '9280846b905f9a183ce9950f5666afeb'), ('14', 'java', '1529460939189', '1529462739189', 'd3e85bc2f6bda23878130f317ad37383'), ('15', 'fengqingyebai', '1529463416984', '1529465216984', 'f9ee83659dc41c95aa065a8e8d18403d'), ('16', 'duhaoranc@163.com', '1529495209159', '1529497009158', 'f850e9347598dfe7a7506d53863a87bf'), ('17', 'asfasdf', '1529495869612', '1529497669612', '4b670216b7381972835239488c947832'), ('18', 'ZBfool', '1529544726265', '1529546526265', 'accba72763c05801fa1b58757b1c77b6'), ('19', 'shuohao', '1529912146128', '1529913946128', 'c3f373be23476b94d769b9301c2e54c3'), ('20', 'debug96', '1530104743011', '1530106543011', '1e3d26055a23ac91cde8ae702d9f1fb1'), ('21', 'l1012384', '1530607109644', '1530608909644', '99cffe1fae2964b4a6ab850dec57bd9d'), ('23', 'ME_Pu', '1530624040788', '1530625840788', '6c686d50a38db85b4c244d10587859db'), ('24', 'HickSalmon', '1530861385214', '1530863185213', 'bb2045dfdc62e7aac499d3c72add374f'), ('25', 'JerryLiang', '1530865649264', '1530867449264', 'c2f26078a0682425697de080b25a1b6e'), ('26', 'AlexDing', '1530928337217', '1530930137217', 'c57663ce94f8080fe42a88139bc7a3c1'), ('27', 'Jagger', '1530945977367', '1530947777367', '96cd084cdaf95e244fc561ee852ebfc3'), ('28', 'xieshuang', '1531189589172', '1531191389172', '0ec96bcde0a913a7fd600abafc8415a0'), ('31', 'poker', '1531400816587', '1531402616587', '5f54882068739a8600a4c74b228400f2'), ('32', '449073709', '1531497946789', '1531499746788', '3437beeba453b9545181f09647e322d6'), ('33', 'Alen0206', '1531725094448', '1531726894448', 'a9e2bb36b958239172d9da07e5e69013'), ('34', 'coder106', '1531760898557', '1531762698557', '51adc678f957c0cb7e52371f88ca93a4'), ('35', 'qwas', '1531798634410', '1531800434410', 'b13568e25493f94f91571359ba37e4f4'), ('37', 'Rainbow', '1531874901824', '1531876701824', '3866d4e6bdd09615c2cde45eac097ee3'), ('38', 'chenjie', '1531905770871', '1531907570871', '0faf86916ca4d11108c093a2c98671c8'), ('39', 'ai211932', '1532075933260', '1532077733260', 'dac9f6220724387128f759b19cfed67b'), ('40', 'bufan', '1532688890049', '1532690690049', 'e35442aba87914d699e9932de222820d'), ('41', 'hh19970918', '1532844137734', '1532845937734', 'f01b8429255b31d76e52790ae1b42385'), ('42', 'lc11', '1533349859196', '1533351659196', '011dd5fbf20cc9c6d2782254fab69262'), ('43', 'bfs213', '1533570735608', '1533572535608', '681d04c802313e4df94bae19abae53c9'), ('44', 't82168820', '1533623367368', '1533625167368', 'a2adb2740b20b1279415b7cd2fc49f51'), ('45', 'chree', '1534212860707', '1534214660707', '66e5309df65fbb73bd0abe525d6ca46a'), ('46', 'wangbing1991', '1534515577492', '1534517377492', '989482f06275e797c8cfaa6d25a88f29'), ('47', 'mr_donghao', '1534583061941', '1534584861941', '4dddbe19a0383a3810e4d9d9eeeda357'), ('48', 'cscdcsd', '1534738154733', '1534739954733', 'a9dc0c23bb64de7b86ac720369527b0b'), ('49', 'yitiao', '1535080979131', '1535082779131', '7ac977ace136da5633f3ff975569d1da'), ('50', 'zhangyi', '1535191273929', '1535193073929', '4ce42591a259d0878ca88e70623d63d0'), ('52', 'codegroup', '1535643183170', '1535644983170', 'b028d5b041f34074007b56b4e77e6161'), ('54', '835854435', '1535699925581', '1535701725581', '7788befcbead34b61aa73c8fe7e484b0'), ('55', 'shijie', '1535950201839', '1535952001839', '6e045fc85754fdb54f84ac3b872751e6'), ('56', '1211413075', '1535952022027', '1535953822027', '84c6d77b425bf8887e1f34518ccc1b4f'), ('57', 'achi', '1536595227015', '1536597027015', 'e761fbaf39dc571144df7997c08babba'), ('58', 'stevenstar', '1537018919416', '1537020719416', 'c14e108841f6b5e314a147b19d92f71c'), ('59', 'Moose', '1537367762739', '1537369562739', 'c38b58f3102eefaded1c4aff8c9bc79f'), ('60', 'codingwarrior', '1537442443273', '1537444243273', '69d807473c862c95d99c641f16942dd2'), ('61', '15398699939', '1537502278534', '1537504078534', 'b4878a5ad029e537ea72bb147b5c10c6'), ('62', 'willhappy', '1537942911063', '1537944711063', 'd734f1b6adcf46e947073c4396e809fa'), ('63', '15738779238', '1538035472021', '1538037272021', '18a7b901b524627c7c9589f38f6aaa68'), ('64', 'crow_666', '1538204143738', '1538205943738', 'b26e60219072317430edef10caa5ea56'), ('65', 'WHITENIGHT', '1538206622063', '1538208422063', '365650c523dade8bec7e372d5b71f627'), ('66', 'Lewis', '1538535635038', '1538537435038', 'a6e9e0c68bd926cb6175457762d1a336'), ('67', '458730548', '1539149891010', '1539151691010', '3ec7a5e70971c6154a4e663c22fccf0c'), ('68', '15147168029', '1539173999189', '1539175799189', 'cdc9d8ae3ee05c5270448c6c2f762105'), ('69', '115044810052', '1539175341050', '1539177141050', 'd312600612c2b1e47e8fc21a4e2a3ef2'), ('70', 'sdfsf', '1539241035332', '1539242835331', '3f8ee32d9b60da345246ba2649ccfc43'), ('71', 'test1', '1539261408327', '1539263208327', '353c824fcf0cb8ad33151f565eac4ff6'), ('72', 'fyj_coder', '1539261497311', '1539263297311', 'bc6bf32670df9907dc21e5810723b7f4'), ('73', 'gdx945', '1539355490317', '1539357290317', 'b7e79483d406bc17009f14b2ac3a0108'), ('74', 'terwer', '1540964819644', '1540966619644', '16353640be77da1ac0a69613735a89d1'), ('75', 'qq2402841918', '1541170318269', '1541172118269', 'd44c3d116ef3c4d7526a88fe8d24df2a'), ('76', 'code', '1541503916966', '1541505716966', '78415bcbddc841264d9f787268f5fba5'), ('77', 'model', '1541504072022', '1541505872022', '8a997eab65255584ff7793b8b298df88'), ('78', 'momoda', '1541504191677', '1541505991677', '1fd32d0f8fc51536d6f48233a298c128'), ('79', 'robin', '1541585678875', '1541587478875', '923279c7e3f6085db222d26c87687fae'), ('80', 'Zachary', '1541662335910', '1541664135910', 'cff0f14f7fd6bd8eb6d26afdff76ea8c'), ('81', 'Albert', '1541680599166', '1541682399166', '0527dfeb00c76705a8638801bf7b9411'), ('82', '76295504', '1541809850470', '1541811650470', '847f07947180a3e4ee523a952fdf03d3'), ('83', 'chenzi', '1541947165289', '1541948965289', '87f4f7e8fd95cdf296565571f227b0a1'), ('84', 'tvb1', '1542111782023', '1542113582023', '15a2812473ae832268785d8cd62c4603'), ('85', 'dalin', '1542350032355', '1542351832355', '9d6d4209cebaae84bd3b3a415a6b6520'), ('86', 'sunkint', '1542521918781', '1542523718781', '3afdbf3244e622134dfd5764033c0197'), ('87', 'Webb_Chen', '1542525445282', '1542527245282', '50858945ad8fb072aaaedb22c2f1678c'), ('88', 'lizhiyi', '1543061781920', '1543063581920', '0e6313edb66a5abbe330e37db8758b1f'), ('89', 'theygg', '1543502754139', '1543504554139', 'f1267d7cb3c351361d790b4e29bb6efd'), ('90', 'bigpao1980', '1543757836359', '1543759636359', '45692941f7611418034cb0fb5473a1b9'), ('92', 'Pamper', '1544012466858', '1544014266858', 'bae9c111253715e5b52c87f473605a35'), ('93', 'tiger', '1544680967350', '1544682767350', '63fcd4139db67efb195450dbed6217ca'), ('94', 'xjh101010', '1544761530569', '1544763330568', 'c559b24875997eb31ca4697596ce78d6'), ('95', 'fans', '1545634670716', '1545636470716', 'b11035fedaab08974de8fc5055550b46'), ('96', 'ysqyjjlp', '1545764524725', '1545766324725', 'bb6e975c12060e7ac0110b00b7703b21'), ('97', 'qwe86314', '1546063600839', '1546065400839', '49dc2a9f2e0b9531a964485b59a30d27'), ('99', 'Empirefree', '1546924081109', '1546925881109', 'ba69bb1f07c58cd2e382f63644331db2'), ('100', 'hubspring', '1547105796426', '1547107596426', 'a00ea813e1ba78b13810106d1596b458'), ('101', 'haifeng', '1547559908282', '1547561708282', '9fad752b63511ed28e1828c25682ed55'), ('102', 'Hhc0917', '1547794048264', '1547795848264', '2234d10cb8be146d9c060d26a04e7d73'), ('103', 'meizhenhao', '1548066848717', '1548068648717', '6683c185579371f70da2fc87cd01047a'), ('104', 'gszdc', '1548294693574', '1548296493574', '416e9542b2b9c39537c2b684d62f742c'), ('105', 'yoke', '1548298897192', '1548300697192', '15145e3c6aae55dba4b768c13db13574'), ('106', 'zhaoqi94', '1550048837479', '1550050637479', '12467fd44d423597b86cd177a2237907'), ('107', 'wannamyself', '1550939694092', '1550941494092', '2c0e101d32e3122bb553df742173a0c0'), ('108', 'Forever', '1551433368767', '1551435168767', 'c2e8004fcc30966de304ff1319bd6485'), ('109', 'lusifer', '1551455566369', '1551457366369', '7a2a27960b001649ee58005bd419518e'), ('110', 'lufider', '1551455701806', '1551457501806', '9059047e739c1a39db74221347bb74ce'), ('111', 'lufiderhjk', '1551455779347', '1551457579347', 'd40eadfa1ae5edd5b02431793521c093'), ('114', '147lusifer', '1551463520790', '1551465320790', '413e029dffe32d9020ed9842e5b57ad1'), ('115', 'zhaoyanzeng', '1551681645599', '1551683445599', '7119e09617fd5d2dd53e02cf117dd9a2'), ('116', 'hfbin', '1551691249712', '1551693049712', '53657b45c63f45aaa5db264a4708a16f'), ('117', '2530047598', '1552039393266', '1552041193266', '9650213fe218c312ae703998c3a55d5b'), ('119', 'lusifer2', '1552067700804', '1552069500803', '963befee81d1a89a598be76053317b2a'), ('121', 'zhangtao', '1552533090553', '1552534890553', '76969323a5d4ccadec44073f0e2de631'), ('122', 'qbian', '1552971488380', '1552973288380', '94b1a0de5675e490bb0d70790c884ef4'), ('123', 'jinruimin', '1553141034927', '1553142834927', '102c9856da796dc16e648b966ab2890e'), ('124', '147854', '1553618583614', '1553620383614', '6e9706b57df9a24c446e26435937753a'), ('125', 'SK123', '1555927656987', '1555929456987', 'de9f5595e0e52e493cf0b1e53206be51'), ('126', 'shyjs1', '1555991886315', '1555993686315', '062e4b17e8e501e8f90a4e41aaeebfa0'), ('128', 'sjzxsj001', '1556067412063', '1556069212063', 'ec49591d520e042c1048747a5bac073c'), ('129', 'shxycm1', '1556071026394', '1556072826394', '686eb484aa2ca2ce1b8f13e35178ebd2'), ('130', 'gfjghkuy', '1556153551831', '1556155351831', 'f6e94fbbaca481e3f3c3944b2ef2af36'), ('131', 'zdx2589', '1556287942109', '1556289742109', '991a84fb9959346f3d13634d8b2fc3ea'), ('132', 'xiaomajia21', '1556329843406', '1556331643406', 'c9dafa4b3ffbf740e72b17de2fcecb7a'), ('133', 'fgjghkyus', '1556527961120', '1556529761120', '0efb2a4d4789a1656633e8117fae618e'), ('134', 'owlcity', '1557108888197', '1557110688197', '85ae8f452d8ccfdc7a1c63b0c893f026');
COMMIT;

-- ----------------------------
--  Table structure for `message`
-- ----------------------------
DROP TABLE IF EXISTS `message`;
CREATE TABLE `message` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` varchar(500) NOT NULL,
  `create_time` datetime DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `type` int(11) DEFAULT NULL,
  `friend_id` int(11) DEFAULT NULL,
  `receiver_id` int(11) DEFAULT NULL,
  `sender_id` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=107 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `message`
-- ----------------------------
BEGIN;
INSERT INTO `message` VALUES ('1', '[上车],点击[ http://pinyin.cn/e148637 ]查看表情', '2018-06-14 14:45:27', '2', '1', '1', '1', '2', '2'), ('2', '[上车],点击[ http://pinyin.cn/e148637 ]查看表情', '2018-06-14 14:45:27', '2', '1', '2', '1', '2', '1'), ('3', 'Nihao', '2018-06-14 14:45:41', '2', '1', '2', '2', '1', '1'), ('4', 'Nihao', '2018-06-14 14:45:41', '2', '1', '1', '2', '1', '2'), ('5', 'welcome', '2018-06-14 14:45:44', '2', '1', '2', '2', '1', '1'), ('6', 'welcome', '2018-06-14 14:45:45', '2', '1', '1', '2', '1', '2'), ('7', '站长好', '2018-06-14 14:46:09', '2', '1', '1', '1', '2', '2'), ('8', '站长好', '2018-06-14 14:46:09', '2', '1', '2', '1', '2', '1'), ('9', '啦啦啦', '2018-06-15 15:59:19', '3', '1', '8', '8', '1', '1'), ('10', '啦啦啦', '2018-06-15 15:59:19', '2', '1', '1', '8', '1', '8'), ('11', '啦啦啦', '2018-06-15 16:00:09', '2', '1', '1', '1', '8', '8'), ('12', '啦啦啦', '2018-06-15 16:00:09', '3', '1', '8', '1', '8', '1'), ('13', '小坏坏', '2018-06-18 22:40:27', '3', '1', '8', '8', '1', '1'), ('14', '小坏坏', '2018-06-18 22:40:27', '2', '1', '1', '8', '1', '8'), ('15', '收到了么', '2018-06-18 22:40:34', '3', '1', '8', '8', '1', '1'), ('16', '收到了么', '2018-06-18 22:40:34', '2', '1', '1', '8', '1', '8'), ('17', '啦啦啦', '2018-06-18 22:40:40', '3', '1', '8', '8', '1', '1'), ('18', '啦啦啦', '2018-06-18 22:40:40', '2', '1', '1', '8', '1', '8'), ('19', '摸摸大', '2018-06-18 22:40:48', '3', '1', '8', '8', '1', '1'), ('20', '摸摸大', '2018-06-18 22:40:48', '2', '1', '1', '8', '1', '8'), ('21', '收到了呢', '2018-06-18 22:40:55', '2', '1', '1', '1', '8', '8'), ('22', '收到了呢', '2018-06-18 22:40:55', '3', '1', '8', '1', '8', '1'), ('23', '么么哒', '2018-06-18 22:41:01', '2', '1', '1', '1', '8', '8'), ('24', '么么哒', '2018-06-18 22:41:02', '3', '1', '8', '1', '8', '1'), ('25', '爱你', '2018-06-18 22:41:16', '3', '1', '8', '8', '1', '1'), ('26', '爱你', '2018-06-18 22:41:16', '2', '1', '1', '8', '1', '8'), ('27', '啦啦啦', '2018-06-18 22:41:25', '3', '1', '8', '8', '1', '1'), ('28', '啦啦啦', '2018-06-18 22:41:25', '2', '1', '1', '8', '1', '8'), ('29', '啦啦啦啦啦', '2018-06-18 22:42:52', '3', '1', '8', '8', '1', '1'), ('30', '啦啦啦啦啦', '2018-06-18 22:42:52', '2', '1', '1', '8', '1', '8'), ('31', '[表情]', '2018-06-18 22:44:03', '3', '1', '8', '8', '1', '1'), ('32', '[表情]', '2018-06-18 22:44:03', '2', '1', '1', '8', '1', '8'), ('33', '我想艹你', '2018-06-18 22:46:22', '2', '1', '1', '1', '8', '8'), ('34', '我想艹你', '2018-06-18 22:46:22', '3', '1', '8', '1', '8', '1'), ('35', '来呀', '2018-06-18 22:46:29', '3', '1', '8', '8', '1', '1'), ('36', '来呀', '2018-06-18 22:46:29', '2', '1', '1', '8', '1', '8'), ('37', '摸摸大', '2018-06-18 22:47:22', '3', '1', '8', '8', '1', '1'), ('38', '摸摸大', '2018-06-18 22:47:22', '2', '1', '1', '8', '1', '8'), ('39', '习近平', '2018-06-18 22:47:30', '2', '1', '1', '1', '8', '8'), ('40', '习近平', '2018-06-18 22:47:30', '3', '1', '8', '1', '8', '1'), ('41', '想爱嘛', '2018-06-18 22:47:30', '3', '1', '8', '8', '1', '1'), ('42', '想爱嘛', '2018-06-18 22:47:30', '2', '1', '1', '8', '1', '8'), ('43', '要忍住哦', '2018-06-18 22:47:37', '3', '1', '8', '8', '1', '1'), ('44', '要忍住哦', '2018-06-18 22:47:37', '2', '1', '1', '8', '1', '8'), ('45', '我喜欢习近平', '2018-06-18 22:47:43', '2', '1', '1', '1', '8', '8'), ('46', '我喜欢习近平', '2018-06-18 22:47:43', '3', '1', '8', '1', '8', '1'), ('47', '好的呢', '2018-06-18 22:48:15', '2', '1', '1', '1', '8', '8'), ('48', '好的呢', '2018-06-18 22:48:15', '3', '1', '8', '1', '8', '1'), ('49', '我喜欢你', '2018-06-18 22:48:19', '2', '1', '1', '1', '8', '8'), ('50', '我喜欢你', '2018-06-18 22:48:19', '3', '1', '8', '1', '8', '1'), ('51', '超喜欢呢', '2018-06-18 22:48:25', '2', '1', '1', '1', '8', '8'), ('52', '超喜欢呢', '2018-06-18 22:48:25', '3', '1', '8', '1', '8', '1'), ('53', '在玩手机啊', '2018-06-18 22:48:33', '2', '1', '1', '1', '8', '8'), ('54', '在玩手机啊', '2018-06-18 22:48:33', '3', '1', '8', '1', '8', '1'), ('55', '好的呢', '2018-06-18 22:49:39', '3', '1', '8', '8', '1', '1'), ('56', '好的呢', '2018-06-18 22:49:39', '2', '1', '1', '8', '1', '8'), ('57', '在玩手机啊', '2018-06-18 22:49:43', '2', '1', '1', '1', '8', '8'), ('58', '在玩手机啊', '2018-06-18 22:49:43', '3', '1', '8', '1', '8', '1'), ('59', 'yy', '2018-06-18 22:49:49', '2', '1', '1', '1', '8', '8'), ('60', 'yy', '2018-06-18 22:49:49', '3', '1', '8', '1', '8', '1'), ('61', '我想躺在你身边', '2018-06-18 22:50:05', '2', '1', '1', '1', '8', '8'), ('62', '我想躺在你身边', '2018-06-18 22:50:05', '3', '1', '8', '1', '8', '1'), ('63', '安静地躺在你身边呢', '2018-06-18 22:50:25', '2', '1', '1', '1', '8', '8'), ('64', '安静地躺在你身边呢', '2018-06-18 22:50:25', '3', '1', '8', '1', '8', '1'), ('65', '你困了', '2018-06-18 22:50:37', '2', '1', '1', '1', '8', '8'), ('66', '你困了', '2018-06-18 22:50:37', '3', '1', '8', '1', '8', '1'), ('67', '不困', '2018-06-18 22:50:41', '2', '1', '1', '1', '8', '8'), ('68', '不困', '2018-06-18 22:50:41', '3', '1', '8', '1', '8', '1'), ('69', '我等下还要去洗澡澡洗头呢', '2018-06-18 22:50:54', '2', '1', '1', '1', '8', '8'), ('70', '我等下还要去洗澡澡洗头呢', '2018-06-18 22:50:54', '3', '1', '8', '1', '8', '1'), ('71', '不困了', '2018-06-18 22:51:02', '2', '1', '1', '1', '8', '8'), ('72', '不困了', '2018-06-18 22:51:02', '3', '1', '8', '1', '8', '1'), ('73', '小曌曌', '2018-06-18 22:51:10', '2', '1', '1', '1', '8', '8'), ('74', '小曌曌', '2018-06-18 22:51:10', '3', '1', '8', '1', '8', '1'), ('75', '我好爱你', '2018-06-18 22:51:36', '3', '1', '8', '8', '1', '1'), ('76', '我好爱你', '2018-06-18 22:51:36', '2', '1', '1', '8', '1', '8'), ('77', '超可爱', '2018-06-18 22:51:41', '3', '1', '8', '8', '1', '1'), ('78', '超可爱', '2018-06-18 22:51:41', '2', '1', '1', '8', '1', '8'), ('79', '啦啦啦', '2018-06-18 22:51:44', '3', '1', '8', '8', '1', '1'), ('80', '啦啦啦', '2018-06-18 22:51:44', '2', '1', '1', '8', '1', '8'), ('81', '超可爱', '2018-06-18 22:51:47', '2', '1', '1', '1', '8', '8'), ('82', '超可爱', '2018-06-18 22:51:47', '3', '1', '8', '1', '8', '1'), ('83', '么么大', '2018-06-18 22:51:58', '3', '1', '8', '8', '1', '1'), ('84', '么么大', '2018-06-18 22:51:58', '2', '1', '1', '8', '1', '8'), ('85', '等一下', '2018-06-18 22:52:05', '2', '1', '1', '1', '8', '8'), ('86', '等一下', '2018-06-18 22:52:05', '3', '1', '8', '1', '8', '1'), ('87', '开空调了', '2018-06-18 22:52:13', '2', '1', '1', '1', '8', '8'), ('88', '开空调了', '2018-06-18 22:52:13', '3', '1', '8', '1', '8', '1'), ('89', '不是啊', '2018-06-18 22:52:20', '2', '1', '1', '1', '8', '8'), ('90', '不是啊', '2018-06-18 22:52:20', '3', '1', '8', '1', '8', '1'), ('91', '有点困了', '2018-06-18 22:52:25', '2', '1', '1', '1', '8', '8'), ('92', '有点困了', '2018-06-18 22:52:25', '3', '1', '8', '1', '8', '1'), ('93', '你不敢说话嘛', '2018-06-18 22:52:27', '3', '1', '8', '8', '1', '1'), ('94', '你不敢说话嘛', '2018-06-18 22:52:27', '2', '1', '1', '8', '1', '8'), ('95', '睡觉了吧', '2018-06-18 22:52:34', '3', '1', '8', '8', '1', '1'), ('96', '睡觉了吧', '2018-06-18 22:52:34', '2', '1', '1', '8', '1', '8'), ('97', '拜拜啦', '2018-06-18 22:54:39', '3', '1', '8', '8', '1', '1'), ('98', '拜拜啦', '2018-06-18 22:54:39', '2', '1', '1', '8', '1', '8'), ('99', '您好，您的用户名是duhaoranc@163.com，因为包含了一个点，用户名不合法，所以主页无法访问。如果您收到此消息，并发送您想改的用户名，我可以帮你修改', '2018-06-22 09:15:17', '2', '1', '17', '17', '1', '1'), ('100', '您好，您的用户名是duhaoranc@163.com，因为包含了一个点，用户名不合法，所以主页无法访问。如果您收到此消息，并发送您想改的用户名，我可以帮你修改', '2018-06-22 09:15:17', '2', '1', '1', '17', '1', '17'), ('101', 'hello', '2018-09-12 19:12:58', '2', '1', '2', '2', '1', '1'), ('102', 'hello', '2018-09-12 19:12:58', '1', '1', '1', '2', '1', '2'), ('103', '加油', '2018-09-12 19:13:02', '2', '1', '2', '2', '1', '1'), ('104', '加油', '2018-09-12 19:13:02', '1', '1', '1', '2', '1', '2'), ('105', '厉害了，博主，哈哈', '2019-01-21 18:44:09', '2', '1', '1', '1', '121', '121'), ('106', '厉害了，博主，哈哈', '2019-01-21 18:44:09', '2', '1', '121', '1', '121', '1');
COMMIT;

-- ----------------------------
--  Table structure for `notice`
-- ----------------------------
DROP TABLE IF EXISTS `notice`;
CREATE TABLE `notice` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `guid` varchar(255) DEFAULT NULL,
  `more` varchar(255) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `from_user_id` int(11) DEFAULT NULL,
  `notice_type_id` int(11) DEFAULT NULL,
  `to_user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=150 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `notice`
-- ----------------------------
BEGIN;
INSERT INTO `notice` VALUES ('3', null, '2018-06-15 14:55:57', '/manage/relationships/fans', null, '1', '1', '3', '7'), ('5', null, '2018-06-15 15:01:46', '/manage/relationships/fans', null, '0', '1', '3', '3'), ('6', null, '2018-06-15 15:02:25', '/manage/relationships/fans', null, '0', '1', '3', '2'), ('7', null, '2018-06-15 15:02:26', '/manage/relationships/fans', null, '1', '1', '3', '7'), ('8', null, '2018-06-15 15:03:03', '/manage/relationships/fans', null, '0', '1', '3', '4'), ('9', null, '2018-06-15 15:03:14', '/manage/relationships/fans', null, '0', '1', '3', '5'), ('10', null, '2018-06-15 15:03:21', '/manage/relationships/fans', null, '0', '1', '3', '6'), ('15', '愿得一心人，白首不相离', '2018-06-15 16:04:49', '/articles/10003#comment-6', '(⌒▽⌒)', '1', '1', '1', '8'), ('16', '愿得一心人，白首不相离', '2018-06-15 16:15:07', '/articles/10003#comment-8', 'test', '1', '1', '1', '8'), ('19', null, '2018-06-15 16:28:38', '/manage/relationships/fans', null, '1', '8', '3', '7'), ('20', null, '2018-06-15 16:28:42', '/manage/relationships/fans', null, '1', '8', '3', '7'), ('21', null, '2018-06-15 16:28:48', '/manage/relationships/fans', null, '1', '8', '3', '7'), ('22', '愿得一心人，白首不相离', '2018-06-17 20:48:04', '/articles/10003#comment-11', '文明评论。。。。。。', '1', '9', '1', '8'), ('23', null, '2018-06-17 21:43:54', '/manage/relationships/fans', null, '0', '1', '3', '10'), ('24', null, '2018-06-17 21:46:40', '/manage/relationships/fans', null, '1', '1', '3', '9'), ('26', '加油', '2018-06-18 22:37:17', '/articles/10010#comment-13', '谢谢老婆', '1', '1', '2', '8'), ('30', null, '2018-06-20 11:36:59', '/manage/relationships/fans', null, '0', '1', '3', '15'), ('34', null, '2018-06-20 21:49:46', '/manage/relationships/fans', null, '0', '1', '3', '18'), ('36', null, '2018-06-22 09:05:51', '/manage/relationships/fans', null, '0', '1', '3', '19'), ('37', null, '2018-06-22 09:07:09', '/manage/relationships/fans', null, '0', '1', '3', '16'), ('39', '文章详情页打开感觉可以新开一个界面挺好，可能是个人习惯问题。。。。。。。。。', '2018-06-26 23:54:43', '/articles/10033#comment-23', '很好的建议！', '0', '1', '2', '17'), ('42', null, '2018-07-06 16:09:00', '/manage/relationships/fans', null, '0', '7', '3', '8'), ('43', null, '2018-07-06 16:09:05', '/manage/relationships/fans', null, '0', '7', '3', '8'), ('44', null, '2018-07-06 16:09:08', '/manage/relationships/fans', null, '0', '7', '3', '8'), ('45', null, '2018-07-06 16:09:12', '/manage/relationships/fans', null, '0', '7', '3', '8'), ('46', null, '2018-07-06 18:14:08', '/manage/relationships/fans', null, '0', '1', '3', '27'), ('48', null, '2018-07-07 14:43:05', '/manage/relationships/fans', null, '0', '1', '3', '28'), ('51', null, '2018-07-11 21:52:08', '/manage/relationships/fans', null, '0', '1', '3', '30'), ('53', null, '2018-07-19 14:45:20', '/manage/relationships/fans', null, '1', '8', '3', '7'), ('54', 'python从入门到放弃', '2018-07-19 19:18:11', '/articles/10054#comment-27', '（#-_-)┯━┯', '0', '1', '1', '8'), ('55', 'python从入门到放弃', '2018-07-20 16:40:30', '/articles/10054#comment-28', '(ﾟДﾟ≡ﾟдﾟ)!?', '0', '7', '1', '8'), ('56', null, '2018-07-29 07:41:35', '/manage/relationships/fans', null, '1', '42', '3', '7'), ('57', '测试问题！！！', '2018-08-04 11:29:31', '/questions/2#answer-2', '<p><img alt=\"图片.png\" src=\"http://cdn.codergroup.cn/uploads/2018/8/4/debug96/1533353348759\" width=\"1328\" height=\"142\"><br></p>', '1', '22', '4', '1'), ('58', '为什么不能根据返回类型区分重载？', '2018-08-10 11:27:41', '/articles/10002#comment-29', '(\"▔□▔)/', '1', '41', '1', '1'), ('59', '简单说说合作开发项目的注意点', '2018-08-20 12:13:48', '/articles/10055#comment-30', '(<_<)(ﾟДﾟ≡ﾟдﾟ)!?', '1', '50', '1', '7'), ('60', null, '2018-08-20 16:59:12', '/manage/relationships/fans', null, '0', '7', '3', '42'), ('61', null, '2018-08-20 16:59:14', '/manage/relationships/fans', null, '0', '7', '3', '8'), ('62', null, '2018-08-20 16:59:15', '/manage/relationships/fans', null, '1', '7', '3', '1'), ('63', '(<_<)(ﾟДﾟ≡ﾟдﾟ)!?', '2018-08-20 17:10:04', '/articles/10055#comment-31', '(╯°口°)╯(┴—┴', '0', '7', '2', '50'), ('64', '简单说说合作开发项目的注意点', '2018-08-24 11:24:36', '/articles/10055#comment-32', '111', '1', '51', '1', '7'), ('65', '标题不短', '2018-09-20 21:32:35', '/articles/10035#comment-46', '测试评论(⌒▽⌒)', '0', '63', '1', '23'), ('66', '这是标题', '2018-09-20 22:23:48', '/articles/10057#comment-48', '大师傅', '0', '63', '1', '54'), ('67', null, '2018-10-03 11:01:39', '/manage/relationships/fans', null, '1', '70', '3', '1'), ('68', 'aaaaaaaaaa', '2018-10-10 12:55:12', '/articles/10058#comment-49', '哈哈', '0', '71', '1', '54'), ('69', 'javaweb  菜鸟级别手的想法2  zbcoder', '2018-10-10 13:00:12', '/articles/10061#comment-50', 'sb', '0', '72', '1', '71'), ('70', 'sb', '2018-10-10 13:00:45', '/articles/10061#comment-51', 'dsb', '0', '71', '2', '72'), ('71', '张彪是SB吗？', '2018-10-10 13:05:05', '/questions/3#answer-4', '<p>！！！<br><br></p>', '0', '72', '4', '71'), ('72', '张彪是SB吗？', '2018-10-10 13:05:54', '/questions/3#answer-4', '<p>！！！<br><br></p>', '0', '72', '4', '71'), ('73', '张彪是SB吗？', '2018-10-10 13:05:54', '/questions/3', '<p>！！！<br><br></p>', '0', '71', '6', '72'), ('74', '张彪是SB吗？', '2018-10-12 14:06:42', '/questions/3#answer-5', '<p>是啊</p>', '0', '75', '4', '71'), ('75', '闪光点福利阿萨德刚放假阿萨德说的', '2018-10-27 20:15:51', '/articles/10071#comment-52', '测试中', '0', '82', '1', '71'), ('76', null, '2018-10-27 20:18:38', '/manage/relationships/fans', null, '0', '82', '3', '71'), ('77', null, '2018-10-27 20:19:10', '/manage/relationships/fans', null, '0', '82', '3', '71'), ('78', '测试中', '2018-10-30 15:35:40', '/articles/10072#comment-54', '你说啥', '0', '71', '2', '82'), ('79', null, '2018-10-31 11:49:19', '/manage/relationships/fans', null, '0', '85', '3', '7'), ('80', '提问的测试', '2018-11-01 19:04:26', '/questions/9#answer-8', '配置\n', '0', '75', '4', '82'), ('81', '这些大V安抚说的的发送到樊ad个邵登峰给第三方', '2018-11-05 17:16:48', '/questions/8#answer-11', '放大法师', '0', '75', '4', '71'), ('82', '这些大V安抚说的的发送到樊ad个邵登峰给第三方', '2018-11-05 17:17:04', '/questions/8#answer-11', '股份的水电费', '0', '75', '4', '71'), ('83', '提问的测试', '2018-11-05 20:35:47', '/questions/9#answer-8', '@哈哈哈哈 大概花费大概多少', '0', '75', '4', '82'), ('84', '提问的测试', '2018-11-05 21:00:16', '/questions/9#answer-17', '<p>发的所发生的</p>', '0', '75', '4', '82'), ('85', '测试一篇文章', '2018-11-05 22:29:20', '/articles/10074#comment-60', '测试', '0', '78', '1', '71'), ('86', '测试一篇文章', '2018-11-05 22:29:33', '/articles/10074#comment-61', '测试_2', '0', '78', '1', '71'), ('87', null, '2018-11-05 22:29:49', '/manage/relationships/fans', null, '0', '78', '3', '71'), ('88', null, '2018-11-05 22:33:29', '/manage/relationships/fans', null, '1', '78', '3', '1'), ('89', null, '2018-11-08 20:37:44', '/manage/relationships/fans', null, '0', '77', '3', '71'), ('90', null, '2018-11-08 22:18:57', '/manage/relationships/fans', null, '0', '77', '3', '94'), ('91', null, '2018-11-08 22:19:09', '/manage/relationships/fans', null, '0', '77', '3', '82'), ('92', null, '2018-11-08 22:28:09', '/manage/relationships/fans', null, '0', '77', '3', '54'), ('93', 'fyjshsjhshss', '2018-11-08 23:31:10', '/questions/23#answer-24', '<p>经核实对方</p>', '0', '71', '4', '77'), ('94', null, '2018-11-09 17:12:20', '/manage/relationships/fans', null, '0', '78', '3', '77'), ('95', 'fyjshsjhshss', '2018-11-09 20:08:50', '/questions/23#answer-24', 'sdfghjkl', '0', '75', '5', '71'), ('96', 'fyjshsjhshss', '2018-11-10 20:45:17', '/questions/23#answer-23', '来', '0', '71', '4', '77'), ('97', null, '2018-11-11 15:11:18', '/manage/relationships/fans', null, '0', '1', '3', '78'), ('98', null, '2018-11-11 16:10:56', '/manage/relationships/fans', null, '0', '71', '3', '82'), ('99', null, '2018-11-11 16:11:39', '/manage/relationships/fans', null, '0', '71', '3', '82'), ('100', '文章二', '2018-11-11 22:42:31', '/articles/10079#comment-65', 'ax', '0', '96', '1', '77'), ('101', '(╯°口°)╯(┴—┴', '2018-11-12 17:50:14', '/articles/10080#comment-67', '？？', '0', '71', '2', '96'), ('102', '111111', '2018-11-13 20:28:20', '/articles/10082#comment-68', '·····', '0', '97', '1', '70'), ('103', null, '2018-11-13 20:43:30', '/manage/relationships/fans', null, '0', '97', '3', '70'), ('104', 'hello_world！', '2018-11-14 13:16:51', '/questions/19#answer-27', '<p>11</p>', '0', '1', '4', '78'), ('105', '来逛逛，哈哈哈哈哈', '2018-11-18 21:31:20', '/questions/24#answer-28', '<p>11</p>', '0', '101', '4', '98'), ('106', '来逛逛，哈哈哈哈哈', '2018-11-18 21:31:47', '/questions/24#answer-29', '<p>2</p>', '0', '101', '4', '98'), ('107', '来逛逛，哈哈哈哈哈', '2018-11-18 21:32:09', '/questions/24#answer-31', '<p>21</p>', '0', '101', '4', '98'), ('108', '111111', '2018-11-20 13:27:30', '/articles/10082#comment-69', '我发测试下评论', '0', '100', '1', '70'), ('109', '来逛逛，哈哈哈哈哈', '2018-12-31 18:11:16', '/questions/24#answer-35', '<p>saff</p>', '0', '114', '4', '98'), ('110', '理解Class.forName()', '2019-01-01 10:53:49', '/articles/10004#comment-71', '8888', '1', '113', '1', '1'), ('111', '理解Class.forName()', '2019-01-01 10:53:57', '/articles/10004#comment-72', '(￣3￣)', '1', '113', '1', '1'), ('112', '理解Class.forName()', '2019-01-01 10:54:14', '/articles/10004#comment-73', '999999', '1', '113', '1', '1'), ('113', null, '2019-01-01 21:46:17', '/manage/relationships/fans', null, '0', '1', '3', '71'), ('114', null, '2019-01-21 18:36:24', '/manage/relationships/fans', null, '0', '121', '3', '120'), ('115', null, '2019-01-21 18:42:40', '/manage/relationships/fans', null, '1', '121', '3', '1'), ('116', null, '2019-01-21 18:43:12', '/manage/relationships/fans', null, '1', '121', '3', '1'), ('117', null, '2019-01-21 18:43:14', '/manage/relationships/fans', null, '0', '121', '3', '120'), ('118', '测试内容', '2019-02-22 11:31:25', '/articles/10096#comment-83', '22222', '0', '126', '1', '122'), ('119', '22222', '2019-02-24 00:36:20', '/articles/10096#comment-84', '测试回复', '0', '127', '2', '126'), ('120', null, '2019-02-24 00:37:13', '/manage/relationships/fans', null, '0', '127', '3', '122'), ('121', 'hello_world！', '2019-03-01 17:54:20', '/questions/22#answer-37', '<p>1111</p>', '0', '111', '4', '78'), ('123', null, '2019-03-04 17:37:13', '/manage/relationships/fans', null, '0', '111', '3', '122'), ('124', null, '2019-03-04 17:37:20', '/manage/relationships/fans', null, '0', '111', '3', '122'), ('125', 'java垃圾回收算法和垃圾收集器', '2019-03-08 16:55:53', '/articles/10045#comment-86', '6666666牛逼', '0', '113', '1', '1'), ('126', ' 发表于╮(￣▽￣)╭', '2019-03-14 11:30:12', '/articles/10096#comment-89', '9999', '0', '113', '2', '127'), ('127', '测试内容', '2019-03-14 14:55:27', '/articles/10096#comment-91', '222222211111111111111222222211111111111111222222211111111111111222222211111111111111222\n', '0', '136', '1', '122'), ('128', 'javaweb  菜鸟级别手的想法2  zbcoder', '2019-03-15 21:18:02', '/articles/10061#comment-92', '（￣▽￣）(｀・ω・´)(>_>)', '0', '113', '1', '71'), ('129', 'javaweb  菜鸟级别手的想法2  zbcoder', '2019-03-15 21:18:08', '/articles/10061#comment-93', '阿萨斯', '0', '113', '1', '71'), ('130', 'javaweb  菜鸟级别手的想法2  zbcoder', '2019-03-15 21:18:11', '/articles/10061#comment-94', '阿萨斯', '0', '113', '1', '71'), ('131', 'javaweb  菜鸟级别手的想法2  zbcoder', '2019-03-15 21:18:13', '/articles/10061#comment-95', '阿萨飒飒', '0', '113', '1', '71'), ('132', 'javaweb  菜鸟级别手的想法2  zbcoder', '2019-03-15 21:18:20', '/articles/10061#comment-96', '阿萨斯', '0', '113', '1', '71'), ('133', 'javaweb  菜鸟级别手的想法2  zbcoder', '2019-03-15 21:18:22', '/articles/10061#comment-97', '阿萨撒撒', '0', '113', '1', '71'), ('134', 'javaweb  菜鸟级别手的想法2  zbcoder', '2019-03-15 21:18:26', '/articles/10061#comment-98', '阿萨斯阿萨', '0', '113', '1', '71'), ('135', 'javaweb  菜鸟级别手的想法2  zbcoder', '2019-03-15 21:18:28', '/articles/10061#comment-99', '阿萨斯', '0', '113', '1', '71'), ('136', 'javaweb  菜鸟级别手的想法2  zbcoder', '2019-03-15 21:18:30', '/articles/10061#comment-100', '阿萨斯', '0', '113', '1', '71'), ('137', 'javaweb  菜鸟级别手的想法2  zbcoder', '2019-03-15 21:18:45', '/articles/10061#comment-101', '阿萨斯阿萨阿萨阿萨', '0', '113', '1', '71'), ('138', 'SpringBoot 初体验（2）使用SpringDataJpa', '2019-03-21 07:59:42', '/articles/10051#comment-104', '阿萨斯全是', '0', '113', '1', '7'), ('139', 'SpringBoot 初体验（2）使用SpringDataJpa', '2019-03-21 08:02:31', '/articles/10051#comment-105', '（￣▽￣）', '0', '113', '1', '7'), ('142', 'test-name', '2019-03-21 11:45:23', '/articles/10104#comment-106', '阿萨飒飒阿萨', '0', '113', '1', '140'), ('143', 'test-name', '2019-03-21 15:08:32', '/articles/10104#comment-107', '1231213', '0', '111', '1', '140'), ('144', '1231213', '2019-03-21 18:12:03', '/articles/10104#comment-108', '阿萨斯阿萨', '0', '113', '2', '111'), ('145', 'test-name', '2019-04-02 09:28:42', '/articles/10104#comment-115', '(=・ω・=)', '0', '113', '1', '140'), ('146', 'cesss', '2019-04-04 09:41:44', '/questions/25#answer-32', '888888888888', '0', '113', '4', '104'), ('147', 'cesss', '2019-04-04 09:42:10', '/questions/25#answer-32', 'alert(xxxxx);', '0', '113', '4', '104'), ('148', 'cesss', '2019-04-04 09:42:23', '/questions/25#answer-32', 'alert(\'xxxxxx\');', '0', '113', '4', '104'), ('149', '（￣▽￣）', '2019-04-12 20:34:56', '/articles/10092#comment-119', '8898999', '0', '113', '2', '115');
COMMIT;

-- ----------------------------
--  Table structure for `notice_type`
-- ----------------------------
DROP TABLE IF EXISTS `notice_type`;
CREATE TABLE `notice_type` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `content` varchar(255) DEFAULT NULL,
  `style` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `notice_type`
-- ----------------------------
BEGIN;
INSERT INTO `notice_type` VALUES ('1', '新的评论消息', 'fa fa-comments text-orange'), ('2', '新的回复消息', 'fa fa-comment text-aqua'), ('3', '新的粉丝消息', 'fa fa-users text-red'), ('4', '新的回答消息', 'fa fa-comments text-orange'), ('5', '答案被回复', 'fa fa-comment text-aqua'), ('6', '答案被采纳', 'fa fa-check-circle text-success');
COMMIT;

-- ----------------------------
--  Table structure for `question`
-- ----------------------------
DROP TABLE IF EXISTS `question`;
CREATE TABLE `question` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `answer_size` int(11) DEFAULT NULL,
  `content` longtext NOT NULL,
  `create_time` datetime DEFAULT NULL,
  `guid` varchar(100) DEFAULT NULL,
  `status` varchar(10) DEFAULT NULL,
  `summary` varchar(2000) NOT NULL,
  `tags` varchar(100) DEFAULT NULL,
  `title` varchar(200) NOT NULL,
  `update_time` datetime DEFAULT NULL,
  `view_size` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `question`
-- ----------------------------
BEGIN;
INSERT INTO `question` VALUES ('1', '1', '<p>问题测试内容<br></p>', '2018-06-15 17:09:48', '/questions/1', 'resolved', '问题测试内容', '', '问题测试！！！', null, '52', '1'), ('2', '1', '<p>这里是问题描述！</p>', '2018-06-20 11:48:30', '/questions/2', 'publish', '这里是问题描述！', '', '测试问题！！！', null, '94', '1'), ('3', '4', '<p>是</p><p>大傻逼</p>', '2018-10-10 13:04:24', '/questions/3', 'resolved', '是大傻逼', '', '张彪是SB吗？', null, '16', '71'), ('4', '2', '<h1><span style=\"color: rgb(227, 55, 55); font-size: 1.5em;\"><mark>彩色文字</mark></span><br></h1><p>我是谁？？？？？</p>', '2018-10-12 14:08:00', '/questions/4', 'resolved', '彩色文字我是谁？？？？？', '', '我是谁？？？？？？？', null, '4', '75'), ('5', '1', '<p>不能很好理解Java Web的操作过程。</p>', '2018-10-12 15:40:46', '/questions/5', 'resolved', '不能很好理解Java Web的操作过程。', 'Java Web', '如何快速理解Java Web操作步骤？', null, '17', '78'), ('6', '1', '<p>我二七王二七王二七王而我却而我却二认为人情味</p>', '2018-10-17 10:38:10', '/questions/6', 'resolved', '我二七王二七王二七王而我却而我却二认为人情味', '', '为问问请问去玩儿为请问', null, '11', '71'), ('7', '0', '<p>12313</p>', '2018-10-18 19:42:18', '/questions/7', 'publish', '12313', 'java', '12313213', null, '9', '72'), ('8', '1', '<p>阿斯蒂芬</p>', '2018-10-22 20:44:31', '/questions/8', 'publish', '阿斯蒂芬', '邵登峰', '这些大V安抚说的的发送到樊ad个邵登峰给第三方', null, '6', '71'), ('9', '2', '<p>这是提问测试，不用回复</p>', '2018-10-27 20:20:59', '/questions/9', 'resolved', '这是提问测试，不用回复', '这个是提问测试,限制的太不合理了', '提问的测试', null, '18', '82'), ('10', '3', '<p>发范德萨发打发第三方撒飞洒发</p>', '2018-11-05 21:03:58', '/questions/10', 'resolved', '发范德萨发打发第三方撒飞洒发', '放大范德萨发', '反倒是大所多群所多群', null, '5', '75'), ('11', '0', '<p>发一个帖子，支持下站长的社区了，我也是一名coder。</p>', '2018-11-06 19:40:08', '/questions/11', 'publish', '发一个帖子，支持下站长的社区了，我也是一名coder。', '', '来支持CoderGroup社区了', null, '3', '88'), ('12', '0', '<p>test</p>', '2018-11-07 18:27:00', '/questions/12', 'publish', 'test', 'test', 'test1', null, '0', '78'), ('13', '0', '<p>test<br></p>', '2018-11-07 18:27:16', '/questions/13', 'publish', 'test', 'test', 'testtest', null, '0', '78'), ('14', '0', '<p>test<br></p>', '2018-11-07 18:27:27', '/questions/14', 'publish', 'test', 'test', 'test_test', null, '0', '78'), ('15', '0', '<p>hello_world！<br></p>', '2018-11-07 18:30:23', '/questions/15', 'publish', 'hello_world！', 'hello_world！', 'hello_world！', null, '0', '78'), ('16', '0', '<p>hello_world！<br></p>', '2018-11-07 18:30:32', '/questions/16', 'publish', 'hello_world！', 'hello_world！', 'hello_world！', null, '0', '78'), ('17', '0', '<p>hello_world！<br></p>', '2018-11-07 18:30:42', '/questions/17', 'publish', 'hello_world！', 'hello_world！', 'hello_world！', null, '0', '78'), ('18', '0', '<p>hello_world！<br></p>', '2018-11-07 18:30:49', '/questions/18', 'publish', 'hello_world！', 'hello_world！', 'hello_world！', null, '3', '78'), ('19', '1', '<p>hello_world！<br></p>', '2018-11-07 18:31:09', '/questions/19', 'publish', 'hello_world！', 'hello_world！', 'hello_world！', null, '1', '78'), ('20', '0', '<p>hello_world！<br></p>', '2018-11-07 18:31:16', '/questions/20', 'publish', 'hello_world！', 'hello_world！', 'hello_world！', null, '1', '78'), ('21', '0', '<p>hello_world！<br></p>', '2018-11-07 18:31:24', '/questions/21', 'publish', 'hello_world！', 'hello_world！', 'hello_world！', null, '5', '78'), ('22', '1', '<p>hello_world！<br></p>', '2018-11-07 18:31:31', '/questions/22', 'publish', 'hello_world！', 'hello_world！', 'hello_world！', null, '17', '78'), ('23', '2', '<p>没有问题</p>', '2018-11-08 20:41:47', '/questions/23', 'publish', '没有问题', 'fyj', 'fyjshsjhshss', null, '18', '77'), ('24', '4', '<pre><code class=\"lang-java\">//标签体的逻辑实际应该编写到此方法中\n&nbsp;@Override\n&nbsp;public&nbsp;void&nbsp;doTag()&nbsp;throws&nbsp;JspException, IOException&nbsp;{\n&nbsp; &nbsp;JspWriter out=pageContext.getOut();\n&nbsp; &nbsp;int&nbsp;c=0;\n&nbsp; &nbsp;c=Integer.parseInt(count);\n&nbsp; &nbsp;for(int&nbsp;i=0;i&lt;c;i++){\n&nbsp; &nbsp; &nbsp;out.print((i+1)+\":\"+value);\n&nbsp; &nbsp; &nbsp;out.print(\"&lt;br&gt;\");\n&nbsp; &nbsp;}\n&nbsp;}\n\n&nbsp;@Override\n&nbsp;public&nbsp;JspTag&nbsp;getParent()&nbsp;{\n&nbsp; &nbsp;System.out.println(\"getParent\");\n&nbsp; &nbsp;return&nbsp;null;\n&nbsp;}\n\n&nbsp;@Override\n&nbsp;public&nbsp;void&nbsp;setJspBody(JspFragment arg0)&nbsp;{\n&nbsp; &nbsp;System.out.println(\"setJspBody\");\n&nbsp;}\n&nbsp; &nbsp;private&nbsp;PageContext pageContext;\n&nbsp; &nbsp;//JSP引擎调用，把代表jsp页面的PageContext对象传入\n&nbsp;@Override\n&nbsp;public&nbsp;void&nbsp;setJspContext(JspContext arg0)&nbsp;{\n&nbsp; &nbsp;System.out.println(arg0&nbsp;instanceof&nbsp;PageContext);\n&nbsp; &nbsp;this.pageContext=(PageContext)arg0;\n&nbsp;}<br></code></pre>', '2018-11-16 14:35:45', '/questions/24', 'publish', '//标签体的逻辑实际应该编写到此方法中\n @Override\n public void doTag() throws JspException, IOException {', '小助手', '来逛逛，哈哈哈哈哈', null, '26', '98'), ('25', '1', '<p>sscesddd</p>', '2018-11-24 20:17:31', '/questions/25', 'resolved', 'sscesddd', '', 'cesss', null, '9', '104'), ('26', '2', '<p style=\"margin-left: 40px;\">QAQ，为什么你这么牛逼</p><hr><p><img alt=\"background.png\" src=\"http://cdn.codergroup.cn/uploads/2019/1/8/Empirefree/1546924367195\" width=\"60\" height=\"25\"><br></p>', '2019-01-08 13:10:19', '/questions/26', 'resolved', 'QAQ，为什么你这么牛逼<img alt=\"background.png\" src=\"http://cdn.codergroup.cn/uploads/2019/1/8/Empirefree/1546924367195', 'springboot', '测试用的问号？', '2019-01-08 13:12:48', '29', '115'), ('27', '0', '<p>&nbsp;为什么明天不上班</p>', '2019-03-08 17:02:30', '/questions/27', 'publish', ' 为什么明天不上班', '????', '明天不上班', '2019-03-08 20:01:59', '19', '113'), ('28', '1', '<p>java是什么东西</p>', '2019-04-02 09:29:19', '/questions/28', 'resolved', 'java是什么东西', '如何使用java', '怎么使用java', null, '8', '113'), ('29', '0', '<p>111111</p>', '2019-05-06 19:30:12', '/questions/29', 'publish', '111111', '是是', '11111111', '2019-05-06 19:31:03', '1', '153'), ('30', '0', '<p>11111</p>', '2019-05-06 19:30:13', '/questions/30', 'publish', '11111', '是是', '11111111', '2019-05-06 19:30:48', '1', '153');
COMMIT;

-- ----------------------------
--  Table structure for `relationship`
-- ----------------------------
DROP TABLE IF EXISTS `relationship`;
CREATE TABLE `relationship` (
  `to_user_id` int(11) NOT NULL,
  `from_user_id` int(11) NOT NULL,
  PRIMARY KEY (`to_user_id`,`from_user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `relationship`
-- ----------------------------
BEGIN;
INSERT INTO `relationship` VALUES ('1', '2'), ('1', '7'), ('1', '8'), ('1', '15'), ('1', '18'), ('1', '28'), ('1', '30'), ('1', '70'), ('1', '78'), ('1', '121'), ('2', '1'), ('3', '1'), ('4', '1'), ('5', '1'), ('6', '1'), ('7', '1'), ('7', '8'), ('7', '42'), ('7', '85'), ('8', '1'), ('8', '7'), ('9', '1'), ('10', '1'), ('15', '1'), ('16', '1'), ('18', '1'), ('19', '1'), ('27', '1'), ('28', '1'), ('30', '1'), ('42', '7'), ('54', '77'), ('70', '97'), ('71', '1'), ('71', '77'), ('71', '78'), ('71', '82'), ('77', '78'), ('78', '1'), ('82', '71'), ('82', '77'), ('94', '77'), ('120', '121'), ('122', '127');
COMMIT;

-- ----------------------------
--  Table structure for `slide`
-- ----------------------------
DROP TABLE IF EXISTS `slide`;
CREATE TABLE `slide` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `guid` varchar(255) DEFAULT NULL,
  `picture` varchar(255) DEFAULT NULL,
  `position` int(11) DEFAULT NULL,
  `status` varchar(255) DEFAULT NULL,
  `title` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `slide`
-- ----------------------------
BEGIN;
INSERT INTO `slide` VALUES ('1', '#', '/img/slide-1.jpg', '5', 'publish', '欢迎加入 CoderGroup'), ('2', '#', '/img/slide-2.jpg', '2', 'publish', '技术分享，疑难求助，简单而方便'), ('4', '#', '/img/slide-4.jpg', '1', 'publish', '程序人生，义无反顾');
COMMIT;

-- ----------------------------
--  Table structure for `tag`
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `article_size` int(11) DEFAULT NULL,
  `guid` varchar(255) DEFAULT NULL,
  `name` varchar(20) DEFAULT NULL,
  `position` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_1wdpsed5kna2y38hnbgrnhi5b` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `tag`
-- ----------------------------
BEGIN;
INSERT INTO `tag` VALUES ('1', null, '/search/articles?keywords=面试', '面试', '1'), ('2', null, '/article?keywords=源码', '源码', '1'), ('3', null, '/search/articles?keywords=Java', 'Java', '1'), ('4', null, '/article?keywords=算法', '算法', '1'), ('5', null, '/search/article?keywords=数据结构', '数据结构', '1'), ('6', null, '/search/articles?keywords=计算机网络', '计算机网络', '1'), ('7', null, '/search/articles?keywords=操作系统', '操作系统', '1'), ('8', null, '/search/articles?keywords=test', 'test', '1');
COMMIT;

-- ----------------------------
--  Table structure for `user`
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `answer_size` bigint(20) DEFAULT NULL,
  `article_size` bigint(20) DEFAULT NULL,
  `avatar` varchar(200) DEFAULT NULL,
  `contact` varchar(100) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `email` varchar(50) NOT NULL,
  `fan_size` bigint(20) DEFAULT NULL,
  `follow_size` bigint(20) DEFAULT NULL,
  `github` varchar(50) DEFAULT NULL,
  `homepage` varchar(50) DEFAULT NULL,
  `is_verify_email` varchar(1) DEFAULT NULL,
  `last_login_time` datetime DEFAULT NULL,
  `nickname` varchar(30) NOT NULL,
  `password` varchar(100) NOT NULL,
  `profile` varchar(1000) DEFAULT NULL,
  `question_size` bigint(20) DEFAULT NULL,
  `reputation` int(11) DEFAULT NULL,
  `status` varchar(255) DEFAULT NULL,
  `username` varchar(20) NOT NULL,
  `view_size` bigint(20) DEFAULT NULL,
  `job_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_ob8kqyqqgmefl0aco34akdtpe` (`email`),
  UNIQUE KEY `UK_sb8bbouer5wak8vyiiy4pf2bx` (`username`)
) ENGINE=InnoDB AUTO_INCREMENT=141 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `user`
-- ----------------------------
BEGIN;
INSERT INTO `user` VALUES ('1', '0', '41', 'http://www.gravatar.com/avatar/3ae8728fec3cd5cbfe99c4b966695f03?s=128&d=identicon&r=PG', 'QQ: 847064370(微信同号)', '2018-06-14 02:47:12', '847064370@qq.com', '10', '18', 'http://github.com/saysky', 'https://liuyanzhao.com', 'N', '2019-06-01 22:42:29', '言曌', '$2a$10$I.y/2D.GcYFvY3k6n0ifNO3Xq38YrkIDuwxVp.iAt/9W4t2RxBCIC', '<p>山无陵，江水为竭。冬雷震震，夏雨雪。天地合，乃敢与君绝。</p>\r\n<p class=\"text-maroon\">长期求实习和内推等就业机会！</p>\r\n\r\n', '0', '536', 'normal', 'saysky', '1', '2'), ('7', '0', '5', 'http://cdn.codergroup.cn/uploads/2018/7/6/ai211932/1530844254014', '1092702721', '2018-06-15 14:43:27', '111@qq.com', '4', '3', 'https://github.com/ai211932', '', 'Y', '2018-09-15 17:45:41', '刘某人', '$2a$10$U/HsZzN3ty4yKkNyH5WR.eZOAMD8XuGhTMft4rBiITp4vYeXGTjBm', '那天我痴痴的望着你性感的身躯一丝不挂地在我面前扭动，轻轻地抚摸你的肌肤，我无法抵挡住你的诱惑......“老板，我要这条鱼”', '0', '168', 'normal', 'ai211932', '1', '3'), ('8', '0', '2', 'http://cdn.codergroup.cn/uploads/2018/6/18/qiqi/1529331879879', null, '2018-06-15 15:26:03', '222@qq.com', '2', '2', null, null, 'N', '2019-02-16 20:59:44', 'qiqi', '$2a$10$nlwWeSq3thwbSm9jq.DW1.pRRXmrjrjsLMkpyWwg7y0aVG07/jgQG', null, '0', '36', 'normal', 'qiqi', '1', '1'), ('9', '0', '1', 'http://www.gravatar.com/avatar/7c55e74423287b25e4f36cbbb706d0f9?s=128&d=identicon&r=PG', null, '2018-06-17 20:46:23', '333@qq.com', '0', '0', '', '', 'N', '2018-07-06 15:22:04', 'HickSalmon', '$2a$10$IIOUuWLMQksb2eYT7dsQ4.S3KeufU0hT0K6Cu4g/VOT1gAiY4mpE2', '', '0', '22', 'normal', 'HickSalmon', '1', '1'), ('10', '0', '8', 'http://www.gravatar.com/avatar/e0438b47141558af1473cbd84e5a4c63?s=128&d=identicon&r=PG', null, '2018-06-17 20:54:24', '333@sina.com', '1', '0', null, null, 'N', '2018-06-17 20:54:24', 'xinyue', '$2a$10$zemJun.5c5JY.7pvMGbkfO6/HzqcqO2Tzcm/K6vndZHoC0V97U9DG', null, '0', '20', 'normal', 'xinyue', '1', '1'), ('23', '0', '36', 'http://thirdqq.qlogo.cn/qqapp/101472393/7E52AF82A3534AE6836335B1393DE1DC/100', null, '2018-07-03 16:38:15', '3332@qq.com', '0', '0', null, null, 'Y', '2018-07-03 16:38:15', '潘多拉魔盒', '$2a$10$i8JJOD/xT8qVIKSDDYm9o.tRXf7N18Yfw.5jDTn51vYG1pWF698fe', null, '0', '20', 'normal', 'l1012384', '1', '1'), ('31', '0', '1', 'http://www.gravatar.com/avatar/d1d3ff672d2fd49286b79d0b3dc30016?s=128&d=identicon&r=PG', null, '2018-07-11 00:41:15', '123@qq.com', '0', '0', null, null, 'N', '2018-07-11 00:41:15', 'admin1', '$2a$10$EIHnV.iDtL6K3PmxWmN4CORHEbIhqZUubZWmXH6gCAbFwhEHptdW.', null, '0', '20', 'normal', 'admin1', '1', '1'), ('33', '0', '1', 'http://www.gravatar.com/avatar/c1b5364130884363fe0b3cebe9a49083?s=128&d=identicon&r=PG', null, '2018-07-12 21:06:45', 'you@gmail.com', '0', '0', null, null, 'N', '2018-07-12 21:06:45', 'poker', '$2a$10$3374j2nZKwBVnZJ1g9y09e73EtvfAeoi6gzUNpxG1nu/uJMay4Mbq', null, '0', '20', 'normal', 'poker', '1', '1'), ('48', '0', '1', 'http://thirdqq.qlogo.cn/qqapp/101472393/2293CF0CC64A50324C348E03F5F60874/100', null, '2018-08-17 22:19:29', '584201871@qq.com', '0', '0', null, null, 'Y', '2018-08-17 22:20:27', '在风中等你?', '$2a$10$IRk305yA0cXtushFns7sy.SuBLsPcekSdxR1yQFVJi1YZZOlDhnIy', null, '0', '30', 'normal', 'wangbing1991', '1', '1'), ('54', '0', '2', 'http://cdn.codergroup.cn/uploads/2018/8/30/codegroup/1535643223434', '', '2018-08-30 22:37:42', '123456@qq.com', '1', '0', '', '', 'N', '2018-08-31 15:17:50', 'codegroup', '$2a$10$qzqGd6jPL7oSjZAjGSLLXuDNKkXiT2XHl9CxTG20CtK5moDrmeKG6', '哈哈哈哈', '0', '75', 'normal', 'codegroup', '1', '1'), ('59', '0', '1', 'http://thirdqq.qlogo.cn/qqapp/101472393/206DA74F9BB45F02A2E778077E5ED984/100', null, '2018-09-11 00:00:24', '11022995396@qq.com', '0', '0', null, null, 'Y', '2019-01-14 23:28:46', 'OscarDBQ', '$2a$10$YzIRVtLDsjqFujNXIw/Iq.jpiYh7ewq2Qvlc4lgOUxoVmA42QkYo2', null, '0', '30', 'normal', 'achi', '1', '1'), ('70', '0', '1', 'http://thirdqq.qlogo.cn/qqapp/101472393/8FBE18109DC95CDDED943DE8E05DC540/100', null, '2018-10-03 11:00:28', '613041@qq.com', '1', '1', null, null, 'Y', '2018-11-13 19:44:00', 'Aurora of Lewis', '$2a$10$QqsYkqRKpRhc9rJ1Mj/brueGm0tczIOaa26k3Ds1iUJsArbFxPjum', null, '0', '35', 'normal', 'Lewis', '1', '1'), ('71', '0', '13', 'http://www.gravatar.com/avatar/8fe55fcdfd4b227f4fdbaf0f08196186?s=128&d=identicon&r=PG', null, '2018-10-10 11:53:33', '4333@qq.com', '4', '1', null, null, 'N', '2018-11-10 13:13:19', 'sunweijia', '$2a$10$rHFVIAXOHwzK70kPTKnc0eEYCse64FBMAt/4kWD/E7bZKZ4vFq9F6', null, '0', '288', 'normal', 'sunweijia', '1', '1'), ('77', '0', '2', 'http://cdn.codergroup.cn/uploads/2018/11/8/test1/1541664542479', 'qq739090072', '2018-10-11 20:36:38', '435678@qq.com', '1', '4', '', '', 'Y', '2018-11-02 14:13:41', '南城花已开', '$2a$10$DmAjnLEQnW0r9unQ3.iMnOU4So.mvKtzZAevB621pT0k9EBZ0DUca', '这个人很懒什么也没有留下...', '0', '50', 'normal', 'test1', '1', '2'), ('82', '0', '1', 'http://thirdqq.qlogo.cn/qqapp/101472393/74F0DCD3BB4FF2E27FC65E6273103B98/100', null, '2018-10-27 20:14:19', 'sadfsdf@qq.com', '2', '1', null, null, 'N', '2018-10-30 15:08:10', '暖暖的风', '$2a$10$YC9oDZ4cEMnNi.uEkbtcfe1YchAG9F5UGeZzWIfDg/5Tvuse7wLUe', null, '0', '48', 'normal', 'qwertyuiop', '1', '1'), ('93', '0', '1', 'http://www.gravatar.com/avatar/f1545d13d4dade804eee440808eedf40?s=128&d=identicon&r=PG', null, '2018-11-08 15:32:09', '2748365@qq.com', '0', '0', null, null, 'N', '2019-01-25 17:29:03', 'Zachary', '$2a$10$ryLfE0VXvq1mIlb0L3sEa.OxhHejRZMOLfdX.iAuzjdDmeNqzaDGq', null, '0', '35', 'normal', 'Zachary', '1', '1'), ('94', '0', '1', 'http://www.gravatar.com/avatar/5c12806622f9e6f69ddac2798c1fe371?s=128&d=identicon&r=PG', null, '2018-11-08 20:36:19', '2anyang@hotmail.com', '1', '0', null, null, 'Y', '2018-11-08 20:36:19', 'Albert', '$2a$10$FIHnzy4bSD5zrkmhlqblRerbsHyCofEc44MIDi9T.KT53UWJvAKbK', null, '0', '20', 'normal', 'Albert', '1', '1'), ('96', '0', '1', 'http://www.gravatar.com/avatar/5be46f16285ee5b8551731c7a28c1c43?s=128&d=identicon&r=PG', null, '2018-11-11 22:38:59', '294266@qq.com', '0', '0', null, null, 'Y', '2018-11-11 22:38:59', 'chenzi', '$2a$10$srRrwHBdFgUfpd6L5NQpm.g1n9tvpo2AKiprCIkT91paG60ginXfi', null, '0', '29', 'normal', 'chenzi', '1', '1'), ('101', '0', '1', 'http://thirdqq.qlogo.cn/qqapp/101472393/035E5AE504FE740A69EA6D3BF435E184/100', null, '2018-11-18 19:48:07', '33130276@163.com', '0', '0', null, null, 'N', '2018-11-19 09:49:57', '?®™™™™?', '$2a$10$zS0NyFBj3W0DlEa0J8znnO8MVI61jDeKq5PbzX40E8DKcvzoH7i6y', null, '0', '41', 'normal', 'mmma', '1', '1'), ('102', '0', '1', 'http://www.gravatar.com/avatar/f425f2f91b6bbecdc26242366f3d0c82?s=128&d=identicon&r=PG', null, '2018-11-19 15:47:02', '3809252882@qq.com', '0', '0', null, null, 'N', '2018-11-20 22:37:07', 'jlb0906', '$2a$10$CGlQUkk0xJjDsTIAbtLzsOqXHUrmhfV.cKB4NXTBH0RkuRMXPzCSi', null, '0', '25', 'normal', 'jlb0906', '1', '1'), ('113', '0', '4', 'http://www.gravatar.com/avatar/2d9234e6da3d407827c3025efccf47b8?s=128&d=identicon&r=PG', '863146675', '2018-12-29 14:06:36', '3863146675@qq.com', '0', '0', '', '', 'Y', '2019-04-12 08:37:55', 'qwe86314', '$2a$10$MqklorkjkwAemAxLc03Ft.GNui6lF14nZQdM3gQTxoP/rttyK5wie', 'alert(\"xxx\");', '0', '165', 'normal', 'qwe86314', '1', '1'), ('115', '0', '2', 'http://cdn.codergroup.cn/uploads/2019/1/10/Empirefree/1547086807569', null, '2019-01-08 12:59:17', '349680@qq.com', '0', '0', null, null, 'Y', '2019-03-26 18:30:56', 'Empirefree', '$2a$10$98FrD8ial8yQdta788g2x.Km3lAP8Lp9wMuk67snpkOBGSexyuuIO', null, '0', '64', 'normal', 'Empirefree', '1', '1'), ('120', '0', '1', 'http://www.gravatar.com/avatar/6ab20f07fc4adceda6347dbac18a081b?s=128&d=identicon&r=PG', null, '2019-01-18 14:46:41', '38675@qq.com', '1', '0', null, null, 'Y', '2019-01-18 14:46:41', 'Hhc0917', '$2a$10$S1r3m1liZBP5yBMcIgc3AuDwW77X2v9ZPAjWgzi4uYzcwburYdC72', null, '0', '20', 'normal', 'Hhc0917', '1', '1'), ('122', '0', '1', 'http://www.gravatar.com/avatar/b130ec9d374885695c3ce7c585918300?s=128&d=identicon&r=PG', null, '2019-01-24 09:51:30', '3dc518@qq.com', '1', '0', null, null, 'Y', '2019-01-24 09:51:30', 'gszdc', '$2a$10$WbYhfYBk/3YAWe0foZ00xeU9hleXkzR.G1F842EH7x3HROcA7aPo2', null, '0', '42', 'normal', 'gszdc', '1', '1'), ('139', '0', '1', 'http://www.gravatar.com/avatar/e7c7b6eb675ba780985c7e1cbadd2484?s=128&d=identicon&r=PG', null, '2019-03-15 21:00:09', '3sy@gmail.com', '0', '0', null, null, 'N', '2019-03-16 19:10:46', 'fantasy', '$2a$10$kQB12BTgGTm0d.ml/tc05.JqwE.mvW4ZPXPkb4REL4mjaP/fw9lsi', null, '0', '22', 'normal', 'fantasy', '1', '1'), ('140', '0', '1', 'http://www.gravatar.com/avatar/fb04a8d441dcb3cb1296a3b7f2858d2d?s=128&d=identicon&r=PG', null, '2019-03-19 12:57:45', '3608572@163.com', '0', '0', null, null, 'Y', '2019-03-21 09:36:17', 'qbian', '$2a$10$Y2J1lqdS7kS2wDw7xQh9T.qARBogJEP4ZcRWh3yftyixow79RLtuO', null, '0', '37', 'normal', 'qbian', '1', '1');
COMMIT;

-- ----------------------------
--  Table structure for `user_authority`
-- ----------------------------
DROP TABLE IF EXISTS `user_authority`;
CREATE TABLE `user_authority` (
  `user_id` int(11) NOT NULL,
  `authority_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `user_authority`
-- ----------------------------
BEGIN;
INSERT INTO `user_authority` VALUES ('1', '2'), ('1', '1'), ('2', '2'), ('3', '2'), ('4', '2'), ('5', '2'), ('6', '2'), ('7', '2'), ('8', '2'), ('10', '2'), ('11', '2'), ('12', '2'), ('13', '2'), ('14', '2'), ('15', '2'), ('16', '2'), ('17', '2'), ('18', '2'), ('19', '2'), ('21', '2'), ('22', '2'), ('23', '2'), ('24', '2'), ('25', '2'), ('26', '2'), ('9', '2'), ('27', '2'), ('28', '2'), ('29', '2'), ('30', '2'), ('31', '2'), ('32', '2'), ('33', '2'), ('34', '2'), ('35', '2'), ('36', '2'), ('37', '2'), ('38', '2'), ('39', '2'), ('40', '2'), ('41', '2'), ('42', '2'), ('43', '2'), ('44', '2'), ('45', '2'), ('46', '2'), ('47', '2'), ('48', '2'), ('49', '2'), ('50', '2'), ('51', '2'), ('52', '2'), ('53', '2'), ('54', '2'), ('55', '2'), ('56', '2'), ('57', '2'), ('58', '2'), ('59', '2'), ('60', '2'), ('61', '2'), ('62', '2'), ('63', '2'), ('64', '2'), ('65', '2'), ('66', '2'), ('67', '2'), ('68', '2'), ('69', '2'), ('70', '2'), ('20', '2'), ('71', '2'), ('72', '2'), ('73', '2'), ('74', '2'), ('75', '2'), ('76', '2'), ('77', '2'), ('78', '2'), ('79', '2'), ('80', '2'), ('81', '2'), ('82', '2'), ('83', '2'), ('84', '2'), ('85', '2'), ('86', '2'), ('87', '2'), ('88', '2'), ('89', '2'), ('90', '2'), ('91', '2'), ('92', '2'), ('93', '2'), ('94', '2'), ('95', '2'), ('96', '2'), ('97', '2'), ('98', '2'), ('99', '2'), ('100', '2'), ('101', '2'), ('102', '2'), ('103', '2'), ('104', '2'), ('105', '2'), ('106', '2'), ('107', '2'), ('108', '2'), ('109', '2'), ('110', '2'), ('111', '2'), ('112', '2'), ('113', '2'), ('114', '2'), ('115', '2'), ('116', '2'), ('117', '2'), ('118', '2'), ('119', '2'), ('120', '2'), ('121', '2'), ('122', '2'), ('123', '2'), ('124', '2'), ('125', '2'), ('126', '2'), ('127', '2'), ('128', '2'), ('129', '2'), ('130', '2'), ('131', '2'), ('132', '2'), ('133', '2'), ('134', '2'), ('135', '2'), ('136', '2'), ('137', '2'), ('138', '2'), ('139', '2'), ('140', '2'), ('141', '2'), ('142', '2'), ('149', '2'), ('152', '2'), ('153', '2'), ('150', '2');
COMMIT;

-- ----------------------------
--  Table structure for `zan`
-- ----------------------------
DROP TABLE IF EXISTS `zan`;
CREATE TABLE `zan` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `create_time` datetime DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=163 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Records of `zan`
-- ----------------------------
BEGIN;
INSERT INTO `zan` VALUES ('1', '2018-06-14 03:13:40', '1'), ('2', '2018-06-15 15:46:59', '8'), ('3', '2018-06-15 15:56:59', '8'), ('4', '2018-06-15 15:57:01', '8'), ('5', '2018-06-15 15:57:04', '8'), ('6', '2018-06-15 15:57:08', '8'), ('7', '2018-06-15 16:25:53', '8'), ('8', '2018-06-18 22:34:49', '8'), ('9', '2018-06-18 22:38:46', '8'), ('10', '2018-06-18 22:38:48', '8'), ('11', '2018-06-18 22:39:05', '8'), ('12', '2018-06-19 15:33:51', '1'), ('13', '2018-06-19 23:26:50', '11'), ('14', '2018-06-20 11:40:49', '1'), ('15', '2018-06-20 19:48:15', '17'), ('16', '2018-06-20 19:48:16', '17'), ('17', '2018-06-20 20:07:46', '17'), ('18', '2018-06-20 20:07:47', '17'), ('19', '2018-06-20 20:07:50', '17'), ('20', '2018-06-20 20:07:53', '17'), ('21', '2018-06-20 20:08:12', '17'), ('22', '2018-07-06 09:34:11', '7'), ('23', '2018-07-06 09:34:29', '7'), ('24', '2018-07-06 10:21:49', '7'), ('25', '2018-07-07 18:10:31', '1'), ('26', '2018-07-08 22:31:16', '7'), ('27', '2018-07-11 08:45:06', '7'), ('28', '2018-07-11 22:41:16', '1'), ('29', '2018-08-15 10:54:30', '7'), ('30', '2018-08-20 12:13:29', '50'), ('31', '2018-08-20 16:57:53', '7'), ('32', '2018-08-24 11:23:54', '51'), ('33', '2018-08-24 11:24:41', '51'), ('34', '2018-08-24 11:24:44', '51'), ('35', '2018-08-30 22:40:17', '54'), ('36', '2018-08-30 23:24:49', '54'), ('37', '2018-08-30 23:36:59', '54'), ('38', '2018-09-03 12:51:36', '56'), ('39', '2018-09-05 11:25:56', '51'), ('40', '2018-09-19 22:38:05', '62'), ('41', '2018-10-03 11:02:28', '70'), ('42', '2018-10-10 12:59:59', '72'), ('43', '2018-10-10 13:06:09', '71'), ('44', '2018-10-10 13:06:09', '71'), ('45', '2018-10-10 13:06:10', '71'), ('46', '2018-10-10 13:06:10', '71'), ('47', '2018-10-10 13:06:10', '71'), ('48', '2018-10-10 14:28:44', '71'), ('49', '2018-10-10 14:28:50', '71'), ('50', '2018-10-12 14:06:54', '75'), ('51', '2018-10-12 14:06:56', '75'), ('52', '2018-10-12 15:36:35', '78'), ('53', '2018-10-17 10:57:13', '75'), ('54', '2018-10-17 10:57:17', '75'), ('55', '2018-10-26 10:59:50', '71'), ('56', '2018-10-27 14:52:42', '71'), ('57', '2018-10-27 15:42:00', '72'), ('58', '2018-10-27 19:15:56', '71'), ('59', '2018-10-27 20:18:41', '82'), ('60', '2018-10-27 20:30:49', '82'), ('61', '2018-10-27 20:30:57', '82'), ('62', '2018-10-30 15:11:15', '71'), ('63', '2018-10-30 17:08:16', '71'), ('64', '2018-10-30 17:08:17', '71'), ('65', '2018-10-31 11:50:48', '85'), ('66', '2018-10-31 18:31:16', '71'), ('67', '2018-10-31 18:44:21', '71'), ('68', '2018-10-31 18:44:45', '71'), ('69', '2018-10-31 23:45:33', '71'), ('70', '2018-11-01 16:27:54', '71'), ('71', '2018-11-01 18:58:55', '75'), ('72', '2018-11-01 18:58:59', '75'), ('73', '2018-11-04 12:52:31', '71'), ('74', '2018-11-04 12:52:32', '71'), ('75', '2018-11-04 12:52:33', '71'), ('76', '2018-11-04 12:52:34', '71'), ('77', '2018-11-04 12:52:35', '71'), ('78', '2018-11-05 17:15:52', '75'), ('79', '2018-11-05 19:31:55', '71'), ('80', '2018-11-05 19:32:06', '71'), ('81', '2018-11-05 19:32:09', '71'), ('82', '2018-11-05 20:26:46', '71'), ('83', '2018-11-05 20:26:48', '71'), ('84', '2018-11-05 20:26:51', '71'), ('85', '2018-11-05 21:01:13', '75'), ('86', '2018-11-05 21:01:16', '75'), ('87', '2018-11-05 21:01:18', '75'), ('88', '2018-11-05 21:01:22', '75'), ('89', '2018-11-05 21:04:08', '75'), ('90', '2018-11-05 21:04:15', '75'), ('91', '2018-11-05 21:04:30', '75'), ('92', '2018-11-05 21:04:34', '75'), ('93', '2018-11-05 22:00:09', '71'), ('94', '2018-11-08 20:38:36', '71'), ('95', '2018-11-08 20:49:17', '94'), ('96', '2018-11-10 20:45:59', '71'), ('97', '2018-11-11 22:42:43', '96'), ('98', '2018-11-11 22:42:44', '96'), ('99', '2018-11-11 22:44:08', '96'), ('100', '2018-11-13 19:45:57', '70'), ('101', '2018-11-13 20:28:12', '97'), ('102', '2018-11-18 21:31:23', '101'), ('103', '2018-11-18 21:31:25', '101'), ('104', '2018-11-18 21:31:26', '101'), ('105', '2018-11-18 21:31:27', '101'), ('106', '2018-11-18 21:31:49', '101'), ('107', '2018-11-20 10:26:47', '103'), ('108', '2018-11-24 20:26:28', '104'), ('109', '2018-11-24 20:26:30', '104'), ('110', '2018-11-24 20:26:33', '104'), ('111', '2018-12-19 19:43:27', '22'), ('112', '2018-12-20 14:19:16', '93'), ('113', '2018-12-24 15:00:14', '111'), ('114', '2019-01-01 21:46:23', '1'), ('115', '2019-01-08 13:02:55', '115'), ('116', '2019-01-08 13:51:17', '115'), ('117', '2019-01-08 13:51:23', '115'), ('118', '2019-01-21 18:42:08', '121'), ('119', '2019-01-24 09:54:28', '122'), ('120', '2019-01-25 17:30:38', '93'), ('121', '2019-01-28 13:59:12', '93'), ('122', '2019-02-22 11:31:18', '126'), ('123', '2019-02-24 22:12:05', '128'), ('124', '2019-03-01 12:32:45', '111'), ('125', '2019-03-01 17:38:09', '111'), ('126', '2019-03-01 17:45:14', '129'), ('127', '2019-03-12 18:39:04', '113'), ('128', '2019-03-14 14:16:14', '136'), ('129', '2019-03-14 15:23:37', '113'), ('130', '2019-03-15 16:14:41', '136'), ('131', '2019-03-15 16:14:42', '136'), ('132', '2019-03-15 16:14:43', '136'), ('133', '2019-03-15 16:14:44', '136'), ('134', '2019-03-15 16:14:49', '136'), ('135', '2019-03-15 16:14:52', '136'), ('136', '2019-03-15 21:18:04', '113'), ('137', '2019-03-15 21:18:05', '113'), ('138', '2019-03-15 21:19:31', '113'), ('139', '2019-03-19 21:12:23', '140'), ('140', '2019-03-21 07:59:31', '113'), ('141', '2019-03-21 07:59:45', '113'), ('142', '2019-03-21 07:59:47', '113'), ('143', '2019-03-21 07:59:49', '113'), ('144', '2019-03-21 15:08:42', '111'), ('145', '2019-03-21 15:08:44', '111'), ('146', '2019-03-21 15:08:49', '111'), ('147', '2019-03-26 18:42:57', '115'), ('148', '2019-03-26 18:42:59', '115'), ('149', '2019-03-26 18:42:59', '115'), ('150', '2019-03-26 18:43:00', '115'), ('151', '2019-03-26 18:43:00', '115'), ('152', '2019-03-26 18:43:01', '115'), ('153', '2019-03-30 21:04:26', '113'), ('154', '2019-03-30 21:08:13', '113'), ('155', '2019-03-30 21:08:55', '113'), ('156', '2019-03-30 21:08:57', '113'), ('157', '2019-03-30 21:08:59', '113'), ('158', '2019-04-02 09:27:37', '113'), ('159', '2019-04-02 09:27:44', '113'), ('160', '2019-04-02 09:27:53', '113'), ('161', '2019-04-04 09:55:34', '113'), ('162', '2019-04-04 09:56:00', '113');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
